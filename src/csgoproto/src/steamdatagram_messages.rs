// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steamdatagram_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramRouterPingReply)
pub struct CMsgSteamDatagramRouterPingReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_datacenter_ids)
    pub latency_datacenter_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.latency_ping_ms)
    pub latency_ping_ms: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramRouterPingReply.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramRouterPingReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramRouterPingReply {
    fn default() -> &'a CMsgSteamDatagramRouterPingReply {
        <CMsgSteamDatagramRouterPingReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramRouterPingReply {
    pub fn new() -> CMsgSteamDatagramRouterPingReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 1;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 4;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 5;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 6;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 7;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.client_timestamp },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "latency_datacenter_ids",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_datacenter_ids },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_datacenter_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "latency_ping_ms",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.latency_ping_ms },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.latency_ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_ip",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.your_public_ip },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.your_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_time",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.server_time },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.server_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.challenge },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramRouterPingReply| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramRouterPingReply| { &mut m.client_cookie },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramRouterPingReply>(
            "CMsgSteamDatagramRouterPingReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramRouterPingReply {
    const NAME: &'static str = "CMsgSteamDatagramRouterPingReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    is.read_repeated_packed_fixed32_into(&mut self.latency_datacenter_ids)?;
                },
                21 => {
                    self.latency_datacenter_ids.push(is.read_fixed32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.latency_ping_ms)?;
                },
                24 => {
                    self.latency_ping_ms.push(is.read_uint32()?);
                },
                37 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                49 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                56 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::vec_packed_fixed32_size(2, &self.latency_datacenter_ids);
        my_size += ::protobuf::rt::vec_packed_uint32_size(3, &self.latency_ping_ms);
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(1, v)?;
        }
        os.write_repeated_packed_fixed32(2, &self.latency_datacenter_ids)?;
        os.write_repeated_packed_uint32(3, &self.latency_ping_ms)?;
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramRouterPingReply {
        CMsgSteamDatagramRouterPingReply::new()
    }

    fn clear(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
        self.latency_datacenter_ids.clear();
        self.latency_ping_ms.clear();
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramRouterPingReply {
        static instance: CMsgSteamDatagramRouterPingReply = CMsgSteamDatagramRouterPingReply {
            client_timestamp: ::std::option::Option::None,
            latency_datacenter_ids: ::std::vec::Vec::new(),
            latency_ping_ms: ::std::vec::Vec::new(),
            your_public_ip: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramRouterPingReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramRouterPingReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramRouterPingReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramRouterPingReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverPing)
pub struct CMsgSteamDatagramGameserverPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.client_session)
    pub client_session: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.router_timestamp)
    pub router_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.router_gameserver_latency)
    pub router_gameserver_latency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.seq_number_router)
    pub seq_number_router: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverPing.seq_number_e2e)
    pub seq_number_e2e: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverPing {
    fn default() -> &'a CMsgSteamDatagramGameserverPing {
        <CMsgSteamDatagramGameserverPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverPing {
    pub fn new() -> CMsgSteamDatagramGameserverPing {
        ::std::default::Default::default()
    }

    // optional uint32 client_session = 1;

    pub fn client_session(&self) -> u32 {
        self.client_session.unwrap_or(0)
    }

    pub fn clear_client_session(&mut self) {
        self.client_session = ::std::option::Option::None;
    }

    pub fn has_client_session(&self) -> bool {
        self.client_session.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session(&mut self, v: u32) {
        self.client_session = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 2;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_timestamp = 3;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;

    pub fn router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }

    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;

    pub fn router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }

    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_router = 6;

    pub fn seq_number_router(&self) -> u32 {
        self.seq_number_router.unwrap_or(0)
    }

    pub fn clear_seq_number_router(&mut self) {
        self.seq_number_router = ::std::option::Option::None;
    }

    pub fn has_seq_number_router(&self) -> bool {
        self.seq_number_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_router(&mut self, v: u32) {
        self.seq_number_router = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_number_e2e = 7;

    pub fn seq_number_e2e(&self) -> u32 {
        self.seq_number_e2e.unwrap_or(0)
    }

    pub fn clear_seq_number_e2e(&mut self) {
        self.seq_number_e2e = ::std::option::Option::None;
    }

    pub fn has_seq_number_e2e(&self) -> bool {
        self.seq_number_e2e.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_number_e2e(&mut self, v: u32) {
        self.seq_number_e2e = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session",
            |m: &CMsgSteamDatagramGameserverPing| { &m.client_session },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.client_session },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_steam_id",
            |m: &CMsgSteamDatagramGameserverPing| { &m.client_steam_id },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.client_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CMsgSteamDatagramGameserverPing| { &m.client_timestamp },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_timestamp",
            |m: &CMsgSteamDatagramGameserverPing| { &m.router_timestamp },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.router_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_gameserver_latency",
            |m: &CMsgSteamDatagramGameserverPing| { &m.router_gameserver_latency },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.router_gameserver_latency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_number_router",
            |m: &CMsgSteamDatagramGameserverPing| { &m.seq_number_router },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.seq_number_router },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_number_e2e",
            |m: &CMsgSteamDatagramGameserverPing| { &m.seq_number_e2e },
            |m: &mut CMsgSteamDatagramGameserverPing| { &mut m.seq_number_e2e },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverPing>(
            "CMsgSteamDatagramGameserverPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverPing {
    const NAME: &'static str = "CMsgSteamDatagramGameserverPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_session = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.router_gameserver_latency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_number_router = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.seq_number_e2e = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_session {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_number_router {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.seq_number_e2e {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_session {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_number_router {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.seq_number_e2e {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverPing {
        CMsgSteamDatagramGameserverPing::new()
    }

    fn clear(&mut self) {
        self.client_session = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.client_timestamp = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seq_number_router = ::std::option::Option::None;
        self.seq_number_e2e = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverPing {
        static instance: CMsgSteamDatagramGameserverPing = CMsgSteamDatagramGameserverPing {
            client_session: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            client_timestamp: ::std::option::Option::None,
            router_timestamp: ::std::option::Option::None,
            router_gameserver_latency: ::std::option::Option::None,
            seq_number_router: ::std::option::Option::None,
            seq_number_e2e: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramGameServerAuthTicket)
pub struct CMsgSteamDatagramGameServerAuthTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.time_expiry)
    pub time_expiry: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.authorized_steam_id)
    pub authorized_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.authorized_public_ip)
    pub authorized_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.gameserver_steam_id)
    pub gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.gameserver_net_id)
    pub gameserver_net_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.extra_fields)
    pub extra_fields: ::std::vec::Vec<cmsg_steam_datagram_game_server_auth_ticket::ExtraField>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameServerAuthTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameServerAuthTicket {
    fn default() -> &'a CMsgSteamDatagramGameServerAuthTicket {
        <CMsgSteamDatagramGameServerAuthTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameServerAuthTicket {
    pub fn new() -> CMsgSteamDatagramGameServerAuthTicket {
        ::std::default::Default::default()
    }

    // optional fixed32 time_expiry = 1;

    pub fn time_expiry(&self) -> u32 {
        self.time_expiry.unwrap_or(0)
    }

    pub fn clear_time_expiry(&mut self) {
        self.time_expiry = ::std::option::Option::None;
    }

    pub fn has_time_expiry(&self) -> bool {
        self.time_expiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expiry(&mut self, v: u32) {
        self.time_expiry = ::std::option::Option::Some(v);
    }

    // optional fixed64 authorized_steam_id = 2;

    pub fn authorized_steam_id(&self) -> u64 {
        self.authorized_steam_id.unwrap_or(0)
    }

    pub fn clear_authorized_steam_id(&mut self) {
        self.authorized_steam_id = ::std::option::Option::None;
    }

    pub fn has_authorized_steam_id(&self) -> bool {
        self.authorized_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_steam_id(&mut self, v: u64) {
        self.authorized_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 authorized_public_ip = 3;

    pub fn authorized_public_ip(&self) -> u32 {
        self.authorized_public_ip.unwrap_or(0)
    }

    pub fn clear_authorized_public_ip(&mut self) {
        self.authorized_public_ip = ::std::option::Option::None;
    }

    pub fn has_authorized_public_ip(&self) -> bool {
        self.authorized_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_public_ip(&mut self, v: u32) {
        self.authorized_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 4;

    pub fn gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_net_id = 5;

    pub fn gameserver_net_id(&self) -> u64 {
        self.gameserver_net_id.unwrap_or(0)
    }

    pub fn clear_gameserver_net_id(&mut self) {
        self.gameserver_net_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_net_id(&self) -> bool {
        self.gameserver_net_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_net_id(&mut self, v: u64) {
        self.gameserver_net_id = ::std::option::Option::Some(v);
    }

    // optional bytes signature = 6;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 app_id = 7;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expiry",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.time_expiry },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.time_expiry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authorized_steam_id",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.authorized_steam_id },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.authorized_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authorized_public_ip",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.authorized_public_ip },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.authorized_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_steam_id",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.gameserver_steam_id },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.gameserver_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_net_id",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.gameserver_net_id },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.gameserver_net_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.signature },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.app_id },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.app_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extra_fields",
            |m: &CMsgSteamDatagramGameServerAuthTicket| { &m.extra_fields },
            |m: &mut CMsgSteamDatagramGameServerAuthTicket| { &mut m.extra_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameServerAuthTicket>(
            "CMsgSteamDatagramGameServerAuthTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameServerAuthTicket {
    const NAME: &'static str = "CMsgSteamDatagramGameServerAuthTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.time_expiry = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.authorized_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.authorized_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.gameserver_net_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.extra_fields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time_expiry {
            my_size += 1 + 4;
        }
        if let Some(v) = self.authorized_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.authorized_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameserver_net_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.app_id {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.extra_fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time_expiry {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.authorized_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.authorized_public_ip {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.gameserver_net_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(7, v)?;
        }
        for v in &self.extra_fields {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameServerAuthTicket {
        CMsgSteamDatagramGameServerAuthTicket::new()
    }

    fn clear(&mut self) {
        self.time_expiry = ::std::option::Option::None;
        self.authorized_steam_id = ::std::option::Option::None;
        self.authorized_public_ip = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.gameserver_net_id = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.extra_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameServerAuthTicket {
        static instance: CMsgSteamDatagramGameServerAuthTicket = CMsgSteamDatagramGameServerAuthTicket {
            time_expiry: ::std::option::Option::None,
            authorized_steam_id: ::std::option::Option::None,
            authorized_public_ip: ::std::option::Option::None,
            gameserver_steam_id: ::std::option::Option::None,
            gameserver_net_id: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            extra_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameServerAuthTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameServerAuthTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameServerAuthTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameServerAuthTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramGameServerAuthTicket`
pub mod cmsg_steam_datagram_game_server_auth_ticket {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSteamDatagramGameServerAuthTicket.ExtraField)
    pub struct ExtraField {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.int32_value)
        pub int32_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.fixed32_value)
        pub fixed32_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.fixed64_value)
        pub fixed64_value: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameServerAuthTicket.ExtraField.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExtraField {
        fn default() -> &'a ExtraField {
            <ExtraField as ::protobuf::Message>::default_instance()
        }
    }

    impl ExtraField {
        pub fn new() -> ExtraField {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string string_value = 2;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional sint32 int32_value = 3;

        pub fn int32_value(&self) -> i32 {
            self.int32_value.unwrap_or(0)
        }

        pub fn clear_int32_value(&mut self) {
            self.int32_value = ::std::option::Option::None;
        }

        pub fn has_int32_value(&self) -> bool {
            self.int32_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_int32_value(&mut self, v: i32) {
            self.int32_value = ::std::option::Option::Some(v);
        }

        // optional fixed32 fixed32_value = 4;

        pub fn fixed32_value(&self) -> u32 {
            self.fixed32_value.unwrap_or(0)
        }

        pub fn clear_fixed32_value(&mut self) {
            self.fixed32_value = ::std::option::Option::None;
        }

        pub fn has_fixed32_value(&self) -> bool {
            self.fixed32_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fixed32_value(&mut self, v: u32) {
            self.fixed32_value = ::std::option::Option::Some(v);
        }

        // optional fixed64 fixed64_value = 5;

        pub fn fixed64_value(&self) -> u64 {
            self.fixed64_value.unwrap_or(0)
        }

        pub fn clear_fixed64_value(&mut self) {
            self.fixed64_value = ::std::option::Option::None;
        }

        pub fn has_fixed64_value(&self) -> bool {
            self.fixed64_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fixed64_value(&mut self, v: u64) {
            self.fixed64_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ExtraField| { &m.name },
                |m: &mut ExtraField| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "string_value",
                |m: &ExtraField| { &m.string_value },
                |m: &mut ExtraField| { &mut m.string_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "int32_value",
                |m: &ExtraField| { &m.int32_value },
                |m: &mut ExtraField| { &mut m.int32_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fixed32_value",
                |m: &ExtraField| { &m.fixed32_value },
                |m: &mut ExtraField| { &mut m.fixed32_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fixed64_value",
                |m: &ExtraField| { &m.fixed64_value },
                |m: &mut ExtraField| { &mut m.fixed64_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExtraField>(
                "CMsgSteamDatagramGameServerAuthTicket.ExtraField",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ExtraField {
        const NAME: &'static str = "ExtraField";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.int32_value = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    37 => {
                        self.fixed32_value = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    41 => {
                        self.fixed64_value = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.int32_value {
                my_size += ::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.fixed32_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.fixed64_value {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.int32_value {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.fixed32_value {
                os.write_fixed32(4, v)?;
            }
            if let Some(v) = self.fixed64_value {
                os.write_fixed64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExtraField {
            ExtraField::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.int32_value = ::std::option::Option::None;
            self.fixed32_value = ::std::option::Option::None;
            self.fixed64_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExtraField {
            static instance: ExtraField = ExtraField {
                name: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                int32_value: ::std::option::Option::None,
                fixed32_value: ::std::option::Option::None,
                fixed64_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ExtraField {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameServerAuthTicket.ExtraField").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExtraField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ExtraField {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionRequest)
pub struct CMsgSteamDatagramGameserverSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.ticket)
    pub ticket: ::protobuf::MessageField<CMsgSteamDatagramGameServerAuthTicket>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge_time)
    pub challenge_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionRequest.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionRequest {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionRequest {
        <CMsgSteamDatagramGameserverSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionRequest {
    pub fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 challenge_time = 3;

    pub fn challenge_time(&self) -> u32 {
        self.challenge_time.unwrap_or(0)
    }

    pub fn clear_challenge_time(&mut self) {
        self.challenge_time = ::std::option::Option::None;
    }

    pub fn has_challenge_time(&self) -> bool {
        self.challenge_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_time(&mut self, v: u32) {
        self.challenge_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 5;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramGameServerAuthTicket>(
            "ticket",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.ticket },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge_time",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge_time },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.challenge },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramGameserverSessionRequest| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramGameserverSessionRequest| { &mut m.client_cookie },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverSessionRequest>(
            "CMsgSteamDatagramGameserverSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionRequest {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ticket)?;
                },
                29 => {
                    self.challenge_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.challenge_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.challenge_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionRequest {
        CMsgSteamDatagramGameserverSessionRequest::new()
    }

    fn clear(&mut self) {
        self.ticket.clear();
        self.challenge_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionRequest {
        static instance: CMsgSteamDatagramGameserverSessionRequest = CMsgSteamDatagramGameserverSessionRequest {
            ticket: ::protobuf::MessageField::none(),
            challenge_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramGameserverSessionEstablished)
pub struct CMsgSteamDatagramGameserverSessionEstablished {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.gameserver_steam_id)
    pub gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramGameserverSessionEstablished.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramGameserverSessionEstablished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramGameserverSessionEstablished {
    fn default() -> &'a CMsgSteamDatagramGameserverSessionEstablished {
        <CMsgSteamDatagramGameserverSessionEstablished as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramGameserverSessionEstablished {
    pub fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        ::std::default::Default::default()
    }

    // optional fixed32 client_cookie = 1;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 3;

    pub fn gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 4;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_steam_id",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.gameserver_steam_id },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.gameserver_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramGameserverSessionEstablished| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramGameserverSessionEstablished| { &mut m.seconds_until_shutdown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramGameserverSessionEstablished>(
            "CMsgSteamDatagramGameserverSessionEstablished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramGameserverSessionEstablished {
    const NAME: &'static str = "CMsgSteamDatagramGameserverSessionEstablished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_cookie {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramGameserverSessionEstablished {
        CMsgSteamDatagramGameserverSessionEstablished::new()
    }

    fn clear(&mut self) {
        self.client_cookie = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramGameserverSessionEstablished {
        static instance: CMsgSteamDatagramGameserverSessionEstablished = CMsgSteamDatagramGameserverSessionEstablished {
            client_cookie: ::std::option::Option::None,
            gameserver_steam_id: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramGameserverSessionEstablished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramGameserverSessionEstablished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramGameserverSessionEstablished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramGameserverSessionEstablished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramNoSession)
pub struct CMsgSteamDatagramNoSession {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSession.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSession.your_public_ip)
    pub your_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSession.server_time)
    pub server_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSession.challenge)
    pub challenge: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramNoSession.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramNoSession.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramNoSession {
    fn default() -> &'a CMsgSteamDatagramNoSession {
        <CMsgSteamDatagramNoSession as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramNoSession {
    pub fn new() -> CMsgSteamDatagramNoSession {
        ::std::default::Default::default()
    }

    // optional fixed32 client_cookie = 7;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional fixed32 your_public_ip = 2;

    pub fn your_public_ip(&self) -> u32 {
        self.your_public_ip.unwrap_or(0)
    }

    pub fn clear_your_public_ip(&mut self) {
        self.your_public_ip = ::std::option::Option::None;
    }

    pub fn has_your_public_ip(&self) -> bool {
        self.your_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_public_ip(&mut self, v: u32) {
        self.your_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_time = 3;

    pub fn server_time(&self) -> u32 {
        self.server_time.unwrap_or(0)
    }

    pub fn clear_server_time(&mut self) {
        self.server_time = ::std::option::Option::None;
    }

    pub fn has_server_time(&self) -> bool {
        self.server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_time(&mut self, v: u32) {
        self.server_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 challenge = 4;

    pub fn challenge(&self) -> u64 {
        self.challenge.unwrap_or(0)
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: u64) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 5;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramNoSession| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramNoSession| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "your_public_ip",
            |m: &CMsgSteamDatagramNoSession| { &m.your_public_ip },
            |m: &mut CMsgSteamDatagramNoSession| { &mut m.your_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_time",
            |m: &CMsgSteamDatagramNoSession| { &m.server_time },
            |m: &mut CMsgSteamDatagramNoSession| { &mut m.server_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgSteamDatagramNoSession| { &m.challenge },
            |m: &mut CMsgSteamDatagramNoSession| { &mut m.challenge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramNoSession| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramNoSession| { &mut m.seconds_until_shutdown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramNoSession>(
            "CMsgSteamDatagramNoSession",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramNoSession {
    const NAME: &'static str = "CMsgSteamDatagramNoSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                61 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.your_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.server_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.challenge = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.your_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.challenge {
            my_size += 1 + 8;
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_cookie {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.your_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.challenge {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramNoSession {
        CMsgSteamDatagramNoSession::new()
    }

    fn clear(&mut self) {
        self.client_cookie = ::std::option::Option::None;
        self.your_public_ip = ::std::option::Option::None;
        self.server_time = ::std::option::Option::None;
        self.challenge = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramNoSession {
        static instance: CMsgSteamDatagramNoSession = CMsgSteamDatagramNoSession {
            client_cookie: ::std::option::Option::None,
            your_public_ip: ::std::option::Option::None,
            server_time: ::std::option::Option::None,
            challenge: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramNoSession {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramNoSession").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramNoSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramNoSession {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramDiagnostic)
pub struct CMsgSteamDatagramDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.severity)
    pub severity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDiagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDiagnostic {
    fn default() -> &'a CMsgSteamDatagramDiagnostic {
        <CMsgSteamDatagramDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDiagnostic {
    pub fn new() -> CMsgSteamDatagramDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 severity = 1;

    pub fn severity(&self) -> u32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: u32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity",
            |m: &CMsgSteamDatagramDiagnostic| { &m.severity },
            |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgSteamDatagramDiagnostic| { &m.text },
            |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramDiagnostic>(
            "CMsgSteamDatagramDiagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDiagnostic {
    const NAME: &'static str = "CMsgSteamDatagramDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.severity = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.severity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDiagnostic {
        CMsgSteamDatagramDiagnostic::new()
    }

    fn clear(&mut self) {
        self.severity = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDiagnostic {
        static instance: CMsgSteamDatagramDiagnostic = CMsgSteamDatagramDiagnostic {
            severity: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramDiagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDiagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDiagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState)
pub struct CMsgSteamDatagramDataCenterState {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.data_centers)
    pub data_centers: ::std::vec::Vec<cmsg_steam_datagram_data_center_state::DataCenter>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDataCenterState {
    fn default() -> &'a CMsgSteamDatagramDataCenterState {
        <CMsgSteamDatagramDataCenterState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDataCenterState {
    pub fn new() -> CMsgSteamDatagramDataCenterState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_centers",
            |m: &CMsgSteamDatagramDataCenterState| { &m.data_centers },
            |m: &mut CMsgSteamDatagramDataCenterState| { &mut m.data_centers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramDataCenterState>(
            "CMsgSteamDatagramDataCenterState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDataCenterState {
    const NAME: &'static str = "CMsgSteamDatagramDataCenterState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_centers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_centers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data_centers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDataCenterState {
        CMsgSteamDatagramDataCenterState::new()
    }

    fn clear(&mut self) {
        self.data_centers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDataCenterState {
        static instance: CMsgSteamDatagramDataCenterState = CMsgSteamDatagramDataCenterState {
            data_centers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramDataCenterState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramDataCenterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDataCenterState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramDataCenterState`
pub mod cmsg_steam_datagram_data_center_state {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.Server)
    pub struct Server {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.address)
        pub address: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.Server.ping_ms)
        pub ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.Server.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Server {
        fn default() -> &'a Server {
            <Server as ::protobuf::Message>::default_instance()
        }
    }

    impl Server {
        pub fn new() -> Server {
            ::std::default::Default::default()
        }

        // optional string address = 1;

        pub fn address(&self) -> &str {
            match self.address.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_address(&mut self) {
            self.address = ::std::option::Option::None;
        }

        pub fn has_address(&self) -> bool {
            self.address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_address(&mut self, v: ::std::string::String) {
            self.address = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_address(&mut self) -> &mut ::std::string::String {
            if self.address.is_none() {
                self.address = ::std::option::Option::Some(::std::string::String::new());
            }
            self.address.as_mut().unwrap()
        }

        // Take field
        pub fn take_address(&mut self) -> ::std::string::String {
            self.address.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ping_ms = 2;

        pub fn ping_ms(&self) -> u32 {
            self.ping_ms.unwrap_or(0)
        }

        pub fn clear_ping_ms(&mut self) {
            self.ping_ms = ::std::option::Option::None;
        }

        pub fn has_ping_ms(&self) -> bool {
            self.ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_ms(&mut self, v: u32) {
            self.ping_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "address",
                |m: &Server| { &m.address },
                |m: &mut Server| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_ms",
                |m: &Server| { &m.ping_ms },
                |m: &mut Server| { &mut m.ping_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Server>(
                "CMsgSteamDatagramDataCenterState.Server",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Server {
        const NAME: &'static str = "Server";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.address = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.address.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.address.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ping_ms {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Server {
            Server::new()
        }

        fn clear(&mut self) {
            self.address = ::std::option::Option::None;
            self.ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Server {
            static instance: Server = Server {
                address: ::std::option::Option::None,
                ping_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Server {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState.Server").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Server {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Server {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSteamDatagramDataCenterState.DataCenter)
    pub struct DataCenter {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.code)
        pub code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramDataCenterState.DataCenter.server_sample)
        pub server_sample: ::std::vec::Vec<Server>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramDataCenterState.DataCenter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DataCenter {
        fn default() -> &'a DataCenter {
            <DataCenter as ::protobuf::Message>::default_instance()
        }
    }

    impl DataCenter {
        pub fn new() -> DataCenter {
            ::std::default::Default::default()
        }

        // optional string code = 1;

        pub fn code(&self) -> &str {
            match self.code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_code(&mut self) {
            self.code = ::std::option::Option::None;
        }

        pub fn has_code(&self) -> bool {
            self.code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_code(&mut self, v: ::std::string::String) {
            self.code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_code(&mut self) -> &mut ::std::string::String {
            if self.code.is_none() {
                self.code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.code.as_mut().unwrap()
        }

        // Take field
        pub fn take_code(&mut self) -> ::std::string::String {
            self.code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "code",
                |m: &DataCenter| { &m.code },
                |m: &mut DataCenter| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "server_sample",
                |m: &DataCenter| { &m.server_sample },
                |m: &mut DataCenter| { &mut m.server_sample },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataCenter>(
                "CMsgSteamDatagramDataCenterState.DataCenter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DataCenter {
        const NAME: &'static str = "DataCenter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.code = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.server_sample.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.code.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.server_sample {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.code.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.server_sample {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DataCenter {
            DataCenter::new()
        }

        fn clear(&mut self) {
            self.code = ::std::option::Option::None;
            self.server_sample.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DataCenter {
            static instance: DataCenter = DataCenter {
                code: ::std::option::Option::None,
                server_sample: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DataCenter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDataCenterState.DataCenter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DataCenter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DataCenter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramLinkInstantaneousStats)
pub struct CMsgSteamDatagramLinkInstantaneousStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_packets_per_sec_x10)
    pub out_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_bytes_per_sec)
    pub out_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_packets_per_sec_x10)
    pub in_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_bytes_per_sec)
    pub in_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.ping_ms)
    pub ping_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_dropped_pct)
    pub packets_dropped_pct: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_weird_sequence_pct)
    pub packets_weird_sequence_pct: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkInstantaneousStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkInstantaneousStats {
    fn default() -> &'a CMsgSteamDatagramLinkInstantaneousStats {
        <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkInstantaneousStats {
    pub fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        ::std::default::Default::default()
    }

    // optional uint32 out_packets_per_sec_x10 = 1;

    pub fn out_packets_per_sec_x10(&self) -> u32 {
        self.out_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_out_packets_per_sec_x10(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_out_packets_per_sec_x10(&self) -> bool {
        self.out_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_packets_per_sec_x10(&mut self, v: u32) {
        self.out_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 out_bytes_per_sec = 2;

    pub fn out_bytes_per_sec(&self) -> u32 {
        self.out_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_out_bytes_per_sec(&mut self) {
        self.out_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_out_bytes_per_sec(&self) -> bool {
        self.out_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_bytes_per_sec(&mut self, v: u32) {
        self.out_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 in_packets_per_sec_x10 = 3;

    pub fn in_packets_per_sec_x10(&self) -> u32 {
        self.in_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_in_packets_per_sec_x10(&mut self) {
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_in_packets_per_sec_x10(&self) -> bool {
        self.in_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_packets_per_sec_x10(&mut self, v: u32) {
        self.in_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 in_bytes_per_sec = 4;

    pub fn in_bytes_per_sec(&self) -> u32 {
        self.in_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_in_bytes_per_sec(&mut self) {
        self.in_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_in_bytes_per_sec(&self) -> bool {
        self.in_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_bytes_per_sec(&mut self, v: u32) {
        self.in_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 5;

    pub fn ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }

    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_dropped_pct = 6;

    pub fn packets_dropped_pct(&self) -> u32 {
        self.packets_dropped_pct.unwrap_or(0)
    }

    pub fn clear_packets_dropped_pct(&mut self) {
        self.packets_dropped_pct = ::std::option::Option::None;
    }

    pub fn has_packets_dropped_pct(&self) -> bool {
        self.packets_dropped_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_dropped_pct(&mut self, v: u32) {
        self.packets_dropped_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_weird_sequence_pct = 7;

    pub fn packets_weird_sequence_pct(&self) -> u32 {
        self.packets_weird_sequence_pct.unwrap_or(0)
    }

    pub fn clear_packets_weird_sequence_pct(&mut self) {
        self.packets_weird_sequence_pct = ::std::option::Option::None;
    }

    pub fn has_packets_weird_sequence_pct(&self) -> bool {
        self.packets_weird_sequence_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_weird_sequence_pct(&mut self, v: u32) {
        self.packets_weird_sequence_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_packets_per_sec_x10",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_packets_per_sec_x10 },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_packets_per_sec_x10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_bytes_per_sec",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_bytes_per_sec },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_bytes_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_packets_per_sec_x10",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_packets_per_sec_x10 },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_packets_per_sec_x10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_bytes_per_sec",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_bytes_per_sec },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_bytes_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ms",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.ping_ms },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_dropped_pct",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_dropped_pct },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_dropped_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_weird_sequence_pct",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_weird_sequence_pct },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_weird_sequence_pct },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramLinkInstantaneousStats>(
            "CMsgSteamDatagramLinkInstantaneousStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkInstantaneousStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkInstantaneousStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.out_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.out_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.packets_dropped_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.packets_weird_sequence_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.out_packets_per_sec_x10 {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.out_bytes_per_sec {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_bytes_per_sec {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.packets_dropped_pct {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.out_packets_per_sec_x10 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.out_bytes_per_sec {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_bytes_per_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.packets_dropped_pct {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        CMsgSteamDatagramLinkInstantaneousStats::new()
    }

    fn clear(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
        self.out_bytes_per_sec = ::std::option::Option::None;
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
        self.in_bytes_per_sec = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packets_dropped_pct = ::std::option::Option::None;
        self.packets_weird_sequence_pct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkInstantaneousStats {
        static instance: CMsgSteamDatagramLinkInstantaneousStats = CMsgSteamDatagramLinkInstantaneousStats {
            out_packets_per_sec_x10: ::std::option::Option::None,
            out_bytes_per_sec: ::std::option::Option::None,
            in_packets_per_sec_x10: ::std::option::Option::None,
            in_bytes_per_sec: ::std::option::Option::None,
            ping_ms: ::std::option::Option::None,
            packets_dropped_pct: ::std::option::Option::None,
            packets_weird_sequence_pct: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramLinkInstantaneousStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramLinkInstantaneousStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramLinkInstantaneousStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkInstantaneousStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramLinkLifetimeStats)
pub struct CMsgSteamDatagramLinkLifetimeStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_sent)
    pub packets_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_sent)
    pub kb_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv)
    pub packets_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_recv)
    pub kb_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_sequenced)
    pub packets_recv_sequenced: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_dropped)
    pub packets_recv_dropped: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_out_of_order)
    pub packets_recv_out_of_order: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_duplicate)
    pub packets_recv_duplicate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_lurch)
    pub packets_recv_lurch: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkLifetimeStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkLifetimeStats {
    fn default() -> &'a CMsgSteamDatagramLinkLifetimeStats {
        <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkLifetimeStats {
    pub fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        ::std::default::Default::default()
    }

    // optional uint64 packets_sent = 3;

    pub fn packets_sent(&self) -> u64 {
        self.packets_sent.unwrap_or(0)
    }

    pub fn clear_packets_sent(&mut self) {
        self.packets_sent = ::std::option::Option::None;
    }

    pub fn has_packets_sent(&self) -> bool {
        self.packets_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_sent(&mut self, v: u64) {
        self.packets_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_sent = 4;

    pub fn kb_sent(&self) -> u64 {
        self.kb_sent.unwrap_or(0)
    }

    pub fn clear_kb_sent(&mut self) {
        self.kb_sent = ::std::option::Option::None;
    }

    pub fn has_kb_sent(&self) -> bool {
        self.kb_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_sent(&mut self, v: u64) {
        self.kb_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv = 5;

    pub fn packets_recv(&self) -> u64 {
        self.packets_recv.unwrap_or(0)
    }

    pub fn clear_packets_recv(&mut self) {
        self.packets_recv = ::std::option::Option::None;
    }

    pub fn has_packets_recv(&self) -> bool {
        self.packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv(&mut self, v: u64) {
        self.packets_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_recv = 6;

    pub fn kb_recv(&self) -> u64 {
        self.kb_recv.unwrap_or(0)
    }

    pub fn clear_kb_recv(&mut self) {
        self.kb_recv = ::std::option::Option::None;
    }

    pub fn has_kb_recv(&self) -> bool {
        self.kb_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_recv(&mut self, v: u64) {
        self.kb_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_sequenced = 7;

    pub fn packets_recv_sequenced(&self) -> u64 {
        self.packets_recv_sequenced.unwrap_or(0)
    }

    pub fn clear_packets_recv_sequenced(&mut self) {
        self.packets_recv_sequenced = ::std::option::Option::None;
    }

    pub fn has_packets_recv_sequenced(&self) -> bool {
        self.packets_recv_sequenced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_sequenced(&mut self, v: u64) {
        self.packets_recv_sequenced = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_dropped = 8;

    pub fn packets_recv_dropped(&self) -> u64 {
        self.packets_recv_dropped.unwrap_or(0)
    }

    pub fn clear_packets_recv_dropped(&mut self) {
        self.packets_recv_dropped = ::std::option::Option::None;
    }

    pub fn has_packets_recv_dropped(&self) -> bool {
        self.packets_recv_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_dropped(&mut self, v: u64) {
        self.packets_recv_dropped = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order = 9;

    pub fn packets_recv_out_of_order(&self) -> u64 {
        self.packets_recv_out_of_order.unwrap_or(0)
    }

    pub fn clear_packets_recv_out_of_order(&mut self) {
        self.packets_recv_out_of_order = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order(&self) -> bool {
        self.packets_recv_out_of_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order(&mut self, v: u64) {
        self.packets_recv_out_of_order = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_duplicate = 10;

    pub fn packets_recv_duplicate(&self) -> u64 {
        self.packets_recv_duplicate.unwrap_or(0)
    }

    pub fn clear_packets_recv_duplicate(&mut self) {
        self.packets_recv_duplicate = ::std::option::Option::None;
    }

    pub fn has_packets_recv_duplicate(&self) -> bool {
        self.packets_recv_duplicate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_duplicate(&mut self, v: u64) {
        self.packets_recv_duplicate = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_lurch = 11;

    pub fn packets_recv_lurch(&self) -> u64 {
        self.packets_recv_lurch.unwrap_or(0)
    }

    pub fn clear_packets_recv_lurch(&mut self) {
        self.packets_recv_lurch = ::std::option::Option::None;
    }

    pub fn has_packets_recv_lurch(&self) -> bool {
        self.packets_recv_lurch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_lurch(&mut self, v: u64) {
        self.packets_recv_lurch = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_sent",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_sent },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kb_sent",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_sent },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kb_recv",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_recv },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_sequenced",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_sequenced },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_sequenced },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_dropped",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_dropped },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_out_of_order",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_out_of_order },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_out_of_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_duplicate",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_duplicate },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_duplicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_lurch",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_lurch },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_lurch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramLinkLifetimeStats>(
            "CMsgSteamDatagramLinkLifetimeStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkLifetimeStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkLifetimeStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.packets_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.kb_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.packets_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.kb_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.packets_recv_sequenced = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.packets_recv_dropped = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.packets_recv_out_of_order = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.packets_recv_duplicate = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.packets_recv_lurch = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packets_sent {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.kb_sent {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.packets_recv {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.kb_recv {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.packets_recv_sequenced {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.packets_recv_dropped {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.packets_recv_out_of_order {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.packets_recv_duplicate {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.packets_recv_lurch {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packets_sent {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.kb_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.packets_recv {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.kb_recv {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.packets_recv_sequenced {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.packets_recv_dropped {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.packets_recv_duplicate {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.packets_recv_lurch {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        CMsgSteamDatagramLinkLifetimeStats::new()
    }

    fn clear(&mut self) {
        self.packets_sent = ::std::option::Option::None;
        self.kb_sent = ::std::option::Option::None;
        self.packets_recv = ::std::option::Option::None;
        self.kb_recv = ::std::option::Option::None;
        self.packets_recv_sequenced = ::std::option::Option::None;
        self.packets_recv_dropped = ::std::option::Option::None;
        self.packets_recv_out_of_order = ::std::option::Option::None;
        self.packets_recv_duplicate = ::std::option::Option::None;
        self.packets_recv_lurch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkLifetimeStats {
        static instance: CMsgSteamDatagramLinkLifetimeStats = CMsgSteamDatagramLinkLifetimeStats {
            packets_sent: ::std::option::Option::None,
            kb_sent: ::std::option::Option::None,
            packets_recv: ::std::option::Option::None,
            kb_recv: ::std::option::Option::None,
            packets_recv_sequenced: ::std::option::Option::None,
            packets_recv_dropped: ::std::option::Option::None,
            packets_recv_out_of_order: ::std::option::Option::None,
            packets_recv_duplicate: ::std::option::Option::None,
            packets_recv_lurch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramLinkLifetimeStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramLinkLifetimeStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramLinkLifetimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkLifetimeStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionQuality)
pub struct CMsgSteamDatagramConnectionQuality {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.instantaneous)
    pub instantaneous: ::protobuf::MessageField<CMsgSteamDatagramLinkInstantaneousStats>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.lifetime)
    pub lifetime: ::protobuf::MessageField<CMsgSteamDatagramLinkLifetimeStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionQuality.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionQuality {
    fn default() -> &'a CMsgSteamDatagramConnectionQuality {
        <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionQuality {
    pub fn new() -> CMsgSteamDatagramConnectionQuality {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramLinkInstantaneousStats>(
            "instantaneous",
            |m: &CMsgSteamDatagramConnectionQuality| { &m.instantaneous },
            |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.instantaneous },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramLinkLifetimeStats>(
            "lifetime",
            |m: &CMsgSteamDatagramConnectionQuality| { &m.lifetime },
            |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.lifetime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionQuality>(
            "CMsgSteamDatagramConnectionQuality",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionQuality {
    const NAME: &'static str = "CMsgSteamDatagramConnectionQuality";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.instantaneous)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lifetime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.instantaneous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.instantaneous.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.lifetime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionQuality {
        CMsgSteamDatagramConnectionQuality::new()
    }

    fn clear(&mut self) {
        self.instantaneous.clear();
        self.lifetime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionQuality {
        static instance: CMsgSteamDatagramConnectionQuality = CMsgSteamDatagramConnectionQuality {
            instantaneous: ::protobuf::MessageField::none(),
            lifetime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionQuality {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionQuality").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionQuality {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsClientToRouter)
pub struct CMsgSteamDatagramConnectionStatsClientToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.c2r)
    pub c2r: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.c2s)
    pub c2s: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_c2r)
    pub seq_num_c2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsClientToRouter.seq_num_c2s)
    pub seq_num_c2s: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsClientToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsClientToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsClientToRouter {
        <CMsgSteamDatagramConnectionStatsClientToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsClientToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 3;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 8;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2r = 9;

    pub fn seq_num_c2r(&self) -> u32 {
        self.seq_num_c2r.unwrap_or(0)
    }

    pub fn clear_seq_num_c2r(&mut self) {
        self.seq_num_c2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2r(&self) -> bool {
        self.seq_num_c2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2r(&mut self, v: u32) {
        self.seq_num_c2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 10;

    pub fn seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }

    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "c2r",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.c2r },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.c2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "c2s",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.c2s },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.c2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.client_timestamp },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_c2r",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2r },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_c2s",
            |m: &CMsgSteamDatagramConnectionStatsClientToRouter| { &m.seq_num_c2s },
            |m: &mut CMsgSteamDatagramConnectionStatsClientToRouter| { &mut m.seq_num_c2s },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsClientToRouter>(
            "CMsgSteamDatagramConnectionStatsClientToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsClientToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsClientToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.c2r)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.c2s)?;
                },
                29 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                69 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.seq_num_c2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.seq_num_c2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.c2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_c2r {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.c2r.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.c2s.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.seq_num_c2r {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsClientToRouter {
        CMsgSteamDatagramConnectionStatsClientToRouter::new()
    }

    fn clear(&mut self) {
        self.c2r.clear();
        self.c2s.clear();
        self.client_timestamp = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.seq_num_c2r = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsClientToRouter {
        static instance: CMsgSteamDatagramConnectionStatsClientToRouter = CMsgSteamDatagramConnectionStatsClientToRouter {
            c2r: ::protobuf::MessageField::none(),
            c2s: ::protobuf::MessageField::none(),
            client_timestamp: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            seq_num_c2r: ::std::option::Option::None,
            seq_num_c2s: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsClientToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsClientToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsClientToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToClient)
pub struct CMsgSteamDatagramConnectionStatsRouterToClient {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.r2c)
    pub r2c: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.s2c)
    pub s2c: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.client_timestamp_from_router)
    pub client_timestamp_from_router: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.client_timestamp_from_server)
    pub client_timestamp_from_server: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.router_gameserver_latency)
    pub router_gameserver_latency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seconds_until_shutdown)
    pub seconds_until_shutdown: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_r2c)
    pub seq_num_r2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToClient.seq_num_s2c)
    pub seq_num_s2c: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToClient {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToClient {
        <CMsgSteamDatagramConnectionStatsRouterToClient as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToClient {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp_from_router = 3;

    pub fn client_timestamp_from_router(&self) -> u32 {
        self.client_timestamp_from_router.unwrap_or(0)
    }

    pub fn clear_client_timestamp_from_router(&mut self) {
        self.client_timestamp_from_router = ::std::option::Option::None;
    }

    pub fn has_client_timestamp_from_router(&self) -> bool {
        self.client_timestamp_from_router.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp_from_router(&mut self, v: u32) {
        self.client_timestamp_from_router = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_timestamp_from_server = 4;

    pub fn client_timestamp_from_server(&self) -> u32 {
        self.client_timestamp_from_server.unwrap_or(0)
    }

    pub fn clear_client_timestamp_from_server(&mut self) {
        self.client_timestamp_from_server = ::std::option::Option::None;
    }

    pub fn has_client_timestamp_from_server(&self) -> bool {
        self.client_timestamp_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp_from_server(&mut self, v: u32) {
        self.client_timestamp_from_server = ::std::option::Option::Some(v);
    }

    // optional uint32 router_gameserver_latency = 5;

    pub fn router_gameserver_latency(&self) -> u32 {
        self.router_gameserver_latency.unwrap_or(0)
    }

    pub fn clear_router_gameserver_latency(&mut self) {
        self.router_gameserver_latency = ::std::option::Option::None;
    }

    pub fn has_router_gameserver_latency(&self) -> bool {
        self.router_gameserver_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_gameserver_latency(&mut self, v: u32) {
        self.router_gameserver_latency = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_until_shutdown = 6;

    pub fn seconds_until_shutdown(&self) -> u32 {
        self.seconds_until_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_until_shutdown(&mut self) {
        self.seconds_until_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_until_shutdown(&self) -> bool {
        self.seconds_until_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_until_shutdown(&mut self, v: u32) {
        self.seconds_until_shutdown = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_cookie = 7;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2c = 8;

    pub fn seq_num_r2c(&self) -> u32 {
        self.seq_num_r2c.unwrap_or(0)
    }

    pub fn clear_seq_num_r2c(&mut self) {
        self.seq_num_r2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2c(&self) -> bool {
        self.seq_num_r2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2c(&mut self, v: u32) {
        self.seq_num_r2c = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 9;

    pub fn seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }

    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "r2c",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.r2c },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.r2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "s2c",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.s2c },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.s2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp_from_router",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_timestamp_from_router },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_timestamp_from_router },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp_from_server",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_timestamp_from_server },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_timestamp_from_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_gameserver_latency",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.router_gameserver_latency },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.router_gameserver_latency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_until_shutdown",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seconds_until_shutdown },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seconds_until_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2c",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_r2c },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_r2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_s2c",
            |m: &CMsgSteamDatagramConnectionStatsRouterToClient| { &m.seq_num_s2c },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToClient| { &mut m.seq_num_s2c },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsRouterToClient>(
            "CMsgSteamDatagramConnectionStatsRouterToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToClient {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.r2c)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.s2c)?;
                },
                29 => {
                    self.client_timestamp_from_router = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.client_timestamp_from_server = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.router_gameserver_latency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seconds_until_shutdown = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                64 => {
                    self.seq_num_r2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.seq_num_s2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_timestamp_from_router {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_timestamp_from_server {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_gameserver_latency {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seconds_until_shutdown {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2c {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.r2c.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.s2c.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.client_timestamp_from_router {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.client_timestamp_from_server {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.router_gameserver_latency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seconds_until_shutdown {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_cookie {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.seq_num_r2c {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToClient {
        CMsgSteamDatagramConnectionStatsRouterToClient::new()
    }

    fn clear(&mut self) {
        self.r2c.clear();
        self.s2c.clear();
        self.client_timestamp_from_router = ::std::option::Option::None;
        self.client_timestamp_from_server = ::std::option::Option::None;
        self.router_gameserver_latency = ::std::option::Option::None;
        self.seconds_until_shutdown = ::std::option::Option::None;
        self.client_cookie = ::std::option::Option::None;
        self.seq_num_r2c = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToClient {
        static instance: CMsgSteamDatagramConnectionStatsRouterToClient = CMsgSteamDatagramConnectionStatsRouterToClient {
            r2c: ::protobuf::MessageField::none(),
            s2c: ::protobuf::MessageField::none(),
            client_timestamp_from_router: ::std::option::Option::None,
            client_timestamp_from_server: ::std::option::Option::None,
            router_gameserver_latency: ::std::option::Option::None,
            seconds_until_shutdown: ::std::option::Option::None,
            client_cookie: ::std::option::Option::None,
            seq_num_r2c: ::std::option::Option::None,
            seq_num_s2c: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsRouterToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsRouterToServer)
pub struct CMsgSteamDatagramConnectionStatsRouterToServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.r2s)
    pub r2s: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.c2s)
    pub c2s: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_timestamp)
    pub client_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.router_timestamp)
    pub router_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_r2s)
    pub seq_num_r2s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.seq_num_c2s)
    pub seq_num_c2s: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsRouterToServer.client_session_id)
    pub client_session_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsRouterToServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsRouterToServer {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsRouterToServer {
        <CMsgSteamDatagramConnectionStatsRouterToServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsRouterToServer {
    pub fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        ::std::default::Default::default()
    }

    // optional fixed32 client_timestamp = 3;

    pub fn client_timestamp(&self) -> u32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: u32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 router_timestamp = 4;

    pub fn router_timestamp(&self) -> u32 {
        self.router_timestamp.unwrap_or(0)
    }

    pub fn clear_router_timestamp(&mut self) {
        self.router_timestamp = ::std::option::Option::None;
    }

    pub fn has_router_timestamp(&self) -> bool {
        self.router_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_router_timestamp(&mut self, v: u32) {
        self.router_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_r2s = 5;

    pub fn seq_num_r2s(&self) -> u32 {
        self.seq_num_r2s.unwrap_or(0)
    }

    pub fn clear_seq_num_r2s(&mut self) {
        self.seq_num_r2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_r2s(&self) -> bool {
        self.seq_num_r2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_r2s(&mut self, v: u32) {
        self.seq_num_r2s = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_c2s = 6;

    pub fn seq_num_c2s(&self) -> u32 {
        self.seq_num_c2s.unwrap_or(0)
    }

    pub fn clear_seq_num_c2s(&mut self) {
        self.seq_num_c2s = ::std::option::Option::None;
    }

    pub fn has_seq_num_c2s(&self) -> bool {
        self.seq_num_c2s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_c2s(&mut self, v: u32) {
        self.seq_num_c2s = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 7;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_id = 8;

    pub fn client_session_id(&self) -> u32 {
        self.client_session_id.unwrap_or(0)
    }

    pub fn clear_client_session_id(&mut self) {
        self.client_session_id = ::std::option::Option::None;
    }

    pub fn has_client_session_id(&self) -> bool {
        self.client_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_id(&mut self, v: u32) {
        self.client_session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "r2s",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.r2s },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.r2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "c2s",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.c2s },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.c2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_timestamp },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "router_timestamp",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.router_timestamp },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.router_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_r2s",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_r2s },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_r2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_c2s",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.seq_num_c2s },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.seq_num_c2s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_steam_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_steam_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_id",
            |m: &CMsgSteamDatagramConnectionStatsRouterToServer| { &m.client_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsRouterToServer| { &mut m.client_session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsRouterToServer>(
            "CMsgSteamDatagramConnectionStatsRouterToServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsRouterToServer {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsRouterToServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.r2s)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.c2s)?;
                },
                29 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                37 => {
                    self.router_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.seq_num_r2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.seq_num_c2s = ::std::option::Option::Some(is.read_uint32()?);
                },
                57 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                64 => {
                    self.client_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.c2s.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.router_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.seq_num_r2s {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.seq_num_c2s {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_session_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.r2s.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.c2s.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.router_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.seq_num_r2s {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.seq_num_c2s {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.client_session_id {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsRouterToServer {
        CMsgSteamDatagramConnectionStatsRouterToServer::new()
    }

    fn clear(&mut self) {
        self.r2s.clear();
        self.c2s.clear();
        self.client_timestamp = ::std::option::Option::None;
        self.router_timestamp = ::std::option::Option::None;
        self.seq_num_r2s = ::std::option::Option::None;
        self.seq_num_c2s = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.client_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsRouterToServer {
        static instance: CMsgSteamDatagramConnectionStatsRouterToServer = CMsgSteamDatagramConnectionStatsRouterToServer {
            r2s: ::protobuf::MessageField::none(),
            c2s: ::protobuf::MessageField::none(),
            client_timestamp: ::std::option::Option::None,
            router_timestamp: ::std::option::Option::None,
            seq_num_r2s: ::std::option::Option::None,
            seq_num_c2s: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            client_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsRouterToServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsRouterToServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsRouterToServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionStatsServerToRouter)
pub struct CMsgSteamDatagramConnectionStatsServerToRouter {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.s2r)
    pub s2r: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.s2c)
    pub s2c: ::protobuf::MessageField<CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_s2r)
    pub seq_num_s2r: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.seq_num_s2c)
    pub seq_num_s2c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.client_steam_id)
    pub client_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionStatsServerToRouter.client_session_id)
    pub client_session_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionStatsServerToRouter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionStatsServerToRouter {
    fn default() -> &'a CMsgSteamDatagramConnectionStatsServerToRouter {
        <CMsgSteamDatagramConnectionStatsServerToRouter as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionStatsServerToRouter {
    pub fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num_s2r = 3;

    pub fn seq_num_s2r(&self) -> u32 {
        self.seq_num_s2r.unwrap_or(0)
    }

    pub fn clear_seq_num_s2r(&mut self) {
        self.seq_num_s2r = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2r(&self) -> bool {
        self.seq_num_s2r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2r(&mut self, v: u32) {
        self.seq_num_s2r = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num_s2c = 4;

    pub fn seq_num_s2c(&self) -> u32 {
        self.seq_num_s2c.unwrap_or(0)
    }

    pub fn clear_seq_num_s2c(&mut self) {
        self.seq_num_s2c = ::std::option::Option::None;
    }

    pub fn has_seq_num_s2c(&self) -> bool {
        self.seq_num_s2c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num_s2c(&mut self, v: u32) {
        self.seq_num_s2c = ::std::option::Option::Some(v);
    }

    // optional fixed64 client_steam_id = 5;

    pub fn client_steam_id(&self) -> u64 {
        self.client_steam_id.unwrap_or(0)
    }

    pub fn clear_client_steam_id(&mut self) {
        self.client_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_steam_id(&self) -> bool {
        self.client_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_steam_id(&mut self, v: u64) {
        self.client_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_id = 6;

    pub fn client_session_id(&self) -> u32 {
        self.client_session_id.unwrap_or(0)
    }

    pub fn clear_client_session_id(&mut self) {
        self.client_session_id = ::std::option::Option::None;
    }

    pub fn has_client_session_id(&self) -> bool {
        self.client_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_id(&mut self, v: u32) {
        self.client_session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "s2r",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.s2r },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.s2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramConnectionQuality>(
            "s2c",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.s2c },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.s2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_s2r",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2r },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num_s2c",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.seq_num_s2c },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.seq_num_s2c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_steam_id",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_steam_id },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_id",
            |m: &CMsgSteamDatagramConnectionStatsServerToRouter| { &m.client_session_id },
            |m: &mut CMsgSteamDatagramConnectionStatsServerToRouter| { &mut m.client_session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionStatsServerToRouter>(
            "CMsgSteamDatagramConnectionStatsServerToRouter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionStatsServerToRouter {
    const NAME: &'static str = "CMsgSteamDatagramConnectionStatsServerToRouter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.s2r)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.s2c)?;
                },
                24 => {
                    self.seq_num_s2r = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.seq_num_s2c = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.client_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.client_session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.s2r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.s2c.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.seq_num_s2r {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.seq_num_s2c {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.client_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_session_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.s2r.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.s2c.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.seq_num_s2r {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seq_num_s2c {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.client_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.client_session_id {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionStatsServerToRouter {
        CMsgSteamDatagramConnectionStatsServerToRouter::new()
    }

    fn clear(&mut self) {
        self.s2r.clear();
        self.s2c.clear();
        self.seq_num_s2r = ::std::option::Option::None;
        self.seq_num_s2c = ::std::option::Option::None;
        self.client_steam_id = ::std::option::Option::None;
        self.client_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionStatsServerToRouter {
        static instance: CMsgSteamDatagramConnectionStatsServerToRouter = CMsgSteamDatagramConnectionStatsServerToRouter {
            s2r: ::protobuf::MessageField::none(),
            s2c: ::protobuf::MessageField::none(),
            seq_num_s2r: ::std::option::Option::None,
            seq_num_s2c: ::std::option::Option::None,
            client_steam_id: ::std::option::Option::None,
            client_session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionStatsServerToRouter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionStatsServerToRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionStatsServerToRouter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleRequest)
pub struct CMsgSteamDatagramClientPingSampleRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleRequest.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleRequest {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleRequest {
        <CMsgSteamDatagramClientPingSampleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleRequest {
    pub fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        ::std::default::Default::default()
    }

    // optional fixed32 client_cookie = 1;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramClientPingSampleRequest| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramClientPingSampleRequest| { &mut m.client_cookie },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientPingSampleRequest>(
            "CMsgSteamDatagramClientPingSampleRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleRequest {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_cookie {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleRequest {
        CMsgSteamDatagramClientPingSampleRequest::new()
    }

    fn clear(&mut self) {
        self.client_cookie = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleRequest {
        static instance: CMsgSteamDatagramClientPingSampleRequest = CMsgSteamDatagramClientPingSampleRequest {
            client_cookie: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientPingSampleRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientPingSampleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply)
pub struct CMsgSteamDatagramClientPingSampleReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.routing_clusters)
    pub routing_clusters: ::std::vec::Vec<cmsg_steam_datagram_client_ping_sample_reply::RoutingCluster>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientPingSampleReply {
    fn default() -> &'a CMsgSteamDatagramClientPingSampleReply {
        <CMsgSteamDatagramClientPingSampleReply as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientPingSampleReply {
    pub fn new() -> CMsgSteamDatagramClientPingSampleReply {
        ::std::default::Default::default()
    }

    // optional fixed32 client_cookie = 1;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "routing_clusters",
            |m: &CMsgSteamDatagramClientPingSampleReply| { &m.routing_clusters },
            |m: &mut CMsgSteamDatagramClientPingSampleReply| { &mut m.routing_clusters },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientPingSampleReply>(
            "CMsgSteamDatagramClientPingSampleReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientPingSampleReply {
    const NAME: &'static str = "CMsgSteamDatagramClientPingSampleReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.routing_clusters.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        for value in &self.routing_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_cookie {
            os.write_fixed32(1, v)?;
        }
        for v in &self.routing_clusters {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientPingSampleReply {
        CMsgSteamDatagramClientPingSampleReply::new()
    }

    fn clear(&mut self) {
        self.client_cookie = ::std::option::Option::None;
        self.routing_clusters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientPingSampleReply {
        static instance: CMsgSteamDatagramClientPingSampleReply = CMsgSteamDatagramClientPingSampleReply {
            client_cookie: ::std::option::Option::None,
            routing_clusters: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientPingSampleReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientPingSampleReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientPingSampleReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramClientPingSampleReply`
pub mod cmsg_steam_datagram_client_ping_sample_reply {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientPingSampleReply.RoutingCluster)
    pub struct RoutingCluster {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.front_ping_ms)
        pub front_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.e2e_ping_ms)
        pub e2e_ping_ms: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientPingSampleReply.RoutingCluster.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoutingCluster {
        fn default() -> &'a RoutingCluster {
            <RoutingCluster as ::protobuf::Message>::default_instance()
        }
    }

    impl RoutingCluster {
        pub fn new() -> RoutingCluster {
            ::std::default::Default::default()
        }

        // optional fixed32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 front_ping_ms = 2;

        pub fn front_ping_ms(&self) -> u32 {
            self.front_ping_ms.unwrap_or(0)
        }

        pub fn clear_front_ping_ms(&mut self) {
            self.front_ping_ms = ::std::option::Option::None;
        }

        pub fn has_front_ping_ms(&self) -> bool {
            self.front_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_front_ping_ms(&mut self, v: u32) {
            self.front_ping_ms = ::std::option::Option::Some(v);
        }

        // optional uint32 e2e_ping_ms = 3;

        pub fn e2e_ping_ms(&self) -> u32 {
            self.e2e_ping_ms.unwrap_or(0)
        }

        pub fn clear_e2e_ping_ms(&mut self) {
            self.e2e_ping_ms = ::std::option::Option::None;
        }

        pub fn has_e2e_ping_ms(&self) -> bool {
            self.e2e_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_e2e_ping_ms(&mut self, v: u32) {
            self.e2e_ping_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &RoutingCluster| { &m.id },
                |m: &mut RoutingCluster| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "front_ping_ms",
                |m: &RoutingCluster| { &m.front_ping_ms },
                |m: &mut RoutingCluster| { &mut m.front_ping_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "e2e_ping_ms",
                |m: &RoutingCluster| { &m.e2e_ping_ms },
                |m: &mut RoutingCluster| { &mut m.e2e_ping_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoutingCluster>(
                "CMsgSteamDatagramClientPingSampleReply.RoutingCluster",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RoutingCluster {
        const NAME: &'static str = "RoutingCluster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    16 => {
                        self.front_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.e2e_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.front_ping_ms {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.e2e_ping_ms {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.front_ping_ms {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.e2e_ping_ms {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoutingCluster {
            RoutingCluster::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.front_ping_ms = ::std::option::Option::None;
            self.e2e_ping_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoutingCluster {
            static instance: RoutingCluster = RoutingCluster {
                id: ::std::option::Option::None,
                front_ping_ms: ::std::option::Option::None,
                e2e_ping_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RoutingCluster {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientPingSampleReply.RoutingCluster").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RoutingCluster {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RoutingCluster {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary)
pub struct CMsgSteamDatagramClientSwitchedPrimary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.client_cookie)
    pub client_cookie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_ip)
    pub from_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_port)
    pub from_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_router_cluster)
    pub from_router_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_time)
    pub from_active_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_active_packets_recv)
    pub from_active_packets_recv: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_dropped_reason)
    pub from_dropped_reason: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.gap_ms)
    pub gap_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_now)
    pub from_quality_now: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_now)
    pub to_quality_now: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.from_quality_then)
    pub from_quality_then: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.to_quality_then)
    pub to_quality_then: ::protobuf::MessageField<cmsg_steam_datagram_client_switched_primary::RouterQuality>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramClientSwitchedPrimary {
    fn default() -> &'a CMsgSteamDatagramClientSwitchedPrimary {
        <CMsgSteamDatagramClientSwitchedPrimary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramClientSwitchedPrimary {
    pub fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        ::std::default::Default::default()
    }

    // optional fixed32 client_cookie = 1;

    pub fn client_cookie(&self) -> u32 {
        self.client_cookie.unwrap_or(0)
    }

    pub fn clear_client_cookie(&mut self) {
        self.client_cookie = ::std::option::Option::None;
    }

    pub fn has_client_cookie(&self) -> bool {
        self.client_cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_cookie(&mut self, v: u32) {
        self.client_cookie = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_ip = 2;

    pub fn from_ip(&self) -> u32 {
        self.from_ip.unwrap_or(0)
    }

    pub fn clear_from_ip(&mut self) {
        self.from_ip = ::std::option::Option::None;
    }

    pub fn has_from_ip(&self) -> bool {
        self.from_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_ip(&mut self, v: u32) {
        self.from_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 from_port = 3;

    pub fn from_port(&self) -> u32 {
        self.from_port.unwrap_or(0)
    }

    pub fn clear_from_port(&mut self) {
        self.from_port = ::std::option::Option::None;
    }

    pub fn has_from_port(&self) -> bool {
        self.from_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_port(&mut self, v: u32) {
        self.from_port = ::std::option::Option::Some(v);
    }

    // optional fixed32 from_router_cluster = 4;

    pub fn from_router_cluster(&self) -> u32 {
        self.from_router_cluster.unwrap_or(0)
    }

    pub fn clear_from_router_cluster(&mut self) {
        self.from_router_cluster = ::std::option::Option::None;
    }

    pub fn has_from_router_cluster(&self) -> bool {
        self.from_router_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_router_cluster(&mut self, v: u32) {
        self.from_router_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_time = 5;

    pub fn from_active_time(&self) -> u32 {
        self.from_active_time.unwrap_or(0)
    }

    pub fn clear_from_active_time(&mut self) {
        self.from_active_time = ::std::option::Option::None;
    }

    pub fn has_from_active_time(&self) -> bool {
        self.from_active_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_time(&mut self, v: u32) {
        self.from_active_time = ::std::option::Option::Some(v);
    }

    // optional uint32 from_active_packets_recv = 6;

    pub fn from_active_packets_recv(&self) -> u32 {
        self.from_active_packets_recv.unwrap_or(0)
    }

    pub fn clear_from_active_packets_recv(&mut self) {
        self.from_active_packets_recv = ::std::option::Option::None;
    }

    pub fn has_from_active_packets_recv(&self) -> bool {
        self.from_active_packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_active_packets_recv(&mut self, v: u32) {
        self.from_active_packets_recv = ::std::option::Option::Some(v);
    }

    // optional string from_dropped_reason = 7;

    pub fn from_dropped_reason(&self) -> &str {
        match self.from_dropped_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_dropped_reason(&mut self) {
        self.from_dropped_reason = ::std::option::Option::None;
    }

    pub fn has_from_dropped_reason(&self) -> bool {
        self.from_dropped_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_dropped_reason(&mut self, v: ::std::string::String) {
        self.from_dropped_reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_dropped_reason(&mut self) -> &mut ::std::string::String {
        if self.from_dropped_reason.is_none() {
            self.from_dropped_reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_dropped_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_dropped_reason(&mut self) -> ::std::string::String {
        self.from_dropped_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gap_ms = 8;

    pub fn gap_ms(&self) -> u32 {
        self.gap_ms.unwrap_or(0)
    }

    pub fn clear_gap_ms(&mut self) {
        self.gap_ms = ::std::option::Option::None;
    }

    pub fn has_gap_ms(&self) -> bool {
        self.gap_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gap_ms(&mut self, v: u32) {
        self.gap_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_cookie",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.client_cookie },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.client_cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_ip",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_ip },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_port",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_port },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_router_cluster",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_router_cluster },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_router_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_active_time",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_time },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_active_packets_recv",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_active_packets_recv },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_active_packets_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_dropped_reason",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_dropped_reason },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_dropped_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gap_ms",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.gap_ms },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.gap_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "from_quality_now",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_now },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_now },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "to_quality_now",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_now },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_now },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "from_quality_then",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.from_quality_then },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.from_quality_then },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_datagram_client_switched_primary::RouterQuality>(
            "to_quality_then",
            |m: &CMsgSteamDatagramClientSwitchedPrimary| { &m.to_quality_then },
            |m: &mut CMsgSteamDatagramClientSwitchedPrimary| { &mut m.to_quality_then },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramClientSwitchedPrimary>(
            "CMsgSteamDatagramClientSwitchedPrimary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramClientSwitchedPrimary {
    const NAME: &'static str = "CMsgSteamDatagramClientSwitchedPrimary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.client_cookie = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.from_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.from_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.from_router_cluster = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.from_active_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.from_active_packets_recv = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.from_dropped_reason = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.gap_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_now)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_now)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.from_quality_then)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.to_quality_then)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_cookie {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.from_router_cluster {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_active_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.from_active_packets_recv {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.gap_ms {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_cookie {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.from_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.from_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.from_router_cluster {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.from_active_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.from_active_packets_recv {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.from_dropped_reason.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.gap_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.from_quality_now.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.to_quality_now.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.from_quality_then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.to_quality_then.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramClientSwitchedPrimary {
        CMsgSteamDatagramClientSwitchedPrimary::new()
    }

    fn clear(&mut self) {
        self.client_cookie = ::std::option::Option::None;
        self.from_ip = ::std::option::Option::None;
        self.from_port = ::std::option::Option::None;
        self.from_router_cluster = ::std::option::Option::None;
        self.from_active_time = ::std::option::Option::None;
        self.from_active_packets_recv = ::std::option::Option::None;
        self.from_dropped_reason = ::std::option::Option::None;
        self.gap_ms = ::std::option::Option::None;
        self.from_quality_now.clear();
        self.to_quality_now.clear();
        self.from_quality_then.clear();
        self.to_quality_then.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramClientSwitchedPrimary {
        static instance: CMsgSteamDatagramClientSwitchedPrimary = CMsgSteamDatagramClientSwitchedPrimary {
            client_cookie: ::std::option::Option::None,
            from_ip: ::std::option::Option::None,
            from_port: ::std::option::Option::None,
            from_router_cluster: ::std::option::Option::None,
            from_active_time: ::std::option::Option::None,
            from_active_packets_recv: ::std::option::Option::None,
            from_dropped_reason: ::std::option::Option::None,
            gap_ms: ::std::option::Option::None,
            from_quality_now: ::protobuf::MessageField::none(),
            to_quality_now: ::protobuf::MessageField::none(),
            from_quality_then: ::protobuf::MessageField::none(),
            to_quality_then: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramClientSwitchedPrimary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientSwitchedPrimary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramClientSwitchedPrimary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramClientSwitchedPrimary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramClientSwitchedPrimary`
pub mod cmsg_steam_datagram_client_switched_primary {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality)
    pub struct RouterQuality {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.front_ping)
        pub front_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.back_ping)
        pub back_ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.seconds_until_down)
        pub seconds_until_down: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamDatagramClientSwitchedPrimary.RouterQuality.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RouterQuality {
        fn default() -> &'a RouterQuality {
            <RouterQuality as ::protobuf::Message>::default_instance()
        }
    }

    impl RouterQuality {
        pub fn new() -> RouterQuality {
            ::std::default::Default::default()
        }

        // optional uint32 score = 1;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 front_ping = 2;

        pub fn front_ping(&self) -> u32 {
            self.front_ping.unwrap_or(0)
        }

        pub fn clear_front_ping(&mut self) {
            self.front_ping = ::std::option::Option::None;
        }

        pub fn has_front_ping(&self) -> bool {
            self.front_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_front_ping(&mut self, v: u32) {
            self.front_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 back_ping = 3;

        pub fn back_ping(&self) -> u32 {
            self.back_ping.unwrap_or(0)
        }

        pub fn clear_back_ping(&mut self) {
            self.back_ping = ::std::option::Option::None;
        }

        pub fn has_back_ping(&self) -> bool {
            self.back_ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_back_ping(&mut self, v: u32) {
            self.back_ping = ::std::option::Option::Some(v);
        }

        // optional uint32 seconds_until_down = 4;

        pub fn seconds_until_down(&self) -> u32 {
            self.seconds_until_down.unwrap_or(0)
        }

        pub fn clear_seconds_until_down(&mut self) {
            self.seconds_until_down = ::std::option::Option::None;
        }

        pub fn has_seconds_until_down(&self) -> bool {
            self.seconds_until_down.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seconds_until_down(&mut self, v: u32) {
            self.seconds_until_down = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "score",
                |m: &RouterQuality| { &m.score },
                |m: &mut RouterQuality| { &mut m.score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "front_ping",
                |m: &RouterQuality| { &m.front_ping },
                |m: &mut RouterQuality| { &mut m.front_ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "back_ping",
                |m: &RouterQuality| { &m.back_ping },
                |m: &mut RouterQuality| { &mut m.back_ping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "seconds_until_down",
                |m: &RouterQuality| { &m.seconds_until_down },
                |m: &mut RouterQuality| { &mut m.seconds_until_down },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RouterQuality>(
                "CMsgSteamDatagramClientSwitchedPrimary.RouterQuality",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RouterQuality {
        const NAME: &'static str = "RouterQuality";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.front_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.back_ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.seconds_until_down = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.score {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.front_ping {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.back_ping {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.seconds_until_down {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.score {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.front_ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.back_ping {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.seconds_until_down {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RouterQuality {
            RouterQuality::new()
        }

        fn clear(&mut self) {
            self.score = ::std::option::Option::None;
            self.front_ping = ::std::option::Option::None;
            self.back_ping = ::std::option::Option::None;
            self.seconds_until_down = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RouterQuality {
            static instance: RouterQuality = RouterQuality {
                score: ::std::option::Option::None,
                front_ping: ::std::option::Option::None,
                back_ping: ::std::option::Option::None,
                seconds_until_down: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RouterQuality {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamDatagramClientSwitchedPrimary.RouterQuality").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RouterQuality {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RouterQuality {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDatagramMsgID)
pub enum ESteamDatagramMsgID {
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingRequest)
    k_ESteamDatagramMsg_RouterPingRequest = 1,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_RouterPingReply)
    k_ESteamDatagramMsg_RouterPingReply = 2,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingRequest)
    k_ESteamDatagramMsg_GameserverPingRequest = 3,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverPingReply)
    k_ESteamDatagramMsg_GameserverPingReply = 4,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionRequest)
    k_ESteamDatagramMsg_GameserverSessionRequest = 5,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_GameserverSessionEstablished)
    k_ESteamDatagramMsg_GameserverSessionEstablished = 6,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_NoSession)
    k_ESteamDatagramMsg_NoSession = 7,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Diagnostic)
    k_ESteamDatagramMsg_Diagnostic = 8,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataClientToRouter)
    k_ESteamDatagramMsg_DataClientToRouter = 9,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToServer)
    k_ESteamDatagramMsg_DataRouterToServer = 10,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataServerToRouter)
    k_ESteamDatagramMsg_DataServerToRouter = 11,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_DataRouterToClient)
    k_ESteamDatagramMsg_DataRouterToClient = 12,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_Stats)
    k_ESteamDatagramMsg_Stats = 13,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleRequest)
    k_ESteamDatagramMsg_ClientPingSampleRequest = 14,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientPingSampleReply)
    k_ESteamDatagramMsg_ClientPingSampleReply = 15,
    // @@protoc_insertion_point(enum_value:ESteamDatagramMsgID.k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary)
    k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary = 16,
}

impl ::protobuf::Enum for ESteamDatagramMsgID {
    const NAME: &'static str = "ESteamDatagramMsgID";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDatagramMsgID> {
        match value {
            1 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest),
            2 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply),
            3 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest),
            4 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply),
            5 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest),
            6 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished),
            7 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession),
            8 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic),
            9 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter),
            10 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer),
            11 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter),
            12 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient),
            13 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats),
            14 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest),
            15 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply),
            16 => ::std::option::Option::Some(ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDatagramMsgID] = &[
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply,
        ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary,
    ];
}

impl ::protobuf::EnumFull for ESteamDatagramMsgID {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDatagramMsgID").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest => 0,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingReply => 1,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingRequest => 2,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverPingReply => 3,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionRequest => 4,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_GameserverSessionEstablished => 5,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_NoSession => 6,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Diagnostic => 7,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataClientToRouter => 8,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToServer => 9,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataServerToRouter => 10,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_DataRouterToClient => 11,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_Stats => 12,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleRequest => 13,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientPingSampleReply => 14,
            ESteamDatagramMsgID::k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary => 15,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESteamDatagramMsgID {
    fn default() -> Self {
        ESteamDatagramMsgID::k_ESteamDatagramMsg_RouterPingRequest
    }
}

impl ESteamDatagramMsgID {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamDatagramMsgID>("ESteamDatagramMsgID")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1csteamdatagram_messages.proto\"\xf3\x02\n\x20CMsgSteamDatagramRoute\
    rPingReply\x12)\n\x10client_timestamp\x18\x01\x20\x01(\x07R\x0fclientTim\
    estamp\x128\n\x16latency_datacenter_ids\x18\x02\x20\x03(\x07R\x14latency\
    DatacenterIdsB\x02\x10\x01\x12*\n\x0flatency_ping_ms\x18\x03\x20\x03(\rR\
    \rlatencyPingMsB\x02\x10\x01\x12$\n\x0eyour_public_ip\x18\x04\x20\x01(\
    \x07R\x0cyourPublicIp\x12\x1f\n\x0bserver_time\x18\x05\x20\x01(\x07R\nse\
    rverTime\x12\x1c\n\tchallenge\x18\x06\x20\x01(\x06R\tchallenge\x124\n\
    \x16seconds_until_shutdown\x18\x07\x20\x01(\rR\x14secondsUntilShutdown\
    \x12#\n\rclient_cookie\x18\x08\x20\x01(\x07R\x0cclientCookie\"\xd4\x02\n\
    \x1fCMsgSteamDatagramGameserverPing\x12%\n\x0eclient_session\x18\x01\x20\
    \x01(\rR\rclientSession\x12&\n\x0fclient_steam_id\x18\x02\x20\x01(\x06R\
    \rclientSteamId\x12)\n\x10client_timestamp\x18\x03\x20\x01(\x07R\x0fclie\
    ntTimestamp\x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTi\
    mestamp\x12:\n\x19router_gameserver_latency\x18\x05\x20\x01(\rR\x17route\
    rGameserverLatency\x12*\n\x11seq_number_router\x18\x06\x20\x01(\rR\x0fse\
    qNumberRouter\x12$\n\x0eseq_number_e2e\x18\x07\x20\x01(\rR\x0cseqNumberE\
    2e\"\xc2\x04\n%CMsgSteamDatagramGameServerAuthTicket\x12\x1f\n\x0btime_e\
    xpiry\x18\x01\x20\x01(\x07R\ntimeExpiry\x12.\n\x13authorized_steam_id\
    \x18\x02\x20\x01(\x06R\x11authorizedSteamId\x120\n\x14authorized_public_\
    ip\x18\x03\x20\x01(\x07R\x12authorizedPublicIp\x12.\n\x13gameserver_stea\
    m_id\x18\x04\x20\x01(\x06R\x11gameserverSteamId\x12*\n\x11gameserver_net\
    _id\x18\x05\x20\x01(\x06R\x0fgameserverNetId\x12\x1c\n\tsignature\x18\
    \x06\x20\x01(\x0cR\tsignature\x12\x15\n\x06app_id\x18\x07\x20\x01(\rR\
    \x05appId\x12T\n\x0cextra_fields\x18\x08\x20\x03(\x0b21.CMsgSteamDatagra\
    mGameServerAuthTicket.ExtraFieldR\x0bextraFields\x1a\xae\x01\n\nExtraFie\
    ld\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cstring_value\
    \x18\x02\x20\x01(\tR\x0bstringValue\x12\x1f\n\x0bint32_value\x18\x03\x20\
    \x01(\x11R\nint32Value\x12#\n\rfixed32_value\x18\x04\x20\x01(\x07R\x0cfi\
    xed32Value\x12#\n\rfixed64_value\x18\x05\x20\x01(\x06R\x0cfixed64Value\"\
    \xd5\x01\n)CMsgSteamDatagramGameserverSessionRequest\x12>\n\x06ticket\
    \x18\x01\x20\x01(\x0b2&.CMsgSteamDatagramGameServerAuthTicketR\x06ticket\
    \x12%\n\x0echallenge_time\x18\x03\x20\x01(\x07R\rchallengeTime\x12\x1c\n\
    \tchallenge\x18\x04\x20\x01(\x06R\tchallenge\x12#\n\rclient_cookie\x18\
    \x05\x20\x01(\x07R\x0cclientCookie\"\xba\x01\n-CMsgSteamDatagramGameserv\
    erSessionEstablished\x12#\n\rclient_cookie\x18\x01\x20\x01(\x07R\x0cclie\
    ntCookie\x12.\n\x13gameserver_steam_id\x18\x03\x20\x01(\x06R\x11gameserv\
    erSteamId\x124\n\x16seconds_until_shutdown\x18\x04\x20\x01(\rR\x14second\
    sUntilShutdown\"\xdc\x01\n\x1aCMsgSteamDatagramNoSession\x12#\n\rclient_\
    cookie\x18\x07\x20\x01(\x07R\x0cclientCookie\x12$\n\x0eyour_public_ip\
    \x18\x02\x20\x01(\x07R\x0cyourPublicIp\x12\x1f\n\x0bserver_time\x18\x03\
    \x20\x01(\x07R\nserverTime\x12\x1c\n\tchallenge\x18\x04\x20\x01(\x06R\tc\
    hallenge\x124\n\x16seconds_until_shutdown\x18\x05\x20\x01(\rR\x14seconds\
    UntilShutdown\"M\n\x1bCMsgSteamDatagramDiagnostic\x12\x1a\n\x08severity\
    \x18\x01\x20\x01(\rR\x08severity\x12\x12\n\x04text\x18\x02\x20\x01(\tR\
    \x04text\"\xa1\x02\n\x20CMsgSteamDatagramDataCenterState\x12O\n\x0cdata_\
    centers\x18\x01\x20\x03(\x0b2,.CMsgSteamDatagramDataCenterState.DataCent\
    erR\x0bdataCenters\x1a;\n\x06Server\x12\x18\n\x07address\x18\x01\x20\x01\
    (\tR\x07address\x12\x17\n\x07ping_ms\x18\x02\x20\x01(\rR\x06pingMs\x1ao\
    \n\nDataCenter\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12M\n\rser\
    ver_sample\x18\x02\x20\x03(\x0b2(.CMsgSteamDatagramDataCenterState.Serve\
    rR\x0cserverSample\"\xed\x02\n'CMsgSteamDatagramLinkInstantaneousStats\
    \x124\n\x17out_packets_per_sec_x10\x18\x01\x20\x01(\rR\x13outPacketsPerS\
    ecX10\x12)\n\x11out_bytes_per_sec\x18\x02\x20\x01(\rR\x0eoutBytesPerSec\
    \x122\n\x16in_packets_per_sec_x10\x18\x03\x20\x01(\rR\x12inPacketsPerSec\
    X10\x12'\n\x10in_bytes_per_sec\x18\x04\x20\x01(\rR\rinBytesPerSec\x12\
    \x17\n\x07ping_ms\x18\x05\x20\x01(\rR\x06pingMs\x12.\n\x13packets_droppe\
    d_pct\x18\x06\x20\x01(\rR\x11packetsDroppedPct\x12;\n\x1apackets_weird_s\
    equence_pct\x18\x07\x20\x01(\rR\x17packetsWeirdSequencePct\"\xa2\x03\n\"\
    CMsgSteamDatagramLinkLifetimeStats\x12!\n\x0cpackets_sent\x18\x03\x20\
    \x01(\x04R\x0bpacketsSent\x12\x17\n\x07kb_sent\x18\x04\x20\x01(\x04R\x06\
    kbSent\x12!\n\x0cpackets_recv\x18\x05\x20\x01(\x04R\x0bpacketsRecv\x12\
    \x17\n\x07kb_recv\x18\x06\x20\x01(\x04R\x06kbRecv\x124\n\x16packets_recv\
    _sequenced\x18\x07\x20\x01(\x04R\x14packetsRecvSequenced\x120\n\x14packe\
    ts_recv_dropped\x18\x08\x20\x01(\x04R\x12packetsRecvDropped\x128\n\x19pa\
    ckets_recv_out_of_order\x18\t\x20\x01(\x04R\x15packetsRecvOutOfOrder\x12\
    4\n\x16packets_recv_duplicate\x18\n\x20\x01(\x04R\x14packetsRecvDuplicat\
    e\x12,\n\x12packets_recv_lurch\x18\x0b\x20\x01(\x04R\x10packetsRecvLurch\
    \"\xb5\x01\n\"CMsgSteamDatagramConnectionQuality\x12N\n\rinstantaneous\
    \x18\x01\x20\x01(\x0b2(.CMsgSteamDatagramLinkInstantaneousStatsR\rinstan\
    taneous\x12?\n\x08lifetime\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramLinkL\
    ifetimeStatsR\x08lifetime\"\xae\x02\n.CMsgSteamDatagramConnectionStatsCl\
    ientToRouter\x125\n\x03c2r\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramConne\
    ctionQualityR\x03c2r\x125\n\x03c2s\x18\x02\x20\x01(\x0b2#.CMsgSteamDatag\
    ramConnectionQualityR\x03c2s\x12)\n\x10client_timestamp\x18\x03\x20\x01(\
    \x07R\x0fclientTimestamp\x12#\n\rclient_cookie\x18\x08\x20\x01(\x07R\x0c\
    clientCookie\x12\x1e\n\x0bseq_num_c2r\x18\t\x20\x01(\rR\tseqNumC2r\x12\
    \x1e\n\x0bseq_num_c2s\x18\n\x20\x01(\rR\tseqNumC2s\"\xf7\x03\n.CMsgSteam\
    DatagramConnectionStatsRouterToClient\x125\n\x03r2c\x18\x01\x20\x01(\x0b\
    2#.CMsgSteamDatagramConnectionQualityR\x03r2c\x125\n\x03s2c\x18\x02\x20\
    \x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03s2c\x12?\n\x1cclient_\
    timestamp_from_router\x18\x03\x20\x01(\x07R\x19clientTimestampFromRouter\
    \x12?\n\x1cclient_timestamp_from_server\x18\x04\x20\x01(\x07R\x19clientT\
    imestampFromServer\x12:\n\x19router_gameserver_latency\x18\x05\x20\x01(\
    \rR\x17routerGameserverLatency\x124\n\x16seconds_until_shutdown\x18\x06\
    \x20\x01(\rR\x14secondsUntilShutdown\x12#\n\rclient_cookie\x18\x07\x20\
    \x01(\x07R\x0cclientCookie\x12\x1e\n\x0bseq_num_r2c\x18\x08\x20\x01(\rR\
    \tseqNumR2c\x12\x1e\n\x0bseq_num_s2c\x18\t\x20\x01(\rR\tseqNumS2c\"\x88\
    \x03\n.CMsgSteamDatagramConnectionStatsRouterToServer\x125\n\x03r2s\x18\
    \x01\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03r2s\x125\n\
    \x03c2s\x18\x02\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x03c2\
    s\x12)\n\x10client_timestamp\x18\x03\x20\x01(\x07R\x0fclientTimestamp\
    \x12)\n\x10router_timestamp\x18\x04\x20\x01(\x07R\x0frouterTimestamp\x12\
    \x1e\n\x0bseq_num_r2s\x18\x05\x20\x01(\rR\tseqNumR2s\x12\x1e\n\x0bseq_nu\
    m_c2s\x18\x06\x20\x01(\rR\tseqNumC2s\x12&\n\x0fclient_steam_id\x18\x07\
    \x20\x01(\x06R\rclientSteamId\x12*\n\x11client_session_id\x18\x08\x20\
    \x01(\rR\x0fclientSessionId\"\xb2\x02\n.CMsgSteamDatagramConnectionStats\
    ServerToRouter\x125\n\x03s2r\x18\x01\x20\x01(\x0b2#.CMsgSteamDatagramCon\
    nectionQualityR\x03s2r\x125\n\x03s2c\x18\x02\x20\x01(\x0b2#.CMsgSteamDat\
    agramConnectionQualityR\x03s2c\x12\x1e\n\x0bseq_num_s2r\x18\x03\x20\x01(\
    \rR\tseqNumS2r\x12\x1e\n\x0bseq_num_s2c\x18\x04\x20\x01(\rR\tseqNumS2c\
    \x12&\n\x0fclient_steam_id\x18\x05\x20\x01(\x06R\rclientSteamId\x12*\n\
    \x11client_session_id\x18\x06\x20\x01(\rR\x0fclientSessionId\"O\n(CMsgSt\
    eamDatagramClientPingSampleRequest\x12#\n\rclient_cookie\x18\x01\x20\x01\
    (\x07R\x0cclientCookie\"\x96\x02\n&CMsgSteamDatagramClientPingSampleRepl\
    y\x12#\n\rclient_cookie\x18\x01\x20\x01(\x07R\x0cclientCookie\x12a\n\x10\
    routing_clusters\x18\x02\x20\x03(\x0b26.CMsgSteamDatagramClientPingSampl\
    eReply.RoutingClusterR\x0froutingClusters\x1ad\n\x0eRoutingCluster\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x07R\x02id\x12\"\n\rfront_ping_ms\x18\x02\
    \x20\x01(\rR\x0bfrontPingMs\x12\x1e\n\x0be2e_ping_ms\x18\x03\x20\x01(\rR\
    \te2ePingMs\"\xef\x06\n&CMsgSteamDatagramClientSwitchedPrimary\x12#\n\rc\
    lient_cookie\x18\x01\x20\x01(\x07R\x0cclientCookie\x12\x17\n\x07from_ip\
    \x18\x02\x20\x01(\x07R\x06fromIp\x12\x1b\n\tfrom_port\x18\x03\x20\x01(\r\
    R\x08fromPort\x12.\n\x13from_router_cluster\x18\x04\x20\x01(\x07R\x11fro\
    mRouterCluster\x12(\n\x10from_active_time\x18\x05\x20\x01(\rR\x0efromAct\
    iveTime\x127\n\x18from_active_packets_recv\x18\x06\x20\x01(\rR\x15fromAc\
    tivePacketsRecv\x12.\n\x13from_dropped_reason\x18\x07\x20\x01(\tR\x11fro\
    mDroppedReason\x12\x15\n\x06gap_ms\x18\x08\x20\x01(\rR\x05gapMs\x12_\n\
    \x10from_quality_now\x18\t\x20\x01(\x0b25.CMsgSteamDatagramClientSwitche\
    dPrimary.RouterQualityR\x0efromQualityNow\x12[\n\x0eto_quality_now\x18\n\
    \x20\x01(\x0b25.CMsgSteamDatagramClientSwitchedPrimary.RouterQualityR\
    \x0ctoQualityNow\x12a\n\x11from_quality_then\x18\x0b\x20\x01(\x0b25.CMsg\
    SteamDatagramClientSwitchedPrimary.RouterQualityR\x0ffromQualityThen\x12\
    ]\n\x0fto_quality_then\x18\x0c\x20\x01(\x0b25.CMsgSteamDatagramClientSwi\
    tchedPrimary.RouterQualityR\rtoQualityThen\x1a\x8f\x01\n\rRouterQuality\
    \x12\x14\n\x05score\x18\x01\x20\x01(\rR\x05score\x12\x1d\n\nfront_ping\
    \x18\x02\x20\x01(\rR\tfrontPing\x12\x1b\n\tback_ping\x18\x03\x20\x01(\rR\
    \x08backPing\x12,\n\x12seconds_until_down\x18\x04\x20\x01(\rR\x10seconds\
    UntilDown*\xda\x05\n\x13ESteamDatagramMsgID\x12)\n%k_ESteamDatagramMsg_R\
    outerPingRequest\x10\x01\x12'\n#k_ESteamDatagramMsg_RouterPingReply\x10\
    \x02\x12-\n)k_ESteamDatagramMsg_GameserverPingRequest\x10\x03\x12+\n'k_E\
    SteamDatagramMsg_GameserverPingReply\x10\x04\x120\n,k_ESteamDatagramMsg_\
    GameserverSessionRequest\x10\x05\x124\n0k_ESteamDatagramMsg_GameserverSe\
    ssionEstablished\x10\x06\x12!\n\x1dk_ESteamDatagramMsg_NoSession\x10\x07\
    \x12\"\n\x1ek_ESteamDatagramMsg_Diagnostic\x10\x08\x12*\n&k_ESteamDatagr\
    amMsg_DataClientToRouter\x10\t\x12*\n&k_ESteamDatagramMsg_DataRouterToSe\
    rver\x10\n\x12*\n&k_ESteamDatagramMsg_DataServerToRouter\x10\x0b\x12*\n&\
    k_ESteamDatagramMsg_DataRouterToClient\x10\x0c\x12\x1d\n\x19k_ESteamData\
    gramMsg_Stats\x10\r\x12/\n+k_ESteamDatagramMsg_ClientPingSampleRequest\
    \x10\x0e\x12-\n)k_ESteamDatagramMsg_ClientPingSampleReply\x10\x0f\x125\n\
    1k_ESteamDatagramMsg_ClientToRouterSwitchedPrimary\x10\x10B\x03\x80\x01\
    \0J\xbaL\n\x07\x12\x05\0\0\xcc\x01\x01\n\x08\n\x01\x08\x12\x03\0\0#\n\t\
    \n\x02\x08\x10\x12\x03\0\0#\n\n\n\x02\x05\0\x12\x04\x02\0\x13\x01\n\n\n\
    \x03\x05\0\x01\x12\x03\x02\x05\x18\n\x0b\n\x04\x05\0\x02\0\x12\x03\x03\
    \x082\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x03\x08-\n\x0c\n\x05\x05\0\x02\
    \0\x02\x12\x03\x0301\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x04\x080\n\x0c\n\
    \x05\x05\0\x02\x01\x01\x12\x03\x04\x08+\n\x0c\n\x05\x05\0\x02\x01\x02\
    \x12\x03\x04./\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x05\x086\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03\x05\x081\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03\x0545\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x06\x084\n\x0c\n\x05\x05\0\
    \x02\x03\x01\x12\x03\x06\x08/\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x062\
    3\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x07\x089\n\x0c\n\x05\x05\0\x02\x04\
    \x01\x12\x03\x07\x084\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x0778\n\x0b\
    \n\x04\x05\0\x02\x05\x12\x03\x08\x08=\n\x0c\n\x05\x05\0\x02\x05\x01\x12\
    \x03\x08\x088\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x08;<\n\x0b\n\x04\
    \x05\0\x02\x06\x12\x03\t\x08*\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\t\
    \x08%\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\t()\n\x0b\n\x04\x05\0\x02\
    \x07\x12\x03\n\x08+\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\n\x08&\n\x0c\n\
    \x05\x05\0\x02\x07\x02\x12\x03\n)*\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0b\
    \x083\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x0b\x08.\n\x0c\n\x05\x05\0\
    \x02\x08\x02\x12\x03\x0b12\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0c\x084\n\
    \x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0c\x08.\n\x0c\n\x05\x05\0\x02\t\x02\
    \x12\x03\x0c13\n\x0b\n\x04\x05\0\x02\n\x12\x03\r\x084\n\x0c\n\x05\x05\0\
    \x02\n\x01\x12\x03\r\x08.\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\r13\n\x0b\
    \n\x04\x05\0\x02\x0b\x12\x03\x0e\x084\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\
    \x03\x0e\x08.\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x0e13\n\x0b\n\x04\
    \x05\0\x02\x0c\x12\x03\x0f\x08'\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\
    \x0f\x08!\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x0f$&\n\x0b\n\x04\x05\0\
    \x02\r\x12\x03\x10\x089\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x10\x083\n\
    \x0c\n\x05\x05\0\x02\r\x02\x12\x03\x1068\n\x0b\n\x04\x05\0\x02\x0e\x12\
    \x03\x11\x087\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x11\x081\n\x0c\n\x05\
    \x05\0\x02\x0e\x02\x12\x03\x1146\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x12\
    \x08?\n\x0c\n\x05\x05\0\x02\x0f\x01\x12\x03\x12\x089\n\x0c\n\x05\x05\0\
    \x02\x0f\x02\x12\x03\x12<>\n\n\n\x02\x04\0\x12\x04\x15\0\x1e\x01\n\n\n\
    \x03\x04\0\x01\x12\x03\x15\x08(\n\x0b\n\x04\x04\0\x02\0\x12\x03\x16\x08.\
    \n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x16\x08\x10\n\x0c\n\x05\x04\0\x02\0\
    \x05\x12\x03\x16\x11\x18\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x16\x19)\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x16,-\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x17\x08D\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x17\x08\x10\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\x17\x11\x18\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x17\x19/\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1723\n\x0c\n\
    \x05\x04\0\x02\x01\x08\x12\x03\x174C\n\r\n\x06\x04\0\x02\x01\x08\x02\x12\
    \x03\x175B\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x18\x08<\n\x0c\n\x05\x04\0\
    \x02\x02\x04\x12\x03\x18\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\
    \x18\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x18\x18'\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03\x18*+\n\x0c\n\x05\x04\0\x02\x02\x08\x12\x03\
    \x18,;\n\r\n\x06\x04\0\x02\x02\x08\x02\x12\x03\x18-:\n\x0b\n\x04\x04\0\
    \x02\x03\x12\x03\x19\x08,\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x19\x08\
    \x10\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x19\x11\x18\n\x0c\n\x05\x04\0\
    \x02\x03\x01\x12\x03\x19\x19'\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x19*\
    +\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x1a\x08)\n\x0c\n\x05\x04\0\x02\x04\
    \x04\x12\x03\x1a\x08\x10\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x1a\x11\
    \x18\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1a\x19$\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03\x1a'(\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x1b\x08'\n\
    \x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x1b\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x05\x05\x12\x03\x1b\x11\x18\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x1b\
    \x19\"\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x1b%&\n\x0b\n\x04\x04\0\x02\
    \x06\x12\x03\x1c\x083\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x1c\x08\x10\
    \n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x1c\x11\x17\n\x0c\n\x05\x04\0\x02\
    \x06\x01\x12\x03\x1c\x18.\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1c12\n\
    \x0b\n\x04\x04\0\x02\x07\x12\x03\x1d\x08+\n\x0c\n\x05\x04\0\x02\x07\x04\
    \x12\x03\x1d\x08\x10\n\x0c\n\x05\x04\0\x02\x07\x05\x12\x03\x1d\x11\x18\n\
    \x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x1d\x19&\n\x0c\n\x05\x04\0\x02\x07\
    \x03\x12\x03\x1d)*\n\n\n\x02\x04\x01\x12\x04\x20\0(\x01\n\n\n\x03\x04\
    \x01\x01\x12\x03\x20\x08'\n\x0b\n\x04\x04\x01\x02\0\x12\x03!\x08+\n\x0c\
    \n\x05\x04\x01\x02\0\x04\x12\x03!\x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\
    \x12\x03!\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03!\x18&\n\x0c\n\
    \x05\x04\x01\x02\0\x03\x12\x03!)*\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\"\
    \x08-\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\"\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x03\"\x11\x18\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03\"\x19(\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\"+,\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03#\x08.\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03#\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03#\x11\x18\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03#\x19)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03#,\
    -\n\x0b\n\x04\x04\x01\x02\x03\x12\x03$\x08.\n\x0c\n\x05\x04\x01\x02\x03\
    \x04\x12\x03$\x08\x10\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03$\x11\x18\n\
    \x0c\n\x05\x04\x01\x02\x03\x01\x12\x03$\x19)\n\x0c\n\x05\x04\x01\x02\x03\
    \x03\x12\x03$,-\n\x0b\n\x04\x04\x01\x02\x04\x12\x03%\x086\n\x0c\n\x05\
    \x04\x01\x02\x04\x04\x12\x03%\x08\x10\n\x0c\n\x05\x04\x01\x02\x04\x05\
    \x12\x03%\x11\x17\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03%\x181\n\x0c\n\
    \x05\x04\x01\x02\x04\x03\x12\x03%45\n\x0b\n\x04\x04\x01\x02\x05\x12\x03&\
    \x08.\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03&\x08\x10\n\x0c\n\x05\x04\
    \x01\x02\x05\x05\x12\x03&\x11\x17\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\
    \x03&\x18)\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03&,-\n\x0b\n\x04\x04\
    \x01\x02\x06\x12\x03'\x08+\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03'\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03'\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\x06\x01\x12\x03'\x18&\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03')\
    *\n\n\n\x02\x04\x02\x12\x04*\0;\x01\n\n\n\x03\x04\x02\x01\x12\x03*\x08-\
    \n\x0c\n\x04\x04\x02\x03\0\x12\x04+\x081\t\n\x0c\n\x05\x04\x02\x03\0\x01\
    \x12\x03+\x10\x1a\n\r\n\x06\x04\x02\x03\0\x02\0\x12\x03,\x10)\n\x0e\n\
    \x07\x04\x02\x03\0\x02\0\x04\x12\x03,\x10\x18\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x05\x12\x03,\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03,\
    \x20$\n\x0e\n\x07\x04\x02\x03\0\x02\0\x03\x12\x03,'(\n\r\n\x06\x04\x02\
    \x03\0\x02\x01\x12\x03-\x101\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x04\x12\
    \x03-\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\x03-\x19\x1f\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03-\x20,\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x01\x03\x12\x03-/0\n\r\n\x06\x04\x02\x03\0\x02\x02\x12\x03.\
    \x100\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x03.\x10\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x02\x05\x12\x03.\x19\x1f\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x02\x01\x12\x03.\x20+\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x03\x12\x03\
    ../\n\r\n\x06\x04\x02\x03\0\x02\x03\x12\x03/\x103\n\x0e\n\x07\x04\x02\
    \x03\0\x02\x03\x04\x12\x03/\x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x03\
    \x05\x12\x03/\x19\x20\n\x0e\n\x07\x04\x02\x03\0\x02\x03\x01\x12\x03/!.\n\
    \x0e\n\x07\x04\x02\x03\0\x02\x03\x03\x12\x03/12\n\r\n\x06\x04\x02\x03\0\
    \x02\x04\x12\x030\x103\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x04\x12\x030\
    \x10\x18\n\x0e\n\x07\x04\x02\x03\0\x02\x04\x05\x12\x030\x19\x20\n\x0e\n\
    \x07\x04\x02\x03\0\x02\x04\x01\x12\x030!.\n\x0e\n\x07\x04\x02\x03\0\x02\
    \x04\x03\x12\x03012\n\x0b\n\x04\x04\x02\x02\0\x12\x033\x08)\n\x0c\n\x05\
    \x04\x02\x02\0\x04\x12\x033\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x033\x11\x18\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x033\x19$\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x033'(\n\x0b\n\x04\x04\x02\x02\x01\x12\x034\x081\
    \n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x034\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x034\x11\x18\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x034\
    \x19,\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x034/0\n\x0b\n\x04\x04\x02\x02\
    \x02\x12\x035\x082\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x035\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x02\x05\x12\x035\x11\x18\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x035\x19-\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03501\n\x0b\
    \n\x04\x04\x02\x02\x03\x12\x036\x081\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\
    \x036\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x036\x11\x18\n\x0c\n\
    \x05\x04\x02\x02\x03\x01\x12\x036\x19,\n\x0c\n\x05\x04\x02\x02\x03\x03\
    \x12\x036/0\n\x0b\n\x04\x04\x02\x02\x04\x12\x037\x08/\n\x0c\n\x05\x04\
    \x02\x02\x04\x04\x12\x037\x08\x10\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\
    \x037\x11\x18\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x037\x19*\n\x0c\n\x05\
    \x04\x02\x02\x04\x03\x12\x037-.\n\x0b\n\x04\x04\x02\x02\x05\x12\x038\x08\
    %\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x038\x08\x10\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x038\x11\x16\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x038\
    \x17\x20\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x038#$\n\x0b\n\x04\x04\x02\
    \x02\x06\x12\x039\x08#\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x039\x08\x10\
    \n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x039\x11\x17\n\x0c\n\x05\x04\x02\
    \x02\x06\x01\x12\x039\x18\x1e\n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x039!\
    \"\n\x0b\n\x04\x04\x02\x02\x07\x12\x03:\x08T\n\x0c\n\x05\x04\x02\x02\x07\
    \x04\x12\x03:\x08\x10\n\x0c\n\x05\x04\x02\x02\x07\x06\x12\x03:\x11B\n\
    \x0c\n\x05\x04\x02\x02\x07\x01\x12\x03:CO\n\x0c\n\x05\x04\x02\x02\x07\
    \x03\x12\x03:RS\n\n\n\x02\x04\x03\x12\x04=\0B\x01\n\n\n\x03\x04\x03\x01\
    \x12\x03=\x081\n\x0b\n\x04\x04\x03\x02\0\x12\x03>\x08C\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03>\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03>\
    \x117\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03>8>\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03>AB\n\x0b\n\x04\x04\x03\x02\x01\x12\x03?\x08,\n\x0c\n\x05\
    \x04\x03\x02\x01\x04\x12\x03?\x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\
    \x12\x03?\x11\x18\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03?\x19'\n\x0c\n\
    \x05\x04\x03\x02\x01\x03\x12\x03?*+\n\x0b\n\x04\x04\x03\x02\x02\x12\x03@\
    \x08'\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\
    \x03\x02\x02\x05\x12\x03@\x11\x18\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\
    \x03@\x19\"\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03@%&\n\x0b\n\x04\x04\
    \x03\x02\x03\x12\x03A\x08+\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03A\x08\
    \x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03A\x11\x18\n\x0c\n\x05\x04\
    \x03\x02\x03\x01\x12\x03A\x19&\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03A)\
    *\n\n\n\x02\x04\x04\x12\x04D\0H\x01\n\n\n\x03\x04\x04\x01\x12\x03D\x085\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03E\x08+\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x03E\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03E\x11\x18\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03E\x19&\n\x0c\n\x05\x04\x04\x02\0\x03\x12\
    \x03E)*\n\x0b\n\x04\x04\x04\x02\x01\x12\x03F\x081\n\x0c\n\x05\x04\x04\
    \x02\x01\x04\x12\x03F\x08\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03F\
    \x11\x18\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03F\x19,\n\x0c\n\x05\x04\
    \x04\x02\x01\x03\x12\x03F/0\n\x0b\n\x04\x04\x04\x02\x02\x12\x03G\x083\n\
    \x0c\n\x05\x04\x04\x02\x02\x04\x12\x03G\x08\x10\n\x0c\n\x05\x04\x04\x02\
    \x02\x05\x12\x03G\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03G\x18.\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03G12\n\n\n\x02\x04\x05\x12\x04J\0\
    P\x01\n\n\n\x03\x04\x05\x01\x12\x03J\x08\"\n\x0b\n\x04\x04\x05\x02\0\x12\
    \x03K\x08+\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03K\x08\x10\n\x0c\n\x05\
    \x04\x05\x02\0\x05\x12\x03K\x11\x18\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x03K\x19&\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03K)*\n\x0b\n\x04\x04\x05\
    \x02\x01\x12\x03L\x08,\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x03L\x08\x10\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x03L\x11\x18\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x03L\x19'\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x03L*+\n\
    \x0b\n\x04\x04\x05\x02\x02\x12\x03M\x08)\n\x0c\n\x05\x04\x05\x02\x02\x04\
    \x12\x03M\x08\x10\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03M\x11\x18\n\x0c\
    \n\x05\x04\x05\x02\x02\x01\x12\x03M\x19$\n\x0c\n\x05\x04\x05\x02\x02\x03\
    \x12\x03M'(\n\x0b\n\x04\x04\x05\x02\x03\x12\x03N\x08'\n\x0c\n\x05\x04\
    \x05\x02\x03\x04\x12\x03N\x08\x10\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\
    \x03N\x11\x18\n\x0c\n\x05\x04\x05\x02\x03\x01\x12\x03N\x19\"\n\x0c\n\x05\
    \x04\x05\x02\x03\x03\x12\x03N%&\n\x0b\n\x04\x04\x05\x02\x04\x12\x03O\x08\
    3\n\x0c\n\x05\x04\x05\x02\x04\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x05\
    \x02\x04\x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03O\
    \x18.\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03O12\n\n\n\x02\x04\x06\x12\
    \x04R\0U\x01\n\n\n\x03\x04\x06\x01\x12\x03R\x08#\n\x0b\n\x04\x04\x06\x02\
    \0\x12\x03S\x08%\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03S\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03S\x11\x17\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03S\x18\x20\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03S#$\n\x0b\n\x04\
    \x04\x06\x02\x01\x12\x03T\x08!\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03T\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03T\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\x01\x01\x12\x03T\x18\x1c\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03T\x1f\x20\n\n\n\x02\x04\x07\x12\x04W\0c\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03W\x08(\n\x0c\n\x04\x04\x07\x03\0\x12\x04X\x08[\t\n\x0c\n\x05\
    \x04\x07\x03\0\x01\x12\x03X\x10\x16\n\r\n\x06\x04\x07\x03\0\x02\0\x12\
    \x03Y\x10,\n\x0e\n\x07\x04\x07\x03\0\x02\0\x04\x12\x03Y\x10\x18\n\x0e\n\
    \x07\x04\x07\x03\0\x02\0\x05\x12\x03Y\x19\x1f\n\x0e\n\x07\x04\x07\x03\0\
    \x02\0\x01\x12\x03Y\x20'\n\x0e\n\x07\x04\x07\x03\0\x02\0\x03\x12\x03Y*+\
    \n\r\n\x06\x04\x07\x03\0\x02\x01\x12\x03Z\x10,\n\x0e\n\x07\x04\x07\x03\0\
    \x02\x01\x04\x12\x03Z\x10\x18\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x05\x12\
    \x03Z\x19\x1f\n\x0e\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x03Z\x20'\n\x0e\
    \n\x07\x04\x07\x03\0\x02\x01\x03\x12\x03Z*+\n\x0c\n\x04\x04\x07\x03\x01\
    \x12\x04]\x08`\t\n\x0c\n\x05\x04\x07\x03\x01\x01\x12\x03]\x10\x1a\n\r\n\
    \x06\x04\x07\x03\x01\x02\0\x12\x03^\x10)\n\x0e\n\x07\x04\x07\x03\x01\x02\
    \0\x04\x12\x03^\x10\x18\n\x0e\n\x07\x04\x07\x03\x01\x02\0\x05\x12\x03^\
    \x19\x1f\n\x0e\n\x07\x04\x07\x03\x01\x02\0\x01\x12\x03^\x20$\n\x0e\n\x07\
    \x04\x07\x03\x01\x02\0\x03\x12\x03^'(\n\r\n\x06\x04\x07\x03\x01\x02\x01\
    \x12\x03_\x10T\n\x0e\n\x07\x04\x07\x03\x01\x02\x01\x04\x12\x03_\x10\x18\
    \n\x0e\n\x07\x04\x07\x03\x01\x02\x01\x06\x12\x03_\x19A\n\x0e\n\x07\x04\
    \x07\x03\x01\x02\x01\x01\x12\x03_BO\n\x0e\n\x07\x04\x07\x03\x01\x02\x01\
    \x03\x12\x03_RS\n\x0b\n\x04\x04\x07\x02\0\x12\x03b\x08O\n\x0c\n\x05\x04\
    \x07\x02\0\x04\x12\x03b\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03b\
    \x11=\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03b>J\n\x0c\n\x05\x04\x07\x02\0\
    \x03\x12\x03bMN\n\n\n\x02\x04\x08\x12\x04e\0m\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03e\x08/\n\x0b\n\x04\x04\x08\x02\0\x12\x03f\x084\n\x0c\n\x05\x04\
    \x08\x02\0\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03f\
    \x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03f\x18/\n\x0c\n\x05\x04\x08\
    \x02\0\x03\x12\x03f23\n\x0b\n\x04\x04\x08\x02\x01\x12\x03g\x08.\n\x0c\n\
    \x05\x04\x08\x02\x01\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x08\x02\x01\
    \x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03g\x18)\n\
    \x0c\n\x05\x04\x08\x02\x01\x03\x12\x03g,-\n\x0b\n\x04\x04\x08\x02\x02\
    \x12\x03h\x083\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03h\x08\x10\n\x0c\n\
    \x05\x04\x08\x02\x02\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03h\x18.\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03h12\n\x0b\n\
    \x04\x04\x08\x02\x03\x12\x03i\x08-\n\x0c\n\x05\x04\x08\x02\x03\x04\x12\
    \x03i\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03i\x11\x17\n\x0c\n\
    \x05\x04\x08\x02\x03\x01\x12\x03i\x18(\n\x0c\n\x05\x04\x08\x02\x03\x03\
    \x12\x03i+,\n\x0b\n\x04\x04\x08\x02\x04\x12\x03j\x08$\n\x0c\n\x05\x04\
    \x08\x02\x04\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\
    \x03j\x11\x17\n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03j\x18\x1f\n\x0c\n\
    \x05\x04\x08\x02\x04\x03\x12\x03j\"#\n\x0b\n\x04\x04\x08\x02\x05\x12\x03\
    k\x080\n\x0c\n\x05\x04\x08\x02\x05\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\
    \x08\x02\x05\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\
    \x03k\x18+\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03k./\n\x0b\n\x04\x04\
    \x08\x02\x06\x12\x03l\x087\n\x0c\n\x05\x04\x08\x02\x06\x04\x12\x03l\x08\
    \x10\n\x0c\n\x05\x04\x08\x02\x06\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\
    \x08\x02\x06\x01\x12\x03l\x182\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\x03l5\
    6\n\n\n\x02\x04\t\x12\x04o\0y\x01\n\n\n\x03\x04\t\x01\x12\x03o\x08*\n\
    \x0b\n\x04\x04\t\x02\0\x12\x03p\x08)\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03\
    p\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03p\x11\x17\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03p\x18$\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03p'(\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03q\x08$\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03q\
    \x08\x10\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\
    \t\x02\x01\x01\x12\x03q\x18\x1f\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03q\"\
    #\n\x0b\n\x04\x04\t\x02\x02\x12\x03r\x08)\n\x0c\n\x05\x04\t\x02\x02\x04\
    \x12\x03r\x08\x10\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03r\x11\x17\n\x0c\n\
    \x05\x04\t\x02\x02\x01\x12\x03r\x18$\n\x0c\n\x05\x04\t\x02\x02\x03\x12\
    \x03r'(\n\x0b\n\x04\x04\t\x02\x03\x12\x03s\x08$\n\x0c\n\x05\x04\t\x02\
    \x03\x04\x12\x03s\x08\x10\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03s\x11\x17\
    \n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03s\x18\x1f\n\x0c\n\x05\x04\t\x02\
    \x03\x03\x12\x03s\"#\n\x0b\n\x04\x04\t\x02\x04\x12\x03t\x083\n\x0c\n\x05\
    \x04\t\x02\x04\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\t\x02\x04\x05\x12\
    \x03t\x11\x17\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03t\x18.\n\x0c\n\x05\
    \x04\t\x02\x04\x03\x12\x03t12\n\x0b\n\x04\x04\t\x02\x05\x12\x03u\x081\n\
    \x0c\n\x05\x04\t\x02\x05\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\t\x02\x05\
    \x05\x12\x03u\x11\x17\n\x0c\n\x05\x04\t\x02\x05\x01\x12\x03u\x18,\n\x0c\
    \n\x05\x04\t\x02\x05\x03\x12\x03u/0\n\x0b\n\x04\x04\t\x02\x06\x12\x03v\
    \x086\n\x0c\n\x05\x04\t\x02\x06\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\t\
    \x02\x06\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\t\x02\x06\x01\x12\x03v\x18\
    1\n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03v45\n\x0b\n\x04\x04\t\x02\x07\x12\
    \x03w\x084\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03w\x08\x10\n\x0c\n\x05\
    \x04\t\x02\x07\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\t\x02\x07\x01\x12\
    \x03w\x18.\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03w13\n\x0b\n\x04\x04\t\
    \x02\x08\x12\x03x\x080\n\x0c\n\x05\x04\t\x02\x08\x04\x12\x03x\x08\x10\n\
    \x0c\n\x05\x04\t\x02\x08\x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\t\x02\x08\
    \x01\x12\x03x\x18*\n\x0c\n\x05\x04\t\x02\x08\x03\x12\x03x-/\n\n\n\x02\
    \x04\n\x12\x04{\0~\x01\n\n\n\x03\x04\n\x01\x12\x03{\x08*\n\x0b\n\x04\x04\
    \n\x02\0\x12\x03|\x08L\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03|\x08\x10\n\
    \x0c\n\x05\x04\n\x02\0\x06\x12\x03|\x119\n\x0c\n\x05\x04\n\x02\0\x01\x12\
    \x03|:G\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03|JK\n\x0b\n\x04\x04\n\x02\x01\
    \x12\x03}\x08B\n\x0c\n\x05\x04\n\x02\x01\x04\x12\x03}\x08\x10\n\x0c\n\
    \x05\x04\n\x02\x01\x06\x12\x03}\x114\n\x0c\n\x05\x04\n\x02\x01\x01\x12\
    \x03}5=\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03}@A\n\x0c\n\x02\x04\x0b\x12\
    \x06\x80\x01\0\x87\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x80\x01\x086\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\x81\x01\x08=\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x81\x01\
    \x114\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x81\x0158\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\x81\x01;<\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x82\x01\
    \x08=\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\x01\x06\x12\x04\x82\x01\x114\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\x82\x0158\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x82\x01;<\n\x0c\
    \n\x04\x04\x0b\x02\x02\x12\x04\x83\x01\x08.\n\r\n\x05\x04\x0b\x02\x02\
    \x04\x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\x83\
    \x01\x11\x18\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x83\x01\x19)\n\r\n\
    \x05\x04\x0b\x02\x02\x03\x12\x04\x83\x01,-\n\x0c\n\x04\x04\x0b\x02\x03\
    \x12\x04\x84\x01\x08+\n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\x84\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\x84\x01\x11\x18\n\r\n\x05\x04\
    \x0b\x02\x03\x01\x12\x04\x84\x01\x19&\n\r\n\x05\x04\x0b\x02\x03\x03\x12\
    \x04\x84\x01)*\n\x0c\n\x04\x04\x0b\x02\x04\x12\x04\x85\x01\x08(\n\r\n\
    \x05\x04\x0b\x02\x04\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x04\x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\
    \x85\x01\x18#\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\x85\x01&'\n\x0c\n\
    \x04\x04\x0b\x02\x05\x12\x04\x86\x01\x08)\n\r\n\x05\x04\x0b\x02\x05\x04\
    \x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x86\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x86\x01\x18#\n\r\n\x05\
    \x04\x0b\x02\x05\x03\x12\x04\x86\x01&(\n\x0c\n\x02\x04\x0c\x12\x06\x89\
    \x01\0\x93\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x89\x01\x086\n\x0c\n\
    \x04\x04\x0c\x02\0\x12\x04\x8a\x01\x08=\n\r\n\x05\x04\x0c\x02\0\x04\x12\
    \x04\x8a\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\x8a\x01\x114\n\
    \r\n\x05\x04\x0c\x02\0\x01\x12\x04\x8a\x0158\n\r\n\x05\x04\x0c\x02\0\x03\
    \x12\x04\x8a\x01;<\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\x8b\x01\x08=\n\r\
    \n\x05\x04\x0c\x02\x01\x04\x12\x04\x8b\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x01\x06\x12\x04\x8b\x01\x114\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x8b\
    \x0158\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\x8b\x01;<\n\x0c\n\x04\x04\
    \x0c\x02\x02\x12\x04\x8c\x01\x08:\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\
    \x8c\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\x8c\x01\x11\x18\n\
    \r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x8c\x01\x195\n\r\n\x05\x04\x0c\x02\
    \x02\x03\x12\x04\x8c\x0189\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\x8d\x01\
    \x08:\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\
    \x04\x0c\x02\x03\x05\x12\x04\x8d\x01\x11\x18\n\r\n\x05\x04\x0c\x02\x03\
    \x01\x12\x04\x8d\x01\x195\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x8d\x018\
    9\n\x0c\n\x04\x04\x0c\x02\x04\x12\x04\x8e\x01\x086\n\r\n\x05\x04\x0c\x02\
    \x04\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\
    \x8e\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\x8e\x01\x181\n\r\
    \n\x05\x04\x0c\x02\x04\x03\x12\x04\x8e\x0145\n\x0c\n\x04\x04\x0c\x02\x05\
    \x12\x04\x8f\x01\x083\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\x8f\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\x04\
    \x0c\x02\x05\x01\x12\x04\x8f\x01\x18.\n\r\n\x05\x04\x0c\x02\x05\x03\x12\
    \x04\x8f\x0112\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\x90\x01\x08+\n\r\n\
    \x05\x04\x0c\x02\x06\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x0c\x02\
    \x06\x05\x12\x04\x90\x01\x11\x18\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\
    \x90\x01\x19&\n\r\n\x05\x04\x0c\x02\x06\x03\x12\x04\x90\x01)*\n\x0c\n\
    \x04\x04\x0c\x02\x07\x12\x04\x91\x01\x08(\n\r\n\x05\x04\x0c\x02\x07\x04\
    \x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\x91\x01\
    \x11\x17\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\x91\x01\x18#\n\r\n\x05\
    \x04\x0c\x02\x07\x03\x12\x04\x91\x01&'\n\x0c\n\x04\x04\x0c\x02\x08\x12\
    \x04\x92\x01\x08(\n\r\n\x05\x04\x0c\x02\x08\x04\x12\x04\x92\x01\x08\x10\
    \n\r\n\x05\x04\x0c\x02\x08\x05\x12\x04\x92\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x08\x01\x12\x04\x92\x01\x18#\n\r\n\x05\x04\x0c\x02\x08\x03\x12\x04\
    \x92\x01&'\n\x0c\n\x02\x04\r\x12\x06\x95\x01\0\x9e\x01\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\x95\x01\x086\n\x0c\n\x04\x04\r\x02\0\x12\x04\x96\x01\
    \x08=\n\r\n\x05\x04\r\x02\0\x04\x12\x04\x96\x01\x08\x10\n\r\n\x05\x04\r\
    \x02\0\x06\x12\x04\x96\x01\x114\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x96\
    \x0158\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x96\x01;<\n\x0c\n\x04\x04\r\x02\
    \x01\x12\x04\x97\x01\x08=\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\x97\x01\
    \x08\x10\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x97\x01\x114\n\r\n\x05\x04\
    \r\x02\x01\x01\x12\x04\x97\x0158\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x97\
    \x01;<\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x98\x01\x08.\n\r\n\x05\x04\r\
    \x02\x02\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\
    \x98\x01\x11\x18\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\x98\x01\x19)\n\r\n\
    \x05\x04\r\x02\x02\x03\x12\x04\x98\x01,-\n\x0c\n\x04\x04\r\x02\x03\x12\
    \x04\x99\x01\x08.\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\x99\x01\x08\x10\n\
    \r\n\x05\x04\r\x02\x03\x05\x12\x04\x99\x01\x11\x18\n\r\n\x05\x04\r\x02\
    \x03\x01\x12\x04\x99\x01\x19)\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x99\
    \x01,-\n\x0c\n\x04\x04\r\x02\x04\x12\x04\x9a\x01\x08(\n\r\n\x05\x04\r\
    \x02\x04\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\
    \x9a\x01\x11\x17\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x9a\x01\x18#\n\r\n\
    \x05\x04\r\x02\x04\x03\x12\x04\x9a\x01&'\n\x0c\n\x04\x04\r\x02\x05\x12\
    \x04\x9b\x01\x08(\n\r\n\x05\x04\r\x02\x05\x04\x12\x04\x9b\x01\x08\x10\n\
    \r\n\x05\x04\r\x02\x05\x05\x12\x04\x9b\x01\x11\x17\n\r\n\x05\x04\r\x02\
    \x05\x01\x12\x04\x9b\x01\x18#\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\x9b\
    \x01&'\n\x0c\n\x04\x04\r\x02\x06\x12\x04\x9c\x01\x08-\n\r\n\x05\x04\r\
    \x02\x06\x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\r\x02\x06\x05\x12\x04\
    \x9c\x01\x11\x18\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\x9c\x01\x19(\n\r\n\
    \x05\x04\r\x02\x06\x03\x12\x04\x9c\x01+,\n\x0c\n\x04\x04\r\x02\x07\x12\
    \x04\x9d\x01\x08.\n\r\n\x05\x04\r\x02\x07\x04\x12\x04\x9d\x01\x08\x10\n\
    \r\n\x05\x04\r\x02\x07\x05\x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\r\x02\
    \x07\x01\x12\x04\x9d\x01\x18)\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\x9d\
    \x01,-\n\x0c\n\x02\x04\x0e\x12\x06\xa0\x01\0\xa7\x01\x01\n\x0b\n\x03\x04\
    \x0e\x01\x12\x04\xa0\x01\x086\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xa1\x01\
    \x08=\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xa1\x01\x08\x10\n\r\n\x05\x04\
    \x0e\x02\0\x06\x12\x04\xa1\x01\x114\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xa1\x0158\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xa1\x01;<\n\x0c\n\x04\x04\
    \x0e\x02\x01\x12\x04\xa2\x01\x08=\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\
    \xa2\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xa2\x01\x114\n\r\
    \n\x05\x04\x0e\x02\x01\x01\x12\x04\xa2\x0158\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xa2\x01;<\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa3\x01\x08(\
    \n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x02\x05\x12\x04\xa3\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\
    \x04\xa3\x01\x18#\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa3\x01&'\n\x0c\
    \n\x04\x04\x0e\x02\x03\x12\x04\xa4\x01\x08(\n\r\n\x05\x04\x0e\x02\x03\
    \x04\x12\x04\xa4\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xa4\
    \x01\x11\x17\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xa4\x01\x18#\n\r\n\
    \x05\x04\x0e\x02\x03\x03\x12\x04\xa4\x01&'\n\x0c\n\x04\x04\x0e\x02\x04\
    \x12\x04\xa5\x01\x08-\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xa5\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xa5\x01\x11\x18\n\r\n\x05\x04\
    \x0e\x02\x04\x01\x12\x04\xa5\x01\x19(\n\r\n\x05\x04\x0e\x02\x04\x03\x12\
    \x04\xa5\x01+,\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\xa6\x01\x08.\n\r\n\
    \x05\x04\x0e\x02\x05\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x05\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\
    \xa6\x01\x18)\n\r\n\x05\x04\x0e\x02\x05\x03\x12\x04\xa6\x01,-\n\x0c\n\
    \x02\x04\x0f\x12\x06\xa9\x01\0\xab\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\
    \x04\xa9\x01\x080\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xaa\x01\x08+\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04\xaa\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\
    \x05\x12\x04\xaa\x01\x11\x18\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xaa\x01\
    \x19&\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xaa\x01)*\n\x0c\n\x02\x04\x10\
    \x12\x06\xad\x01\0\xb6\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xad\x01\
    \x08.\n\x0e\n\x04\x04\x10\x03\0\x12\x06\xae\x01\x08\xb2\x01\t\n\r\n\x05\
    \x04\x10\x03\0\x01\x12\x04\xae\x01\x10\x1e\n\x0e\n\x06\x04\x10\x03\0\x02\
    \0\x12\x04\xaf\x01\x10(\n\x0f\n\x07\x04\x10\x03\0\x02\0\x04\x12\x04\xaf\
    \x01\x10\x18\n\x0f\n\x07\x04\x10\x03\0\x02\0\x05\x12\x04\xaf\x01\x19\x20\
    \n\x0f\n\x07\x04\x10\x03\0\x02\0\x01\x12\x04\xaf\x01!#\n\x0f\n\x07\x04\
    \x10\x03\0\x02\0\x03\x12\x04\xaf\x01&'\n\x0e\n\x06\x04\x10\x03\0\x02\x01\
    \x12\x04\xb0\x01\x102\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x04\x12\x04\xb0\
    \x01\x10\x18\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x05\x12\x04\xb0\x01\x19\
    \x1f\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x01\x12\x04\xb0\x01\x20-\n\x0f\n\
    \x07\x04\x10\x03\0\x02\x01\x03\x12\x04\xb0\x0101\n\x0e\n\x06\x04\x10\x03\
    \0\x02\x02\x12\x04\xb1\x01\x100\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x04\
    \x12\x04\xb1\x01\x10\x18\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x05\x12\x04\
    \xb1\x01\x19\x1f\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x01\x12\x04\xb1\x01\
    \x20+\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x03\x12\x04\xb1\x01./\n\x0c\n\
    \x04\x04\x10\x02\0\x12\x04\xb4\x01\x08+\n\r\n\x05\x04\x10\x02\0\x04\x12\
    \x04\xb4\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xb4\x01\x11\x18\
    \n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xb4\x01\x19&\n\r\n\x05\x04\x10\x02\
    \0\x03\x12\x04\xb4\x01)*\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xb5\x01\x08\
    ]\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\
    \x10\x02\x01\x06\x12\x04\xb5\x01\x11G\n\r\n\x05\x04\x10\x02\x01\x01\x12\
    \x04\xb5\x01HX\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xb5\x01[\\\n\x0c\n\
    \x02\x04\x11\x12\x06\xb8\x01\0\xcc\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\
    \x04\xb8\x01\x08.\n\x0e\n\x04\x04\x11\x03\0\x12\x06\xb9\x01\x08\xbe\x01\
    \t\n\r\n\x05\x04\x11\x03\0\x01\x12\x04\xb9\x01\x10\x1d\n\x0e\n\x06\x04\
    \x11\x03\0\x02\0\x12\x04\xba\x01\x10*\n\x0f\n\x07\x04\x11\x03\0\x02\0\
    \x04\x12\x04\xba\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\0\x05\x12\x04\
    \xba\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\0\x01\x12\x04\xba\x01\x20\
    %\n\x0f\n\x07\x04\x11\x03\0\x02\0\x03\x12\x04\xba\x01()\n\x0e\n\x06\x04\
    \x11\x03\0\x02\x01\x12\x04\xbb\x01\x10/\n\x0f\n\x07\x04\x11\x03\0\x02\
    \x01\x04\x12\x04\xbb\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x05\
    \x12\x04\xbb\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x01\x12\x04\
    \xbb\x01\x20*\n\x0f\n\x07\x04\x11\x03\0\x02\x01\x03\x12\x04\xbb\x01-.\n\
    \x0e\n\x06\x04\x11\x03\0\x02\x02\x12\x04\xbc\x01\x10.\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x02\x04\x12\x04\xbc\x01\x10\x18\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x02\x05\x12\x04\xbc\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\x02\x02\
    \x01\x12\x04\xbc\x01\x20)\n\x0f\n\x07\x04\x11\x03\0\x02\x02\x03\x12\x04\
    \xbc\x01,-\n\x0e\n\x06\x04\x11\x03\0\x02\x03\x12\x04\xbd\x01\x107\n\x0f\
    \n\x07\x04\x11\x03\0\x02\x03\x04\x12\x04\xbd\x01\x10\x18\n\x0f\n\x07\x04\
    \x11\x03\0\x02\x03\x05\x12\x04\xbd\x01\x19\x1f\n\x0f\n\x07\x04\x11\x03\0\
    \x02\x03\x01\x12\x04\xbd\x01\x202\n\x0f\n\x07\x04\x11\x03\0\x02\x03\x03\
    \x12\x04\xbd\x0156\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xc0\x01\x08+\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xc0\x01\x11\x18\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xc0\x01\
    \x19&\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xc0\x01)*\n\x0c\n\x04\x04\x11\
    \x02\x01\x12\x04\xc1\x01\x08%\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc1\
    \x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xc1\x01\x11\x18\n\r\n\
    \x05\x04\x11\x02\x01\x01\x12\x04\xc1\x01\x19\x20\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xc1\x01#$\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xc2\x01\
    \x08&\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xc2\x01\x08\x10\n\r\n\x05\
    \x04\x11\x02\x02\x05\x12\x04\xc2\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\
    \x01\x12\x04\xc2\x01\x18!\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xc2\x01$\
    %\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xc3\x01\x081\n\r\n\x05\x04\x11\x02\
    \x03\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\
    \xc3\x01\x11\x18\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xc3\x01\x19,\n\r\
    \n\x05\x04\x11\x02\x03\x03\x12\x04\xc3\x01/0\n\x0c\n\x04\x04\x11\x02\x04\
    \x12\x04\xc4\x01\x08-\n\r\n\x05\x04\x11\x02\x04\x04\x12\x04\xc4\x01\x08\
    \x10\n\r\n\x05\x04\x11\x02\x04\x05\x12\x04\xc4\x01\x11\x17\n\r\n\x05\x04\
    \x11\x02\x04\x01\x12\x04\xc4\x01\x18(\n\r\n\x05\x04\x11\x02\x04\x03\x12\
    \x04\xc4\x01+,\n\x0c\n\x04\x04\x11\x02\x05\x12\x04\xc5\x01\x085\n\r\n\
    \x05\x04\x11\x02\x05\x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x05\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\
    \xc5\x01\x180\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xc5\x0134\n\x0c\n\
    \x04\x04\x11\x02\x06\x12\x04\xc6\x01\x080\n\r\n\x05\x04\x11\x02\x06\x04\
    \x12\x04\xc6\x01\x08\x10\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xc6\x01\
    \x11\x17\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xc6\x01\x18+\n\r\n\x05\
    \x04\x11\x02\x06\x03\x12\x04\xc6\x01./\n\x0c\n\x04\x04\x11\x02\x07\x12\
    \x04\xc7\x01\x08#\n\r\n\x05\x04\x11\x02\x07\x04\x12\x04\xc7\x01\x08\x10\
    \n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xc7\x01\x11\x17\n\r\n\x05\x04\x11\
    \x02\x07\x01\x12\x04\xc7\x01\x18\x1e\n\r\n\x05\x04\x11\x02\x07\x03\x12\
    \x04\xc7\x01!\"\n\x0c\n\x04\x04\x11\x02\x08\x12\x04\xc8\x01\x08\\\n\r\n\
    \x05\x04\x11\x02\x08\x04\x12\x04\xc8\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x08\x06\x12\x04\xc8\x01\x11F\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xc8\
    \x01GW\n\r\n\x05\x04\x11\x02\x08\x03\x12\x04\xc8\x01Z[\n\x0c\n\x04\x04\
    \x11\x02\t\x12\x04\xc9\x01\x08[\n\r\n\x05\x04\x11\x02\t\x04\x12\x04\xc9\
    \x01\x08\x10\n\r\n\x05\x04\x11\x02\t\x06\x12\x04\xc9\x01\x11F\n\r\n\x05\
    \x04\x11\x02\t\x01\x12\x04\xc9\x01GU\n\r\n\x05\x04\x11\x02\t\x03\x12\x04\
    \xc9\x01XZ\n\x0c\n\x04\x04\x11\x02\n\x12\x04\xca\x01\x08^\n\r\n\x05\x04\
    \x11\x02\n\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x11\x02\n\x06\x12\
    \x04\xca\x01\x11F\n\r\n\x05\x04\x11\x02\n\x01\x12\x04\xca\x01GX\n\r\n\
    \x05\x04\x11\x02\n\x03\x12\x04\xca\x01[]\n\x0c\n\x04\x04\x11\x02\x0b\x12\
    \x04\xcb\x01\x08\\\n\r\n\x05\x04\x11\x02\x0b\x04\x12\x04\xcb\x01\x08\x10\
    \n\r\n\x05\x04\x11\x02\x0b\x06\x12\x04\xcb\x01\x11F\n\r\n\x05\x04\x11\
    \x02\x0b\x01\x12\x04\xcb\x01GV\n\r\n\x05\x04\x11\x02\x0b\x03\x12\x04\xcb\
    \x01Y[\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(CMsgSteamDatagramRouterPingReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverPing::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameServerAuthTicket::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverSessionRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramGameserverSessionEstablished::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramNoSession::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramDiagnostic::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramDataCenterState::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramLinkInstantaneousStats::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramLinkLifetimeStats::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionQuality::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsClientToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsRouterToClient::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsRouterToServer::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionStatsServerToRouter::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientPingSampleRequest::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientPingSampleReply::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramClientSwitchedPrimary::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_game_server_auth_ticket::ExtraField::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_data_center_state::Server::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_data_center_state::DataCenter::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_ping_sample_reply::RoutingCluster::generated_message_descriptor_data());
            messages.push(cmsg_steam_datagram_client_switched_primary::RouterQuality::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ESteamDatagramMsgID::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
