// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_gcmessages_csgo.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CGCStorePurchaseInit_LineItem)
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.cost_in_local_currency)
    pub cost_in_local_currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.purchase_type)
    pub purchase_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCStorePurchaseInit_LineItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;

    pub fn cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }

    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;

    pub fn purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }

    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CGCStorePurchaseInit_LineItem| { &m.item_def_id },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.item_def_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CGCStorePurchaseInit_LineItem| { &m.quantity },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cost_in_local_currency",
            |m: &CGCStorePurchaseInit_LineItem| { &m.cost_in_local_currency },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.cost_in_local_currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "purchase_type",
            |m: &CGCStorePurchaseInit_LineItem| { &m.purchase_type },
            |m: &mut CGCStorePurchaseInit_LineItem| { &mut m.purchase_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCStorePurchaseInit_LineItem>(
            "CGCStorePurchaseInit_LineItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCStorePurchaseInit_LineItem {
    const NAME: &'static str = "CGCStorePurchaseInit_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cost_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: CGCStorePurchaseInit_LineItem = CGCStorePurchaseInit_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            cost_in_local_currency: ::std::option::Option::None,
            purchase_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCStorePurchaseInit_LineItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCStorePurchaseInit_LineItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCStorePurchaseInit_LineItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCStorePurchaseInit_LineItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseInit)
pub struct CMsgGCStorePurchaseInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.line_items)
    pub line_items: ::std::vec::Vec<CGCStorePurchaseInit_LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMsgGCStorePurchaseInit| { &m.country },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.country },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CMsgGCStorePurchaseInit| { &m.language },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgGCStorePurchaseInit| { &m.currency },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "line_items",
            |m: &CMsgGCStorePurchaseInit| { &m.line_items },
            |m: &mut CMsgGCStorePurchaseInit| { &mut m.line_items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInit>(
            "CMsgGCStorePurchaseInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInit {
    const NAME: &'static str = "CMsgGCStorePurchaseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: CMsgGCStorePurchaseInit = CMsgGCStorePurchaseInit {
            country: ::std::option::Option::None,
            language: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseInitResponse)
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.url)
    pub url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInitResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    // optional string url = 3;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.txn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.url },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCStorePurchaseInitResponse| { &m.item_ids },
            |m: &mut CMsgGCStorePurchaseInitResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseInitResponse>(
            "CMsgGCStorePurchaseInitResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                32 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: CMsgGCStorePurchaseInitResponse = CMsgGCStorePurchaseInitResponse {
            result: ::std::option::Option::None,
            txn_id: ::std::option::Option::None,
            url: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseInitResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseInitResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseInitResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOPartyInvite)
pub struct CSOPartyInvite {
    // message fields
    // @@protoc_insertion_point(field:CSOPartyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOPartyInvite.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOPartyInvite.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOPartyInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOPartyInvite {
    fn default() -> &'a CSOPartyInvite {
        <CSOPartyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOPartyInvite {
    pub fn new() -> CSOPartyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CSOPartyInvite| { &m.group_id },
            |m: &mut CSOPartyInvite| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CSOPartyInvite| { &m.sender_id },
            |m: &mut CSOPartyInvite| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_name",
            |m: &CSOPartyInvite| { &m.sender_name },
            |m: &mut CSOPartyInvite| { &mut m.sender_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOPartyInvite>(
            "CSOPartyInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOPartyInvite {
    const NAME: &'static str = "CSOPartyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOPartyInvite {
        CSOPartyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOPartyInvite {
        static instance: CSOPartyInvite = CSOPartyInvite {
            group_id: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            sender_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOPartyInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOPartyInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOPartyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPartyInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOLobbyInvite)
pub struct CSOLobbyInvite {
    // message fields
    // @@protoc_insertion_point(field:CSOLobbyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOLobbyInvite.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOLobbyInvite.sender_name)
    pub sender_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOLobbyInvite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOLobbyInvite {
    fn default() -> &'a CSOLobbyInvite {
        <CSOLobbyInvite as ::protobuf::Message>::default_instance()
    }
}

impl CSOLobbyInvite {
    pub fn new() -> CSOLobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional string sender_name = 3;

    pub fn sender_name(&self) -> &str {
        match self.sender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sender_name(&mut self) {
        self.sender_name = ::std::option::Option::None;
    }

    pub fn has_sender_name(&self) -> bool {
        self.sender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_name(&mut self, v: ::std::string::String) {
        self.sender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender_name(&mut self) -> &mut ::std::string::String {
        if self.sender_name.is_none() {
            self.sender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender_name(&mut self) -> ::std::string::String {
        self.sender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CSOLobbyInvite| { &m.group_id },
            |m: &mut CSOLobbyInvite| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CSOLobbyInvite| { &m.sender_id },
            |m: &mut CSOLobbyInvite| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_name",
            |m: &CSOLobbyInvite| { &m.sender_name },
            |m: &mut CSOLobbyInvite| { &mut m.sender_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOLobbyInvite>(
            "CSOLobbyInvite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOLobbyInvite {
    const NAME: &'static str = "CSOLobbyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.sender_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.sender_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.sender_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOLobbyInvite {
        CSOLobbyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.sender_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOLobbyInvite {
        static instance: CSOLobbyInvite = CSOLobbyInvite {
            group_id: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            sender_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOLobbyInvite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOLobbyInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOLobbyInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOLobbyInvite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSystemBroadcast)
pub struct CMsgSystemBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgSystemBroadcast.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSystemBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSystemBroadcast {
    fn default() -> &'a CMsgSystemBroadcast {
        <CMsgSystemBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSystemBroadcast {
    pub fn new() -> CMsgSystemBroadcast {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgSystemBroadcast| { &m.message },
            |m: &mut CMsgSystemBroadcast| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSystemBroadcast>(
            "CMsgSystemBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSystemBroadcast {
    const NAME: &'static str = "CMsgSystemBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSystemBroadcast {
        CMsgSystemBroadcast::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSystemBroadcast {
        static instance: CMsgSystemBroadcast = CMsgSystemBroadcast {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSystemBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSystemBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSystemBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSystemBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgInviteToParty)
pub struct CMsgInviteToParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgInviteToParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.team_invite)
    pub team_invite: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInviteToParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToParty {
    fn default() -> &'a CMsgInviteToParty {
        <CMsgInviteToParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToParty {
    pub fn new() -> CMsgInviteToParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_invite = 3;

    pub fn team_invite(&self) -> u32 {
        self.team_invite.unwrap_or(0)
    }

    pub fn clear_team_invite(&mut self) {
        self.team_invite = ::std::option::Option::None;
    }

    pub fn has_team_invite(&self) -> bool {
        self.team_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_invite(&mut self, v: u32) {
        self.team_invite = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgInviteToParty| { &m.steam_id },
            |m: &mut CMsgInviteToParty| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgInviteToParty| { &m.client_version },
            |m: &mut CMsgInviteToParty| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_invite",
            |m: &CMsgInviteToParty| { &m.team_invite },
            |m: &mut CMsgInviteToParty| { &mut m.team_invite },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInviteToParty>(
            "CMsgInviteToParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInviteToParty {
    const NAME: &'static str = "CMsgInviteToParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.team_invite = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.team_invite {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_invite {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInviteToParty {
        CMsgInviteToParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_invite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInviteToParty {
        static instance: CMsgInviteToParty = CMsgInviteToParty {
            steam_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            team_invite: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInviteToParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInviteToParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInviteToParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInviteToParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgInvitationCreated)
pub struct CMsgInvitationCreated {
    // message fields
    // @@protoc_insertion_point(field:CMsgInvitationCreated.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInvitationCreated.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInvitationCreated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInvitationCreated {
    fn default() -> &'a CMsgInvitationCreated {
        <CMsgInvitationCreated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgInvitationCreated {
    pub fn new() -> CMsgInvitationCreated {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 2;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CMsgInvitationCreated| { &m.group_id },
            |m: &mut CMsgInvitationCreated| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgInvitationCreated| { &m.steam_id },
            |m: &mut CMsgInvitationCreated| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgInvitationCreated>(
            "CMsgInvitationCreated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgInvitationCreated {
    const NAME: &'static str = "CMsgInvitationCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInvitationCreated {
        CMsgInvitationCreated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInvitationCreated {
        static instance: CMsgInvitationCreated = CMsgInvitationCreated {
            group_id: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgInvitationCreated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgInvitationCreated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgInvitationCreated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgInvitationCreated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgPartyInviteResponse)
pub struct CMsgPartyInviteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.team_invite)
    pub team_invite: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyInviteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInviteResponse {
    fn default() -> &'a CMsgPartyInviteResponse {
        <CMsgPartyInviteResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInviteResponse {
    pub fn new() -> CMsgPartyInviteResponse {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_invite = 4;

    pub fn team_invite(&self) -> u32 {
        self.team_invite.unwrap_or(0)
    }

    pub fn clear_team_invite(&mut self) {
        self.team_invite = ::std::option::Option::None;
    }

    pub fn has_team_invite(&self) -> bool {
        self.team_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_invite(&mut self, v: u32) {
        self.team_invite = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "party_id",
            |m: &CMsgPartyInviteResponse| { &m.party_id },
            |m: &mut CMsgPartyInviteResponse| { &mut m.party_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accept",
            |m: &CMsgPartyInviteResponse| { &m.accept },
            |m: &mut CMsgPartyInviteResponse| { &mut m.accept },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgPartyInviteResponse| { &m.client_version },
            |m: &mut CMsgPartyInviteResponse| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_invite",
            |m: &CMsgPartyInviteResponse| { &m.team_invite },
            |m: &mut CMsgPartyInviteResponse| { &mut m.team_invite },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPartyInviteResponse>(
            "CMsgPartyInviteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPartyInviteResponse {
    const NAME: &'static str = "CMsgPartyInviteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.team_invite = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.team_invite {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.team_invite {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyInviteResponse {
        CMsgPartyInviteResponse::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_invite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyInviteResponse {
        static instance: CMsgPartyInviteResponse = CMsgPartyInviteResponse {
            party_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            team_invite: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPartyInviteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPartyInviteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPartyInviteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPartyInviteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgKickFromParty)
pub struct CMsgKickFromParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgKickFromParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKickFromParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKickFromParty {
    fn default() -> &'a CMsgKickFromParty {
        <CMsgKickFromParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKickFromParty {
    pub fn new() -> CMsgKickFromParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgKickFromParty| { &m.steam_id },
            |m: &mut CMsgKickFromParty| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKickFromParty>(
            "CMsgKickFromParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKickFromParty {
    const NAME: &'static str = "CMsgKickFromParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKickFromParty {
        CMsgKickFromParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKickFromParty {
        static instance: CMsgKickFromParty = CMsgKickFromParty {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKickFromParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKickFromParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKickFromParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKickFromParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgLeaveParty)
pub struct CMsgLeaveParty {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaveParty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveParty {
    fn default() -> &'a CMsgLeaveParty {
        <CMsgLeaveParty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveParty {
    pub fn new() -> CMsgLeaveParty {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLeaveParty>(
            "CMsgLeaveParty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLeaveParty {
    const NAME: &'static str = "CMsgLeaveParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaveParty {
        CMsgLeaveParty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaveParty {
        static instance: CMsgLeaveParty = CMsgLeaveParty {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLeaveParty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLeaveParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLeaveParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLeaveParty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgServerAvailable)
pub struct CMsgServerAvailable {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerAvailable>(
            "CMsgServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerAvailable {
    const NAME: &'static str = "CMsgServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: CMsgServerAvailable = CMsgServerAvailable {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgLANServerAvailable)
pub struct CMsgLANServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgLANServerAvailable.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLANServerAvailable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgLANServerAvailable| { &m.lobby_id },
            |m: &mut CMsgLANServerAvailable| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLANServerAvailable>(
            "CMsgLANServerAvailable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLANServerAvailable {
    const NAME: &'static str = "CMsgLANServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: CMsgLANServerAvailable = CMsgLANServerAvailable {
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLANServerAvailable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLANServerAvailable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLANServerAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLANServerAvailable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconGameAccountClient)
pub struct CSOEconGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.additional_backpack_slots)
    pub additional_backpack_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.bonus_xp_timestamp_refresh)
    pub bonus_xp_timestamp_refresh: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.bonus_xp_usedflags)
    pub bonus_xp_usedflags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.elevated_state)
    pub elevated_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.elevated_timestamp)
    pub elevated_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;

    pub fn additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }

    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional fixed32 bonus_xp_timestamp_refresh = 12;

    pub fn bonus_xp_timestamp_refresh(&self) -> u32 {
        self.bonus_xp_timestamp_refresh.unwrap_or(0)
    }

    pub fn clear_bonus_xp_timestamp_refresh(&mut self) {
        self.bonus_xp_timestamp_refresh = ::std::option::Option::None;
    }

    pub fn has_bonus_xp_timestamp_refresh(&self) -> bool {
        self.bonus_xp_timestamp_refresh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_xp_timestamp_refresh(&mut self, v: u32) {
        self.bonus_xp_timestamp_refresh = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_xp_usedflags = 13;

    pub fn bonus_xp_usedflags(&self) -> u32 {
        self.bonus_xp_usedflags.unwrap_or(0)
    }

    pub fn clear_bonus_xp_usedflags(&mut self) {
        self.bonus_xp_usedflags = ::std::option::Option::None;
    }

    pub fn has_bonus_xp_usedflags(&self) -> bool {
        self.bonus_xp_usedflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_xp_usedflags(&mut self, v: u32) {
        self.bonus_xp_usedflags = ::std::option::Option::Some(v);
    }

    // optional uint32 elevated_state = 14;

    pub fn elevated_state(&self) -> u32 {
        self.elevated_state.unwrap_or(0)
    }

    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: u32) {
        self.elevated_state = ::std::option::Option::Some(v);
    }

    // optional uint32 elevated_timestamp = 15;

    pub fn elevated_timestamp(&self) -> u32 {
        self.elevated_timestamp.unwrap_or(0)
    }

    pub fn clear_elevated_timestamp(&mut self) {
        self.elevated_timestamp = ::std::option::Option::None;
    }

    pub fn has_elevated_timestamp(&self) -> bool {
        self.elevated_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_timestamp(&mut self, v: u32) {
        self.elevated_timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_backpack_slots",
            |m: &CSOEconGameAccountClient| { &m.additional_backpack_slots },
            |m: &mut CSOEconGameAccountClient| { &mut m.additional_backpack_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_xp_timestamp_refresh",
            |m: &CSOEconGameAccountClient| { &m.bonus_xp_timestamp_refresh },
            |m: &mut CSOEconGameAccountClient| { &mut m.bonus_xp_timestamp_refresh },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_xp_usedflags",
            |m: &CSOEconGameAccountClient| { &m.bonus_xp_usedflags },
            |m: &mut CSOEconGameAccountClient| { &mut m.bonus_xp_usedflags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevated_state",
            |m: &CSOEconGameAccountClient| { &m.elevated_state },
            |m: &mut CSOEconGameAccountClient| { &mut m.elevated_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevated_timestamp",
            |m: &CSOEconGameAccountClient| { &m.elevated_timestamp },
            |m: &mut CSOEconGameAccountClient| { &mut m.elevated_timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconGameAccountClient>(
            "CSOEconGameAccountClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconGameAccountClient {
    const NAME: &'static str = "CSOEconGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_backpack_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                101 => {
                    self.bonus_xp_timestamp_refresh = ::std::option::Option::Some(is.read_fixed32()?);
                },
                104 => {
                    self.bonus_xp_usedflags = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.elevated_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.elevated_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.bonus_xp_timestamp_refresh {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_xp_usedflags {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.elevated_state {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.elevated_timestamp {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.bonus_xp_timestamp_refresh {
            os.write_fixed32(12, v)?;
        }
        if let Some(v) = self.bonus_xp_usedflags {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.elevated_timestamp {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.bonus_xp_timestamp_refresh = ::std::option::Option::None;
        self.bonus_xp_usedflags = ::std::option::Option::None;
        self.elevated_state = ::std::option::Option::None;
        self.elevated_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: CSOEconGameAccountClient = CSOEconGameAccountClient {
            additional_backpack_slots: ::std::option::Option::None,
            bonus_xp_timestamp_refresh: ::std::option::Option::None,
            bonus_xp_usedflags: ::std::option::Option::None,
            elevated_state: ::std::option::Option::None,
            elevated_timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconGameAccountClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconGameAccountClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconGameAccountClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconGameAccountClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemCriteriaCondition)
pub struct CSOItemCriteriaCondition {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.op)
    pub op: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.field)
    pub field: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.required)
    pub required: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.float_value)
    pub float_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSOItemCriteriaCondition.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteriaCondition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteriaCondition {
    fn default() -> &'a CSOItemCriteriaCondition {
        <CSOItemCriteriaCondition as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteriaCondition {
    pub fn new() -> CSOItemCriteriaCondition {
        ::std::default::Default::default()
    }

    // optional int32 op = 1;

    pub fn op(&self) -> i32 {
        self.op.unwrap_or(0)
    }

    pub fn clear_op(&mut self) {
        self.op = ::std::option::Option::None;
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: i32) {
        self.op = ::std::option::Option::Some(v);
    }

    // optional string field = 2;

    pub fn field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_field(&mut self) {
        self.field = ::std::option::Option::None;
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field = ::std::option::Option::Some(::std::string::String::new());
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool required = 3;

    pub fn required(&self) -> bool {
        self.required.unwrap_or(false)
    }

    pub fn clear_required(&mut self) {
        self.required = ::std::option::Option::None;
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: bool) {
        self.required = ::std::option::Option::Some(v);
    }

    // optional float float_value = 4;

    pub fn float_value(&self) -> f32 {
        self.float_value.unwrap_or(0.)
    }

    pub fn clear_float_value(&mut self) {
        self.float_value = ::std::option::Option::None;
    }

    pub fn has_float_value(&self) -> bool {
        self.float_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_value(&mut self, v: f32) {
        self.float_value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 5;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "op",
            |m: &CSOItemCriteriaCondition| { &m.op },
            |m: &mut CSOItemCriteriaCondition| { &mut m.op },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field",
            |m: &CSOItemCriteriaCondition| { &m.field },
            |m: &mut CSOItemCriteriaCondition| { &mut m.field },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required",
            |m: &CSOItemCriteriaCondition| { &m.required },
            |m: &mut CSOItemCriteriaCondition| { &mut m.required },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "float_value",
            |m: &CSOItemCriteriaCondition| { &m.float_value },
            |m: &mut CSOItemCriteriaCondition| { &mut m.float_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &CSOItemCriteriaCondition| { &m.string_value },
            |m: &mut CSOItemCriteriaCondition| { &mut m.string_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemCriteriaCondition>(
            "CSOItemCriteriaCondition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemCriteriaCondition {
    const NAME: &'static str = "CSOItemCriteriaCondition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.field = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.required = ::std::option::Option::Some(is.read_bool()?);
                },
                37 => {
                    self.float_value = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.op {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.required {
            my_size += 1 + 1;
        }
        if let Some(v) = self.float_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.op {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.field.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.required {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.float_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteriaCondition {
        CSOItemCriteriaCondition::new()
    }

    fn clear(&mut self) {
        self.op = ::std::option::Option::None;
        self.field = ::std::option::Option::None;
        self.required = ::std::option::Option::None;
        self.float_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteriaCondition {
        static instance: CSOItemCriteriaCondition = CSOItemCriteriaCondition {
            op: ::std::option::Option::None,
            field: ::std::option::Option::None,
            required: ::std::option::Option::None,
            float_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemCriteriaCondition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemCriteriaCondition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemCriteriaCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteriaCondition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemCriteria)
pub struct CSOItemCriteria {
    // message fields
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level)
    pub item_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality)
    pub item_quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_level_set)
    pub item_level_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_quality_set)
    pub item_quality_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_inventory)
    pub initial_inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.initial_quantity)
    pub initial_quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.ignore_enabled_flag)
    pub ignore_enabled_flag: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.conditions)
    pub conditions: ::std::vec::Vec<CSOItemCriteriaCondition>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_rarity)
    pub item_rarity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemCriteria.item_rarity_set)
    pub item_rarity_set: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemCriteria.recent_only)
    pub recent_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemCriteria.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemCriteria {
    fn default() -> &'a CSOItemCriteria {
        <CSOItemCriteria as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemCriteria {
    pub fn new() -> CSOItemCriteria {
        ::std::default::Default::default()
    }

    // optional uint32 item_level = 1;

    pub fn item_level(&self) -> u32 {
        self.item_level.unwrap_or(0)
    }

    pub fn clear_item_level(&mut self) {
        self.item_level = ::std::option::Option::None;
    }

    pub fn has_item_level(&self) -> bool {
        self.item_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level(&mut self, v: u32) {
        self.item_level = ::std::option::Option::Some(v);
    }

    // optional int32 item_quality = 2;

    pub fn item_quality(&self) -> i32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: i32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional bool item_level_set = 3;

    pub fn item_level_set(&self) -> bool {
        self.item_level_set.unwrap_or(false)
    }

    pub fn clear_item_level_set(&mut self) {
        self.item_level_set = ::std::option::Option::None;
    }

    pub fn has_item_level_set(&self) -> bool {
        self.item_level_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_level_set(&mut self, v: bool) {
        self.item_level_set = ::std::option::Option::Some(v);
    }

    // optional bool item_quality_set = 4;

    pub fn item_quality_set(&self) -> bool {
        self.item_quality_set.unwrap_or(false)
    }

    pub fn clear_item_quality_set(&mut self) {
        self.item_quality_set = ::std::option::Option::None;
    }

    pub fn has_item_quality_set(&self) -> bool {
        self.item_quality_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality_set(&mut self, v: bool) {
        self.item_quality_set = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_inventory = 5;

    pub fn initial_inventory(&self) -> u32 {
        self.initial_inventory.unwrap_or(0)
    }

    pub fn clear_initial_inventory(&mut self) {
        self.initial_inventory = ::std::option::Option::None;
    }

    pub fn has_initial_inventory(&self) -> bool {
        self.initial_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_inventory(&mut self, v: u32) {
        self.initial_inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_quantity = 6;

    pub fn initial_quantity(&self) -> u32 {
        self.initial_quantity.unwrap_or(0)
    }

    pub fn clear_initial_quantity(&mut self) {
        self.initial_quantity = ::std::option::Option::None;
    }

    pub fn has_initial_quantity(&self) -> bool {
        self.initial_quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_quantity(&mut self, v: u32) {
        self.initial_quantity = ::std::option::Option::Some(v);
    }

    // optional bool ignore_enabled_flag = 8;

    pub fn ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.unwrap_or(false)
    }

    pub fn clear_ignore_enabled_flag(&mut self) {
        self.ignore_enabled_flag = ::std::option::Option::None;
    }

    pub fn has_ignore_enabled_flag(&self) -> bool {
        self.ignore_enabled_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_enabled_flag(&mut self, v: bool) {
        self.ignore_enabled_flag = ::std::option::Option::Some(v);
    }

    // optional int32 item_rarity = 10;

    pub fn item_rarity(&self) -> i32 {
        self.item_rarity.unwrap_or(0)
    }

    pub fn clear_item_rarity(&mut self) {
        self.item_rarity = ::std::option::Option::None;
    }

    pub fn has_item_rarity(&self) -> bool {
        self.item_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity(&mut self, v: i32) {
        self.item_rarity = ::std::option::Option::Some(v);
    }

    // optional bool item_rarity_set = 11;

    pub fn item_rarity_set(&self) -> bool {
        self.item_rarity_set.unwrap_or(false)
    }

    pub fn clear_item_rarity_set(&mut self) {
        self.item_rarity_set = ::std::option::Option::None;
    }

    pub fn has_item_rarity_set(&self) -> bool {
        self.item_rarity_set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_rarity_set(&mut self, v: bool) {
        self.item_rarity_set = ::std::option::Option::Some(v);
    }

    // optional bool recent_only = 12;

    pub fn recent_only(&self) -> bool {
        self.recent_only.unwrap_or(false)
    }

    pub fn clear_recent_only(&mut self) {
        self.recent_only = ::std::option::Option::None;
    }

    pub fn has_recent_only(&self) -> bool {
        self.recent_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recent_only(&mut self, v: bool) {
        self.recent_only = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level",
            |m: &CSOItemCriteria| { &m.item_level },
            |m: &mut CSOItemCriteria| { &mut m.item_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality",
            |m: &CSOItemCriteria| { &m.item_quality },
            |m: &mut CSOItemCriteria| { &mut m.item_quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_level_set",
            |m: &CSOItemCriteria| { &m.item_level_set },
            |m: &mut CSOItemCriteria| { &mut m.item_level_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_quality_set",
            |m: &CSOItemCriteria| { &m.item_quality_set },
            |m: &mut CSOItemCriteria| { &mut m.item_quality_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_inventory",
            |m: &CSOItemCriteria| { &m.initial_inventory },
            |m: &mut CSOItemCriteria| { &mut m.initial_inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_quantity",
            |m: &CSOItemCriteria| { &m.initial_quantity },
            |m: &mut CSOItemCriteria| { &mut m.initial_quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_enabled_flag",
            |m: &CSOItemCriteria| { &m.ignore_enabled_flag },
            |m: &mut CSOItemCriteria| { &mut m.ignore_enabled_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "conditions",
            |m: &CSOItemCriteria| { &m.conditions },
            |m: &mut CSOItemCriteria| { &mut m.conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_rarity",
            |m: &CSOItemCriteria| { &m.item_rarity },
            |m: &mut CSOItemCriteria| { &mut m.item_rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_rarity_set",
            |m: &CSOItemCriteria| { &m.item_rarity_set },
            |m: &mut CSOItemCriteria| { &mut m.item_rarity_set },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recent_only",
            |m: &CSOItemCriteria| { &m.recent_only },
            |m: &mut CSOItemCriteria| { &mut m.recent_only },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemCriteria>(
            "CSOItemCriteria",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemCriteria {
    const NAME: &'static str = "CSOItemCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_level_set = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.item_quality_set = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.initial_inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.initial_quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.ignore_enabled_flag = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.conditions.push(is.read_message()?);
                },
                80 => {
                    self.item_rarity = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.item_rarity_set = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.recent_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_level {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_level_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.item_quality_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.initial_inventory {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.initial_quantity {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ignore_enabled_flag {
            my_size += 1 + 1;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.item_rarity {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.item_rarity_set {
            my_size += 1 + 1;
        }
        if let Some(v) = self.recent_only {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_level_set {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.item_quality_set {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.initial_inventory {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.initial_quantity {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ignore_enabled_flag {
            os.write_bool(8, v)?;
        }
        for v in &self.conditions {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.item_rarity {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.item_rarity_set {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.recent_only {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemCriteria {
        CSOItemCriteria::new()
    }

    fn clear(&mut self) {
        self.item_level = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.item_level_set = ::std::option::Option::None;
        self.item_quality_set = ::std::option::Option::None;
        self.initial_inventory = ::std::option::Option::None;
        self.initial_quantity = ::std::option::Option::None;
        self.ignore_enabled_flag = ::std::option::Option::None;
        self.conditions.clear();
        self.item_rarity = ::std::option::Option::None;
        self.item_rarity_set = ::std::option::Option::None;
        self.recent_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemCriteria {
        static instance: CSOItemCriteria = CSOItemCriteria {
            item_level: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            item_level_set: ::std::option::Option::None,
            item_quality_set: ::std::option::Option::None,
            initial_inventory: ::std::option::Option::None,
            initial_quantity: ::std::option::Option::None,
            ignore_enabled_flag: ::std::option::Option::None,
            conditions: ::std::vec::Vec::new(),
            item_rarity: ::std::option::Option::None,
            item_rarity_set: ::std::option::Option::None,
            recent_only: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemCriteria {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemCriteria").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemCriteria {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemCriteria {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOItemRecipe)
pub struct CSOItemRecipe {
    // message fields
    // @@protoc_insertion_point(field:CSOItemRecipe.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.n_a)
    pub n_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_inputs)
    pub desc_inputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.desc_outputs)
    pub desc_outputs: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_a)
    pub di_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_b)
    pub di_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.di_c)
    pub di_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_a)
    pub do_a: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_b)
    pub do_b: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.do_c)
    pub do_c: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_class)
    pub requires_all_same_class: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.requires_all_same_slot)
    pub requires_all_same_slot: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOItemRecipe.class_usage_for_output)
    pub class_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.slot_usage_for_output)
    pub slot_usage_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.set_for_output)
    pub set_for_output: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_items_criteria)
    pub input_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.output_items_criteria)
    pub output_items_criteria: ::std::vec::Vec<CSOItemCriteria>,
    // @@protoc_insertion_point(field:CSOItemRecipe.input_item_dupe_counts)
    pub input_item_dupe_counts: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOItemRecipe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOItemRecipe {
    fn default() -> &'a CSOItemRecipe {
        <CSOItemRecipe as ::protobuf::Message>::default_instance()
    }
}

impl CSOItemRecipe {
    pub fn new() -> CSOItemRecipe {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string n_a = 3;

    pub fn n_a(&self) -> &str {
        match self.n_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_n_a(&mut self) {
        self.n_a = ::std::option::Option::None;
    }

    pub fn has_n_a(&self) -> bool {
        self.n_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n_a(&mut self, v: ::std::string::String) {
        self.n_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n_a(&mut self) -> &mut ::std::string::String {
        if self.n_a.is_none() {
            self.n_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.n_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_n_a(&mut self) -> ::std::string::String {
        self.n_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_inputs = 4;

    pub fn desc_inputs(&self) -> &str {
        match self.desc_inputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_inputs(&mut self) {
        self.desc_inputs = ::std::option::Option::None;
    }

    pub fn has_desc_inputs(&self) -> bool {
        self.desc_inputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_inputs(&mut self, v: ::std::string::String) {
        self.desc_inputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_inputs(&mut self) -> &mut ::std::string::String {
        if self.desc_inputs.is_none() {
            self.desc_inputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_inputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_inputs(&mut self) -> ::std::string::String {
        self.desc_inputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc_outputs = 5;

    pub fn desc_outputs(&self) -> &str {
        match self.desc_outputs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc_outputs(&mut self) {
        self.desc_outputs = ::std::option::Option::None;
    }

    pub fn has_desc_outputs(&self) -> bool {
        self.desc_outputs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc_outputs(&mut self, v: ::std::string::String) {
        self.desc_outputs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc_outputs(&mut self) -> &mut ::std::string::String {
        if self.desc_outputs.is_none() {
            self.desc_outputs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc_outputs.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc_outputs(&mut self) -> ::std::string::String {
        self.desc_outputs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_a = 6;

    pub fn di_a(&self) -> &str {
        match self.di_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_a(&mut self) {
        self.di_a = ::std::option::Option::None;
    }

    pub fn has_di_a(&self) -> bool {
        self.di_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_a(&mut self, v: ::std::string::String) {
        self.di_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_a(&mut self) -> &mut ::std::string::String {
        if self.di_a.is_none() {
            self.di_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_a(&mut self) -> ::std::string::String {
        self.di_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_b = 7;

    pub fn di_b(&self) -> &str {
        match self.di_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_b(&mut self) {
        self.di_b = ::std::option::Option::None;
    }

    pub fn has_di_b(&self) -> bool {
        self.di_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_b(&mut self, v: ::std::string::String) {
        self.di_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_b(&mut self) -> &mut ::std::string::String {
        if self.di_b.is_none() {
            self.di_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_b(&mut self) -> ::std::string::String {
        self.di_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string di_c = 8;

    pub fn di_c(&self) -> &str {
        match self.di_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_di_c(&mut self) {
        self.di_c = ::std::option::Option::None;
    }

    pub fn has_di_c(&self) -> bool {
        self.di_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_di_c(&mut self, v: ::std::string::String) {
        self.di_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_di_c(&mut self) -> &mut ::std::string::String {
        if self.di_c.is_none() {
            self.di_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.di_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_di_c(&mut self) -> ::std::string::String {
        self.di_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_a = 9;

    pub fn do_a(&self) -> &str {
        match self.do_a.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_a(&mut self) {
        self.do_a = ::std::option::Option::None;
    }

    pub fn has_do_a(&self) -> bool {
        self.do_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_a(&mut self, v: ::std::string::String) {
        self.do_a = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_a(&mut self) -> &mut ::std::string::String {
        if self.do_a.is_none() {
            self.do_a = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_a.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_a(&mut self) -> ::std::string::String {
        self.do_a.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_b = 10;

    pub fn do_b(&self) -> &str {
        match self.do_b.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_b(&mut self) {
        self.do_b = ::std::option::Option::None;
    }

    pub fn has_do_b(&self) -> bool {
        self.do_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_b(&mut self, v: ::std::string::String) {
        self.do_b = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_b(&mut self) -> &mut ::std::string::String {
        if self.do_b.is_none() {
            self.do_b = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_b.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_b(&mut self) -> ::std::string::String {
        self.do_b.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string do_c = 11;

    pub fn do_c(&self) -> &str {
        match self.do_c.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_do_c(&mut self) {
        self.do_c = ::std::option::Option::None;
    }

    pub fn has_do_c(&self) -> bool {
        self.do_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_c(&mut self, v: ::std::string::String) {
        self.do_c = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_do_c(&mut self) -> &mut ::std::string::String {
        if self.do_c.is_none() {
            self.do_c = ::std::option::Option::Some(::std::string::String::new());
        }
        self.do_c.as_mut().unwrap()
    }

    // Take field
    pub fn take_do_c(&mut self) -> ::std::string::String {
        self.do_c.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool requires_all_same_class = 12;

    pub fn requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.unwrap_or(false)
    }

    pub fn clear_requires_all_same_class(&mut self) {
        self.requires_all_same_class = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_class(&self) -> bool {
        self.requires_all_same_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_class(&mut self, v: bool) {
        self.requires_all_same_class = ::std::option::Option::Some(v);
    }

    // optional bool requires_all_same_slot = 13;

    pub fn requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.unwrap_or(false)
    }

    pub fn clear_requires_all_same_slot(&mut self) {
        self.requires_all_same_slot = ::std::option::Option::None;
    }

    pub fn has_requires_all_same_slot(&self) -> bool {
        self.requires_all_same_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_all_same_slot(&mut self, v: bool) {
        self.requires_all_same_slot = ::std::option::Option::Some(v);
    }

    // optional int32 class_usage_for_output = 14;

    pub fn class_usage_for_output(&self) -> i32 {
        self.class_usage_for_output.unwrap_or(0)
    }

    pub fn clear_class_usage_for_output(&mut self) {
        self.class_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_class_usage_for_output(&self) -> bool {
        self.class_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_usage_for_output(&mut self, v: i32) {
        self.class_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 slot_usage_for_output = 15;

    pub fn slot_usage_for_output(&self) -> i32 {
        self.slot_usage_for_output.unwrap_or(0)
    }

    pub fn clear_slot_usage_for_output(&mut self) {
        self.slot_usage_for_output = ::std::option::Option::None;
    }

    pub fn has_slot_usage_for_output(&self) -> bool {
        self.slot_usage_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_usage_for_output(&mut self, v: i32) {
        self.slot_usage_for_output = ::std::option::Option::Some(v);
    }

    // optional int32 set_for_output = 16;

    pub fn set_for_output(&self) -> i32 {
        self.set_for_output.unwrap_or(0)
    }

    pub fn clear_set_for_output(&mut self) {
        self.set_for_output = ::std::option::Option::None;
    }

    pub fn has_set_for_output(&self) -> bool {
        self.set_for_output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_for_output(&mut self, v: i32) {
        self.set_for_output = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOItemRecipe| { &m.def_index },
            |m: &mut CSOItemRecipe| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSOItemRecipe| { &m.name },
            |m: &mut CSOItemRecipe| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "n_a",
            |m: &CSOItemRecipe| { &m.n_a },
            |m: &mut CSOItemRecipe| { &mut m.n_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc_inputs",
            |m: &CSOItemRecipe| { &m.desc_inputs },
            |m: &mut CSOItemRecipe| { &mut m.desc_inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc_outputs",
            |m: &CSOItemRecipe| { &m.desc_outputs },
            |m: &mut CSOItemRecipe| { &mut m.desc_outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_a",
            |m: &CSOItemRecipe| { &m.di_a },
            |m: &mut CSOItemRecipe| { &mut m.di_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_b",
            |m: &CSOItemRecipe| { &m.di_b },
            |m: &mut CSOItemRecipe| { &mut m.di_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "di_c",
            |m: &CSOItemRecipe| { &m.di_c },
            |m: &mut CSOItemRecipe| { &mut m.di_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_a",
            |m: &CSOItemRecipe| { &m.do_a },
            |m: &mut CSOItemRecipe| { &mut m.do_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_b",
            |m: &CSOItemRecipe| { &m.do_b },
            |m: &mut CSOItemRecipe| { &mut m.do_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "do_c",
            |m: &CSOItemRecipe| { &m.do_c },
            |m: &mut CSOItemRecipe| { &mut m.do_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_all_same_class",
            |m: &CSOItemRecipe| { &m.requires_all_same_class },
            |m: &mut CSOItemRecipe| { &mut m.requires_all_same_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_all_same_slot",
            |m: &CSOItemRecipe| { &m.requires_all_same_slot },
            |m: &mut CSOItemRecipe| { &mut m.requires_all_same_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_usage_for_output",
            |m: &CSOItemRecipe| { &m.class_usage_for_output },
            |m: &mut CSOItemRecipe| { &mut m.class_usage_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_usage_for_output",
            |m: &CSOItemRecipe| { &m.slot_usage_for_output },
            |m: &mut CSOItemRecipe| { &mut m.slot_usage_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "set_for_output",
            |m: &CSOItemRecipe| { &m.set_for_output },
            |m: &mut CSOItemRecipe| { &mut m.set_for_output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_items_criteria",
            |m: &CSOItemRecipe| { &m.input_items_criteria },
            |m: &mut CSOItemRecipe| { &mut m.input_items_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output_items_criteria",
            |m: &CSOItemRecipe| { &m.output_items_criteria },
            |m: &mut CSOItemRecipe| { &mut m.output_items_criteria },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input_item_dupe_counts",
            |m: &CSOItemRecipe| { &m.input_item_dupe_counts },
            |m: &mut CSOItemRecipe| { &mut m.input_item_dupe_counts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOItemRecipe>(
            "CSOItemRecipe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOItemRecipe {
    const NAME: &'static str = "CSOItemRecipe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.n_a = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.desc_inputs = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.desc_outputs = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.di_a = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.di_b = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.di_c = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.do_a = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.do_b = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.do_c = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.requires_all_same_class = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.requires_all_same_slot = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.class_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.slot_usage_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.set_for_output = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.input_items_criteria.push(is.read_message()?);
                },
                170 => {
                    self.output_items_criteria.push(is.read_message()?);
                },
                178 => {
                    is.read_repeated_packed_uint32_into(&mut self.input_item_dupe_counts)?;
                },
                176 => {
                    self.input_item_dupe_counts.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.n_a.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.di_a.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.di_b.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.di_c.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.do_a.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.do_b.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.do_c.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.requires_all_same_class {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_all_same_slot {
            my_size += 1 + 1;
        }
        if let Some(v) = self.class_usage_for_output {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.slot_usage_for_output {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.set_for_output {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        for value in &self.input_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output_items_criteria {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.input_item_dupe_counts {
            my_size += ::protobuf::rt::uint32_size(22, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.n_a.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.desc_inputs.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.desc_outputs.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.di_a.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.di_b.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.di_c.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.do_a.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.do_b.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.do_c.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.requires_all_same_class {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.requires_all_same_slot {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.class_usage_for_output {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.slot_usage_for_output {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.set_for_output {
            os.write_int32(16, v)?;
        }
        for v in &self.input_items_criteria {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.output_items_criteria {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.input_item_dupe_counts {
            os.write_uint32(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOItemRecipe {
        CSOItemRecipe::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.n_a = ::std::option::Option::None;
        self.desc_inputs = ::std::option::Option::None;
        self.desc_outputs = ::std::option::Option::None;
        self.di_a = ::std::option::Option::None;
        self.di_b = ::std::option::Option::None;
        self.di_c = ::std::option::Option::None;
        self.do_a = ::std::option::Option::None;
        self.do_b = ::std::option::Option::None;
        self.do_c = ::std::option::Option::None;
        self.requires_all_same_class = ::std::option::Option::None;
        self.requires_all_same_slot = ::std::option::Option::None;
        self.class_usage_for_output = ::std::option::Option::None;
        self.slot_usage_for_output = ::std::option::Option::None;
        self.set_for_output = ::std::option::Option::None;
        self.input_items_criteria.clear();
        self.output_items_criteria.clear();
        self.input_item_dupe_counts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOItemRecipe {
        static instance: CSOItemRecipe = CSOItemRecipe {
            def_index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            n_a: ::std::option::Option::None,
            desc_inputs: ::std::option::Option::None,
            desc_outputs: ::std::option::Option::None,
            di_a: ::std::option::Option::None,
            di_b: ::std::option::Option::None,
            di_c: ::std::option::Option::None,
            do_a: ::std::option::Option::None,
            do_b: ::std::option::Option::None,
            do_c: ::std::option::Option::None,
            requires_all_same_class: ::std::option::Option::None,
            requires_all_same_slot: ::std::option::Option::None,
            class_usage_for_output: ::std::option::Option::None,
            slot_usage_for_output: ::std::option::Option::None,
            set_for_output: ::std::option::Option::None,
            input_items_criteria: ::std::vec::Vec::new(),
            output_items_criteria: ::std::vec::Vec::new(),
            input_item_dupe_counts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOItemRecipe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOItemRecipe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOItemRecipe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOItemRecipe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgDevNewItemRequest)
pub struct CMsgDevNewItemRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.receiver)
    pub receiver: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDevNewItemRequest.criteria)
    pub criteria: ::protobuf::MessageField<CSOItemCriteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevNewItemRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevNewItemRequest {
    fn default() -> &'a CMsgDevNewItemRequest {
        <CMsgDevNewItemRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgDevNewItemRequest {
    pub fn new() -> CMsgDevNewItemRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 receiver = 1;

    pub fn receiver(&self) -> u64 {
        self.receiver.unwrap_or(0)
    }

    pub fn clear_receiver(&mut self) {
        self.receiver = ::std::option::Option::None;
    }

    pub fn has_receiver(&self) -> bool {
        self.receiver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver(&mut self, v: u64) {
        self.receiver = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver",
            |m: &CMsgDevNewItemRequest| { &m.receiver },
            |m: &mut CMsgDevNewItemRequest| { &mut m.receiver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSOItemCriteria>(
            "criteria",
            |m: &CMsgDevNewItemRequest| { &m.criteria },
            |m: &mut CMsgDevNewItemRequest| { &mut m.criteria },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgDevNewItemRequest>(
            "CMsgDevNewItemRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgDevNewItemRequest {
    const NAME: &'static str = "CMsgDevNewItemRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.receiver = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.criteria)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver {
            my_size += 1 + 8;
        }
        if let Some(v) = self.criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.receiver {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.criteria.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevNewItemRequest {
        CMsgDevNewItemRequest::new()
    }

    fn clear(&mut self) {
        self.receiver = ::std::option::Option::None;
        self.criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevNewItemRequest {
        static instance: CMsgDevNewItemRequest = CMsgDevNewItemRequest {
            receiver: ::std::option::Option::None,
            criteria: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgDevNewItemRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgDevNewItemRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgDevNewItemRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgDevNewItemRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgIncrementKillCountAttribute)
pub struct CMsgIncrementKillCountAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.victim_account_id)
    pub victim_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgIncrementKillCountAttribute.amount)
    pub amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIncrementKillCountAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIncrementKillCountAttribute {
    fn default() -> &'a CMsgIncrementKillCountAttribute {
        <CMsgIncrementKillCountAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIncrementKillCountAttribute {
    pub fn new() -> CMsgIncrementKillCountAttribute {
        ::std::default::Default::default()
    }

    // optional fixed32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 victim_account_id = 2;

    pub fn victim_account_id(&self) -> u32 {
        self.victim_account_id.unwrap_or(0)
    }

    pub fn clear_victim_account_id(&mut self) {
        self.victim_account_id = ::std::option::Option::None;
    }

    pub fn has_victim_account_id(&self) -> bool {
        self.victim_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_account_id(&mut self, v: u32) {
        self.victim_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 5;

    pub fn amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_account_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.killer_account_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.killer_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_account_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.victim_account_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.victim_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgIncrementKillCountAttribute| { &m.item_id },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CMsgIncrementKillCountAttribute| { &m.event_type },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CMsgIncrementKillCountAttribute| { &m.amount },
            |m: &mut CMsgIncrementKillCountAttribute| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIncrementKillCountAttribute>(
            "CMsgIncrementKillCountAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIncrementKillCountAttribute {
    const NAME: &'static str = "CMsgIncrementKillCountAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.victim_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.victim_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.victim_account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIncrementKillCountAttribute {
        CMsgIncrementKillCountAttribute::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.victim_account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIncrementKillCountAttribute {
        static instance: CMsgIncrementKillCountAttribute = CMsgIncrementKillCountAttribute {
            killer_account_id: ::std::option::Option::None,
            victim_account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIncrementKillCountAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIncrementKillCountAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIncrementKillCountAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIncrementKillCountAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplySticker)
pub struct CMsgApplySticker {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplySticker.sticker_item_id)
    pub sticker_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplySticker.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplySticker.sticker_slot)
    pub sticker_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgApplySticker.baseitem_defidx)
    pub baseitem_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgApplySticker.sticker_wear)
    pub sticker_wear: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplySticker.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplySticker {
    fn default() -> &'a CMsgApplySticker {
        <CMsgApplySticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplySticker {
    pub fn new() -> CMsgApplySticker {
        ::std::default::Default::default()
    }

    // optional uint64 sticker_item_id = 1;

    pub fn sticker_item_id(&self) -> u64 {
        self.sticker_item_id.unwrap_or(0)
    }

    pub fn clear_sticker_item_id(&mut self) {
        self.sticker_item_id = ::std::option::Option::None;
    }

    pub fn has_sticker_item_id(&self) -> bool {
        self.sticker_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_item_id(&mut self, v: u64) {
        self.sticker_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_slot = 3;

    pub fn sticker_slot(&self) -> u32 {
        self.sticker_slot.unwrap_or(0)
    }

    pub fn clear_sticker_slot(&mut self) {
        self.sticker_slot = ::std::option::Option::None;
    }

    pub fn has_sticker_slot(&self) -> bool {
        self.sticker_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_slot(&mut self, v: u32) {
        self.sticker_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 baseitem_defidx = 4;

    pub fn baseitem_defidx(&self) -> u32 {
        self.baseitem_defidx.unwrap_or(0)
    }

    pub fn clear_baseitem_defidx(&mut self) {
        self.baseitem_defidx = ::std::option::Option::None;
    }

    pub fn has_baseitem_defidx(&self) -> bool {
        self.baseitem_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseitem_defidx(&mut self, v: u32) {
        self.baseitem_defidx = ::std::option::Option::Some(v);
    }

    // optional float sticker_wear = 5;

    pub fn sticker_wear(&self) -> f32 {
        self.sticker_wear.unwrap_or(0.)
    }

    pub fn clear_sticker_wear(&mut self) {
        self.sticker_wear = ::std::option::Option::None;
    }

    pub fn has_sticker_wear(&self) -> bool {
        self.sticker_wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_wear(&mut self, v: f32) {
        self.sticker_wear = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sticker_item_id",
            |m: &CMsgApplySticker| { &m.sticker_item_id },
            |m: &mut CMsgApplySticker| { &mut m.sticker_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplySticker| { &m.item_item_id },
            |m: &mut CMsgApplySticker| { &mut m.item_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sticker_slot",
            |m: &CMsgApplySticker| { &m.sticker_slot },
            |m: &mut CMsgApplySticker| { &mut m.sticker_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseitem_defidx",
            |m: &CMsgApplySticker| { &m.baseitem_defidx },
            |m: &mut CMsgApplySticker| { &mut m.baseitem_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sticker_wear",
            |m: &CMsgApplySticker| { &m.sticker_wear },
            |m: &mut CMsgApplySticker| { &mut m.sticker_wear },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplySticker>(
            "CMsgApplySticker",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplySticker {
    const NAME: &'static str = "CMsgApplySticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sticker_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.sticker_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.baseitem_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.sticker_wear = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sticker_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.sticker_slot {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.baseitem_defidx {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sticker_wear {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sticker_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.sticker_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.baseitem_defidx {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sticker_wear {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplySticker {
        CMsgApplySticker::new()
    }

    fn clear(&mut self) {
        self.sticker_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.sticker_slot = ::std::option::Option::None;
        self.baseitem_defidx = ::std::option::Option::None;
        self.sticker_wear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplySticker {
        static instance: CMsgApplySticker = CMsgApplySticker {
            sticker_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            sticker_slot: ::std::option::Option::None,
            baseitem_defidx: ::std::option::Option::None,
            sticker_wear: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplySticker {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplySticker").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplySticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplySticker {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgModifyItemAttribute)
pub struct CMsgModifyItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgModifyItemAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgModifyItemAttribute.attr_defidx)
    pub attr_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgModifyItemAttribute.attr_value)
    pub attr_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgModifyItemAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgModifyItemAttribute {
    fn default() -> &'a CMsgModifyItemAttribute {
        <CMsgModifyItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CMsgModifyItemAttribute {
    pub fn new() -> CMsgModifyItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_defidx = 2;

    pub fn attr_defidx(&self) -> u32 {
        self.attr_defidx.unwrap_or(0)
    }

    pub fn clear_attr_defidx(&mut self) {
        self.attr_defidx = ::std::option::Option::None;
    }

    pub fn has_attr_defidx(&self) -> bool {
        self.attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_defidx(&mut self, v: u32) {
        self.attr_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 attr_value = 3;

    pub fn attr_value(&self) -> u32 {
        self.attr_value.unwrap_or(0)
    }

    pub fn clear_attr_value(&mut self) {
        self.attr_value = ::std::option::Option::None;
    }

    pub fn has_attr_value(&self) -> bool {
        self.attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attr_value(&mut self, v: u32) {
        self.attr_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgModifyItemAttribute| { &m.item_id },
            |m: &mut CMsgModifyItemAttribute| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attr_defidx",
            |m: &CMsgModifyItemAttribute| { &m.attr_defidx },
            |m: &mut CMsgModifyItemAttribute| { &mut m.attr_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attr_value",
            |m: &CMsgModifyItemAttribute| { &m.attr_value },
            |m: &mut CMsgModifyItemAttribute| { &mut m.attr_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgModifyItemAttribute>(
            "CMsgModifyItemAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgModifyItemAttribute {
    const NAME: &'static str = "CMsgModifyItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.attr_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.attr_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.attr_defidx {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.attr_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.attr_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgModifyItemAttribute {
        CMsgModifyItemAttribute::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.attr_defidx = ::std::option::Option::None;
        self.attr_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgModifyItemAttribute {
        static instance: CMsgModifyItemAttribute = CMsgModifyItemAttribute {
            item_id: ::std::option::Option::None,
            attr_defidx: ::std::option::Option::None,
            attr_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgModifyItemAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgModifyItemAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgModifyItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgModifyItemAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyStatTrakSwap)
pub struct CMsgApplyStatTrakSwap {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStatTrakSwap.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStatTrakSwap.item_1_item_id)
    pub item_1_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStatTrakSwap.item_2_item_id)
    pub item_2_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStatTrakSwap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStatTrakSwap {
    fn default() -> &'a CMsgApplyStatTrakSwap {
        <CMsgApplyStatTrakSwap as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStatTrakSwap {
    pub fn new() -> CMsgApplyStatTrakSwap {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_1_item_id = 2;

    pub fn item_1_item_id(&self) -> u64 {
        self.item_1_item_id.unwrap_or(0)
    }

    pub fn clear_item_1_item_id(&mut self) {
        self.item_1_item_id = ::std::option::Option::None;
    }

    pub fn has_item_1_item_id(&self) -> bool {
        self.item_1_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_1_item_id(&mut self, v: u64) {
        self.item_1_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_2_item_id = 3;

    pub fn item_2_item_id(&self) -> u64 {
        self.item_2_item_id.unwrap_or(0)
    }

    pub fn clear_item_2_item_id(&mut self) {
        self.item_2_item_id = ::std::option::Option::None;
    }

    pub fn has_item_2_item_id(&self) -> bool {
        self.item_2_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_2_item_id(&mut self, v: u64) {
        self.item_2_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool_item_id",
            |m: &CMsgApplyStatTrakSwap| { &m.tool_item_id },
            |m: &mut CMsgApplyStatTrakSwap| { &mut m.tool_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_1_item_id",
            |m: &CMsgApplyStatTrakSwap| { &m.item_1_item_id },
            |m: &mut CMsgApplyStatTrakSwap| { &mut m.item_1_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_2_item_id",
            |m: &CMsgApplyStatTrakSwap| { &m.item_2_item_id },
            |m: &mut CMsgApplyStatTrakSwap| { &mut m.item_2_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStatTrakSwap>(
            "CMsgApplyStatTrakSwap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStatTrakSwap {
    const NAME: &'static str = "CMsgApplyStatTrakSwap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_1_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_2_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_1_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_2_item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_1_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_2_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStatTrakSwap {
        CMsgApplyStatTrakSwap::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_1_item_id = ::std::option::Option::None;
        self.item_2_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStatTrakSwap {
        static instance: CMsgApplyStatTrakSwap = CMsgApplyStatTrakSwap {
            tool_item_id: ::std::option::Option::None,
            item_1_item_id: ::std::option::Option::None,
            item_2_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStatTrakSwap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStatTrakSwap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStatTrakSwap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStatTrakSwap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyStrangePart)
pub struct CMsgApplyStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangePart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "strange_part_item_id",
            |m: &CMsgApplyStrangePart| { &m.strange_part_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.strange_part_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_item_id",
            |m: &CMsgApplyStrangePart| { &m.item_item_id },
            |m: &mut CMsgApplyStrangePart| { &mut m.item_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyStrangePart>(
            "CMsgApplyStrangePart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyStrangePart {
    const NAME: &'static str = "CMsgApplyStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: CMsgApplyStrangePart = CMsgApplyStrangePart {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyStrangePart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyStrangePart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyStrangePart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyStrangePart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyPennantUpgrade)
pub struct CMsgApplyPennantUpgrade {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyPennantUpgrade.upgrade_item_id)
    pub upgrade_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyPennantUpgrade.pennant_item_id)
    pub pennant_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyPennantUpgrade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyPennantUpgrade {
    fn default() -> &'a CMsgApplyPennantUpgrade {
        <CMsgApplyPennantUpgrade as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyPennantUpgrade {
    pub fn new() -> CMsgApplyPennantUpgrade {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_item_id = 1;

    pub fn upgrade_item_id(&self) -> u64 {
        self.upgrade_item_id.unwrap_or(0)
    }

    pub fn clear_upgrade_item_id(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_item_id(&self) -> bool {
        self.upgrade_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_item_id(&mut self, v: u64) {
        self.upgrade_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 pennant_item_id = 2;

    pub fn pennant_item_id(&self) -> u64 {
        self.pennant_item_id.unwrap_or(0)
    }

    pub fn clear_pennant_item_id(&mut self) {
        self.pennant_item_id = ::std::option::Option::None;
    }

    pub fn has_pennant_item_id(&self) -> bool {
        self.pennant_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pennant_item_id(&mut self, v: u64) {
        self.pennant_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgrade_item_id",
            |m: &CMsgApplyPennantUpgrade| { &m.upgrade_item_id },
            |m: &mut CMsgApplyPennantUpgrade| { &mut m.upgrade_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pennant_item_id",
            |m: &CMsgApplyPennantUpgrade| { &m.pennant_item_id },
            |m: &mut CMsgApplyPennantUpgrade| { &mut m.pennant_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyPennantUpgrade>(
            "CMsgApplyPennantUpgrade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyPennantUpgrade {
    const NAME: &'static str = "CMsgApplyPennantUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upgrade_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.pennant_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pennant_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.upgrade_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pennant_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyPennantUpgrade {
        CMsgApplyPennantUpgrade::new()
    }

    fn clear(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
        self.pennant_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyPennantUpgrade {
        static instance: CMsgApplyPennantUpgrade = CMsgApplyPennantUpgrade {
            upgrade_item_id: ::std::option::Option::None,
            pennant_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyPennantUpgrade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyPennantUpgrade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyPennantUpgrade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyPennantUpgrade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgApplyEggEssence)
pub struct CMsgApplyEggEssence {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyEggEssence.essence_item_id)
    pub essence_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyEggEssence.egg_item_id)
    pub egg_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyEggEssence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyEggEssence {
    fn default() -> &'a CMsgApplyEggEssence {
        <CMsgApplyEggEssence as ::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyEggEssence {
    pub fn new() -> CMsgApplyEggEssence {
        ::std::default::Default::default()
    }

    // optional uint64 essence_item_id = 1;

    pub fn essence_item_id(&self) -> u64 {
        self.essence_item_id.unwrap_or(0)
    }

    pub fn clear_essence_item_id(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
    }

    pub fn has_essence_item_id(&self) -> bool {
        self.essence_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essence_item_id(&mut self, v: u64) {
        self.essence_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 egg_item_id = 2;

    pub fn egg_item_id(&self) -> u64 {
        self.egg_item_id.unwrap_or(0)
    }

    pub fn clear_egg_item_id(&mut self) {
        self.egg_item_id = ::std::option::Option::None;
    }

    pub fn has_egg_item_id(&self) -> bool {
        self.egg_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egg_item_id(&mut self, v: u64) {
        self.egg_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "essence_item_id",
            |m: &CMsgApplyEggEssence| { &m.essence_item_id },
            |m: &mut CMsgApplyEggEssence| { &mut m.essence_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "egg_item_id",
            |m: &CMsgApplyEggEssence| { &m.egg_item_id },
            |m: &mut CMsgApplyEggEssence| { &mut m.egg_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgApplyEggEssence>(
            "CMsgApplyEggEssence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgApplyEggEssence {
    const NAME: &'static str = "CMsgApplyEggEssence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.essence_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.egg_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.essence_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.egg_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.essence_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.egg_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyEggEssence {
        CMsgApplyEggEssence::new()
    }

    fn clear(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
        self.egg_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyEggEssence {
        static instance: CMsgApplyEggEssence = CMsgApplyEggEssence {
            essence_item_id: ::std::option::Option::None,
            egg_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgApplyEggEssence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgApplyEggEssence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgApplyEggEssence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgApplyEggEssence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemAttribute)
pub struct CSOEconItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemAttribute.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value_bytes)
    pub value_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemAttribute.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;

    pub fn value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value_bytes(&mut self) {
        self.value_bytes = ::std::option::Option::None;
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemAttribute| { &m.def_index },
            |m: &mut CSOEconItemAttribute| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CSOEconItemAttribute| { &m.value },
            |m: &mut CSOEconItemAttribute| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_bytes",
            |m: &CSOEconItemAttribute| { &m.value_bytes },
            |m: &mut CSOEconItemAttribute| { &mut m.value_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemAttribute>(
            "CSOEconItemAttribute",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemAttribute {
    const NAME: &'static str = "CSOEconItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.value_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_bytes.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: CSOEconItemAttribute = CSOEconItemAttribute {
            def_index: ::std::option::Option::None,
            value: ::std::option::Option::None,
            value_bytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemAttribute {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemAttribute").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemAttribute {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemEquipped)
pub struct CSOEconItemEquipped {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemEquipped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CSOEconItemEquipped| { &m.new_class },
            |m: &mut CSOEconItemEquipped| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CSOEconItemEquipped| { &m.new_slot },
            |m: &mut CSOEconItemEquipped| { &mut m.new_slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemEquipped>(
            "CSOEconItemEquipped",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemEquipped {
    const NAME: &'static str = "CSOEconItemEquipped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: CSOEconItemEquipped = CSOEconItemEquipped {
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemEquipped {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemEquipped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemEquipped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEquipped {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItem)
pub struct CSOEconItem {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItem.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_name)
    pub custom_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.custom_desc)
    pub custom_desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOEconItem.attribute)
    pub attribute: ::std::vec::Vec<CSOEconItemAttribute>,
    // @@protoc_insertion_point(field:CSOEconItem.interior_item)
    pub interior_item: ::protobuf::MessageField<CSOEconItem>,
    // @@protoc_insertion_point(field:CSOEconItem.in_use)
    pub in_use: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconItem.style)
    pub style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.equipped_state)
    pub equipped_state: ::std::vec::Vec<CSOEconItemEquipped>,
    // @@protoc_insertion_point(field:CSOEconItem.rarity)
    pub rarity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(0)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional string custom_name = 10;

    pub fn custom_name(&self) -> &str {
        match self.custom_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_name(&mut self) {
        self.custom_name = ::std::option::Option::None;
    }

    pub fn has_custom_name(&self) -> bool {
        self.custom_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_name(&mut self, v: ::std::string::String) {
        self.custom_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_name(&mut self) -> &mut ::std::string::String {
        if self.custom_name.is_none() {
            self.custom_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_name(&mut self) -> ::std::string::String {
        self.custom_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_desc = 11;

    pub fn custom_desc(&self) -> &str {
        match self.custom_desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_desc(&mut self) {
        self.custom_desc = ::std::option::Option::None;
    }

    pub fn has_custom_desc(&self) -> bool {
        self.custom_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_desc(&mut self, v: ::std::string::String) {
        self.custom_desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_desc(&mut self) -> &mut ::std::string::String {
        if self.custom_desc.is_none() {
            self.custom_desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_desc(&mut self) -> ::std::string::String {
        self.custom_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool in_use = 14;

    pub fn in_use(&self) -> bool {
        self.in_use.unwrap_or(false)
    }

    pub fn clear_in_use(&mut self) {
        self.in_use = ::std::option::Option::None;
    }

    pub fn has_in_use(&self) -> bool {
        self.in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_use(&mut self, v: bool) {
        self.in_use = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;

    pub fn style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0u64)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 19;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CSOEconItem| { &m.id },
            |m: &mut CSOEconItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItem| { &m.account_id },
            |m: &mut CSOEconItem| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CSOEconItem| { &m.inventory },
            |m: &mut CSOEconItem| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItem| { &m.def_index },
            |m: &mut CSOEconItem| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quantity",
            |m: &CSOEconItem| { &m.quantity },
            |m: &mut CSOEconItem| { &mut m.quantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level",
            |m: &CSOEconItem| { &m.level },
            |m: &mut CSOEconItem| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSOEconItem| { &m.quality },
            |m: &mut CSOEconItem| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSOEconItem| { &m.flags },
            |m: &mut CSOEconItem| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CSOEconItem| { &m.origin },
            |m: &mut CSOEconItem| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_name",
            |m: &CSOEconItem| { &m.custom_name },
            |m: &mut CSOEconItem| { &mut m.custom_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "custom_desc",
            |m: &CSOEconItem| { &m.custom_desc },
            |m: &mut CSOEconItem| { &mut m.custom_desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attribute",
            |m: &CSOEconItem| { &m.attribute },
            |m: &mut CSOEconItem| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CSOEconItem>(
            "interior_item",
            |m: &CSOEconItem| { &m.interior_item },
            |m: &mut CSOEconItem| { &mut m.interior_item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_use",
            |m: &CSOEconItem| { &m.in_use },
            |m: &mut CSOEconItem| { &mut m.in_use },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &CSOEconItem| { &m.style },
            |m: &mut CSOEconItem| { &mut m.style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "original_id",
            |m: &CSOEconItem| { &m.original_id },
            |m: &mut CSOEconItem| { &mut m.original_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "equipped_state",
            |m: &CSOEconItem| { &m.equipped_state },
            |m: &mut CSOEconItem| { &mut m.equipped_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CSOEconItem| { &m.rarity },
            |m: &mut CSOEconItem| { &mut m.rarity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItem>(
            "CSOEconItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItem {
    const NAME: &'static str = "CSOEconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.custom_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.custom_desc = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.attribute.push(is.read_message()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.interior_item)?;
                },
                112 => {
                    self.in_use = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.style = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.equipped_state.push(is.read_message()?);
                },
                152 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.level {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.custom_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.custom_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.in_use {
            my_size += 1 + 1;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::protobuf::rt::uint64_size(16, v);
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.custom_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.custom_desc.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.attribute {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.interior_item.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.in_use {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        for v in &self.equipped_state {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.rarity {
            os.write_uint32(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.custom_name = ::std::option::Option::None;
        self.custom_desc = ::std::option::Option::None;
        self.attribute.clear();
        self.interior_item.clear();
        self.in_use = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.equipped_state.clear();
        self.rarity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: CSOEconItem = CSOEconItem {
            id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            level: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            custom_name: ::std::option::Option::None,
            custom_desc: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            interior_item: ::protobuf::MessageField::none(),
            in_use: ::std::option::Option::None,
            style: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            equipped_state: ::std::vec::Vec::new(),
            rarity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAdjustItemEquippedState)
pub struct CMsgAdjustItemEquippedState {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedState.swap)
    pub swap: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustItemEquippedState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedState {
    fn default() -> &'a CMsgAdjustItemEquippedState {
        <CMsgAdjustItemEquippedState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedState {
    pub fn new() -> CMsgAdjustItemEquippedState {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 new_class = 2;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 3;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }

    // optional bool swap = 4;

    pub fn swap(&self) -> bool {
        self.swap.unwrap_or(false)
    }

    pub fn clear_swap(&mut self) {
        self.swap = ::std::option::Option::None;
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: bool) {
        self.swap = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgAdjustItemEquippedState| { &m.item_id },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_class",
            |m: &CMsgAdjustItemEquippedState| { &m.new_class },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_slot",
            |m: &CMsgAdjustItemEquippedState| { &m.new_slot },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.new_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swap",
            |m: &CMsgAdjustItemEquippedState| { &m.swap },
            |m: &mut CMsgAdjustItemEquippedState| { &mut m.swap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustItemEquippedState>(
            "CMsgAdjustItemEquippedState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedState {
    const NAME: &'static str = "CMsgAdjustItemEquippedState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.swap = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.new_class {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.swap {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.new_class {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.swap {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedState {
        CMsgAdjustItemEquippedState::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.swap = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedState {
        static instance: CMsgAdjustItemEquippedState = CMsgAdjustItemEquippedState {
            item_id: ::std::option::Option::None,
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            swap: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustItemEquippedState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustItemEquippedState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustItemEquippedState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAdjustItemEquippedStateMulti)
pub struct CMsgAdjustItemEquippedStateMulti {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedStateMulti.t_equips)
    pub t_equips: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedStateMulti.ct_equips)
    pub ct_equips: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgAdjustItemEquippedStateMulti.noteam_equips)
    pub noteam_equips: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustItemEquippedStateMulti.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustItemEquippedStateMulti {
    fn default() -> &'a CMsgAdjustItemEquippedStateMulti {
        <CMsgAdjustItemEquippedStateMulti as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustItemEquippedStateMulti {
    pub fn new() -> CMsgAdjustItemEquippedStateMulti {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "t_equips",
            |m: &CMsgAdjustItemEquippedStateMulti| { &m.t_equips },
            |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.t_equips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ct_equips",
            |m: &CMsgAdjustItemEquippedStateMulti| { &m.ct_equips },
            |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.ct_equips },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "noteam_equips",
            |m: &CMsgAdjustItemEquippedStateMulti| { &m.noteam_equips },
            |m: &mut CMsgAdjustItemEquippedStateMulti| { &mut m.noteam_equips },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustItemEquippedStateMulti>(
            "CMsgAdjustItemEquippedStateMulti",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustItemEquippedStateMulti {
    const NAME: &'static str = "CMsgAdjustItemEquippedStateMulti";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.t_equips)?;
                },
                8 => {
                    self.t_equips.push(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.ct_equips)?;
                },
                16 => {
                    self.ct_equips.push(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.noteam_equips)?;
                },
                24 => {
                    self.noteam_equips.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.t_equips {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        for value in &self.ct_equips {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        for value in &self.noteam_equips {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.t_equips {
            os.write_uint64(1, *v)?;
        };
        for v in &self.ct_equips {
            os.write_uint64(2, *v)?;
        };
        for v in &self.noteam_equips {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustItemEquippedStateMulti {
        CMsgAdjustItemEquippedStateMulti::new()
    }

    fn clear(&mut self) {
        self.t_equips.clear();
        self.ct_equips.clear();
        self.noteam_equips.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustItemEquippedStateMulti {
        static instance: CMsgAdjustItemEquippedStateMulti = CMsgAdjustItemEquippedStateMulti {
            t_equips: ::std::vec::Vec::new(),
            ct_equips: ::std::vec::Vec::new(),
            noteam_equips: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustItemEquippedStateMulti {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustItemEquippedStateMulti").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustItemEquippedStateMulti {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustItemEquippedStateMulti {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSortItems)
pub struct CMsgSortItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgSortItems.sort_type)
    pub sort_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSortItems.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;

    pub fn sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }

    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_type",
            |m: &CMsgSortItems| { &m.sort_type },
            |m: &mut CMsgSortItems| { &mut m.sort_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSortItems>(
            "CMsgSortItems",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSortItems {
    const NAME: &'static str = "CMsgSortItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sort_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: CMsgSortItems = CMsgSortItems {
            sort_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSortItems {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSortItems").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSortItems {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSortItems {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconClaimCode)
pub struct CSOEconClaimCode {
    // message fields
    // @@protoc_insertion_point(field:CSOEconClaimCode.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code_type)
    pub code_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.time_acquired)
    pub time_acquired: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconClaimCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconClaimCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconClaimCode {
    fn default() -> &'a CSOEconClaimCode {
        <CSOEconClaimCode as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconClaimCode {
    pub fn new() -> CSOEconClaimCode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 code_type = 2;

    pub fn code_type(&self) -> u32 {
        self.code_type.unwrap_or(0)
    }

    pub fn clear_code_type(&mut self) {
        self.code_type = ::std::option::Option::None;
    }

    pub fn has_code_type(&self) -> bool {
        self.code_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_type(&mut self, v: u32) {
        self.code_type = ::std::option::Option::Some(v);
    }

    // optional uint32 time_acquired = 3;

    pub fn time_acquired(&self) -> u32 {
        self.time_acquired.unwrap_or(0)
    }

    pub fn clear_time_acquired(&mut self) {
        self.time_acquired = ::std::option::Option::None;
    }

    pub fn has_time_acquired(&self) -> bool {
        self.time_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_acquired(&mut self, v: u32) {
        self.time_acquired = ::std::option::Option::Some(v);
    }

    // optional string code = 4;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconClaimCode| { &m.account_id },
            |m: &mut CSOEconClaimCode| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_type",
            |m: &CSOEconClaimCode| { &m.code_type },
            |m: &mut CSOEconClaimCode| { &mut m.code_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_acquired",
            |m: &CSOEconClaimCode| { &m.time_acquired },
            |m: &mut CSOEconClaimCode| { &mut m.time_acquired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &CSOEconClaimCode| { &m.code },
            |m: &mut CSOEconClaimCode| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconClaimCode>(
            "CSOEconClaimCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconClaimCode {
    const NAME: &'static str = "CSOEconClaimCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.code_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_acquired = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.code_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_acquired {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_acquired {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconClaimCode {
        CSOEconClaimCode::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.code_type = ::std::option::Option::None;
        self.time_acquired = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconClaimCode {
        static instance: CSOEconClaimCode = CSOEconClaimCode {
            account_id: ::std::option::Option::None,
            code_type: ::std::option::Option::None,
            time_acquired: ::std::option::Option::None,
            code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconClaimCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconClaimCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconClaimCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconClaimCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgStoreGetUserData)
pub struct CMsgStoreGetUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserData.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserData.currency)
    pub currency: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserData {
    fn default() -> &'a CMsgStoreGetUserData {
        <CMsgStoreGetUserData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserData {
    pub fn new() -> CMsgStoreGetUserData {
        ::std::default::Default::default()
    }

    // optional fixed32 price_sheet_version = 1;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 2;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet_version",
            |m: &CMsgStoreGetUserData| { &m.price_sheet_version },
            |m: &mut CMsgStoreGetUserData| { &mut m.price_sheet_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgStoreGetUserData| { &m.currency },
            |m: &mut CMsgStoreGetUserData| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStoreGetUserData>(
            "CMsgStoreGetUserData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStoreGetUserData {
    const NAME: &'static str = "CMsgStoreGetUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserData {
        CMsgStoreGetUserData::new()
    }

    fn clear(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserData {
        static instance: CMsgStoreGetUserData = CMsgStoreGetUserData {
            price_sheet_version: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStoreGetUserData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStoreGetUserData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStoreGetUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgStoreGetUserDataResponse)
pub struct CMsgStoreGetUserDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.currency_deprecated)
    pub currency_deprecated: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.country_deprecated)
    pub country_deprecated: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet_version)
    pub price_sheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStoreGetUserDataResponse.price_sheet)
    pub price_sheet: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStoreGetUserDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStoreGetUserDataResponse {
    fn default() -> &'a CMsgStoreGetUserDataResponse {
        <CMsgStoreGetUserDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgStoreGetUserDataResponse {
    pub fn new() -> CMsgStoreGetUserDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional int32 currency_deprecated = 2;

    pub fn currency_deprecated(&self) -> i32 {
        self.currency_deprecated.unwrap_or(0)
    }

    pub fn clear_currency_deprecated(&mut self) {
        self.currency_deprecated = ::std::option::Option::None;
    }

    pub fn has_currency_deprecated(&self) -> bool {
        self.currency_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_deprecated(&mut self, v: i32) {
        self.currency_deprecated = ::std::option::Option::Some(v);
    }

    // optional string country_deprecated = 3;

    pub fn country_deprecated(&self) -> &str {
        match self.country_deprecated.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_deprecated(&mut self) {
        self.country_deprecated = ::std::option::Option::None;
    }

    pub fn has_country_deprecated(&self) -> bool {
        self.country_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_deprecated(&mut self, v: ::std::string::String) {
        self.country_deprecated = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_deprecated(&mut self) -> &mut ::std::string::String {
        if self.country_deprecated.is_none() {
            self.country_deprecated = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_deprecated.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_deprecated(&mut self) -> ::std::string::String {
        self.country_deprecated.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 price_sheet_version = 4;

    pub fn price_sheet_version(&self) -> u32 {
        self.price_sheet_version.unwrap_or(0)
    }

    pub fn clear_price_sheet_version(&mut self) {
        self.price_sheet_version = ::std::option::Option::None;
    }

    pub fn has_price_sheet_version(&self) -> bool {
        self.price_sheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet_version(&mut self, v: u32) {
        self.price_sheet_version = ::std::option::Option::Some(v);
    }

    // optional bytes price_sheet = 8;

    pub fn price_sheet(&self) -> &[u8] {
        match self.price_sheet.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_price_sheet(&mut self) {
        self.price_sheet = ::std::option::Option::None;
    }

    pub fn has_price_sheet(&self) -> bool {
        self.price_sheet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_sheet(&mut self, v: ::std::vec::Vec<u8>) {
        self.price_sheet = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_price_sheet(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.price_sheet.is_none() {
            self.price_sheet = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.price_sheet.as_mut().unwrap()
    }

    // Take field
    pub fn take_price_sheet(&mut self) -> ::std::vec::Vec<u8> {
        self.price_sheet.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgStoreGetUserDataResponse| { &m.result },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency_deprecated",
            |m: &CMsgStoreGetUserDataResponse| { &m.currency_deprecated },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.currency_deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_deprecated",
            |m: &CMsgStoreGetUserDataResponse| { &m.country_deprecated },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.country_deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet_version",
            |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet_version },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price_sheet",
            |m: &CMsgStoreGetUserDataResponse| { &m.price_sheet },
            |m: &mut CMsgStoreGetUserDataResponse| { &mut m.price_sheet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgStoreGetUserDataResponse>(
            "CMsgStoreGetUserDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgStoreGetUserDataResponse {
    const NAME: &'static str = "CMsgStoreGetUserDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.currency_deprecated = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.country_deprecated = ::std::option::Option::Some(is.read_string()?);
                },
                37 => {
                    self.price_sheet_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                66 => {
                    self.price_sheet = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.currency_deprecated {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.country_deprecated.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.price_sheet_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.currency_deprecated {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.country_deprecated.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.price_sheet_version {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.price_sheet.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStoreGetUserDataResponse {
        CMsgStoreGetUserDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.currency_deprecated = ::std::option::Option::None;
        self.country_deprecated = ::std::option::Option::None;
        self.price_sheet_version = ::std::option::Option::None;
        self.price_sheet = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStoreGetUserDataResponse {
        static instance: CMsgStoreGetUserDataResponse = CMsgStoreGetUserDataResponse {
            result: ::std::option::Option::None,
            currency_deprecated: ::std::option::Option::None,
            country_deprecated: ::std::option::Option::None,
            price_sheet_version: ::std::option::Option::None,
            price_sheet: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgStoreGetUserDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgStoreGetUserDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgStoreGetUserDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgStoreGetUserDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgUpdateItemSchema)
pub struct CMsgUpdateItemSchema {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game)
    pub items_game: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.item_schema_version)
    pub item_schema_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUpdateItemSchema.items_game_url)
    pub items_game_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateItemSchema.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateItemSchema {
    fn default() -> &'a CMsgUpdateItemSchema {
        <CMsgUpdateItemSchema as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateItemSchema {
    pub fn new() -> CMsgUpdateItemSchema {
        ::std::default::Default::default()
    }

    // optional bytes items_game = 1;

    pub fn items_game(&self) -> &[u8] {
        match self.items_game.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_items_game(&mut self) {
        self.items_game = ::std::option::Option::None;
    }

    pub fn has_items_game(&self) -> bool {
        self.items_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game(&mut self, v: ::std::vec::Vec<u8>) {
        self.items_game = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.items_game.is_none() {
            self.items_game = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.items_game.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game(&mut self) -> ::std::vec::Vec<u8> {
        self.items_game.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 item_schema_version = 2;

    pub fn item_schema_version(&self) -> u32 {
        self.item_schema_version.unwrap_or(0)
    }

    pub fn clear_item_schema_version(&mut self) {
        self.item_schema_version = ::std::option::Option::None;
    }

    pub fn has_item_schema_version(&self) -> bool {
        self.item_schema_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_schema_version(&mut self, v: u32) {
        self.item_schema_version = ::std::option::Option::Some(v);
    }

    // optional string items_game_url = 4;

    pub fn items_game_url(&self) -> &str {
        match self.items_game_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_items_game_url(&mut self) {
        self.items_game_url = ::std::option::Option::None;
    }

    pub fn has_items_game_url(&self) -> bool {
        self.items_game_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_game_url(&mut self, v: ::std::string::String) {
        self.items_game_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_items_game_url(&mut self) -> &mut ::std::string::String {
        if self.items_game_url.is_none() {
            self.items_game_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.items_game_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_items_game_url(&mut self) -> ::std::string::String {
        self.items_game_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_game",
            |m: &CMsgUpdateItemSchema| { &m.items_game },
            |m: &mut CMsgUpdateItemSchema| { &mut m.items_game },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_schema_version",
            |m: &CMsgUpdateItemSchema| { &m.item_schema_version },
            |m: &mut CMsgUpdateItemSchema| { &mut m.item_schema_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "items_game_url",
            |m: &CMsgUpdateItemSchema| { &m.items_game_url },
            |m: &mut CMsgUpdateItemSchema| { &mut m.items_game_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUpdateItemSchema>(
            "CMsgUpdateItemSchema",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUpdateItemSchema {
    const NAME: &'static str = "CMsgUpdateItemSchema";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.items_game = ::std::option::Option::Some(is.read_bytes()?);
                },
                21 => {
                    self.item_schema_version = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    self.items_game_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.items_game.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.item_schema_version {
            my_size += 1 + 4;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.items_game.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.item_schema_version {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.items_game_url.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateItemSchema {
        CMsgUpdateItemSchema::new()
    }

    fn clear(&mut self) {
        self.items_game = ::std::option::Option::None;
        self.item_schema_version = ::std::option::Option::None;
        self.items_game_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateItemSchema {
        static instance: CMsgUpdateItemSchema = CMsgUpdateItemSchema {
            items_game: ::std::option::Option::None,
            item_schema_version: ::std::option::Option::None,
            items_game_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUpdateItemSchema {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUpdateItemSchema").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUpdateItemSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUpdateItemSchema {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCError)
pub struct CMsgGCError {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCError.error_text)
    pub error_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCError {
    fn default() -> &'a CMsgGCError {
        <CMsgGCError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCError {
    pub fn new() -> CMsgGCError {
        ::std::default::Default::default()
    }

    // optional string error_text = 1;

    pub fn error_text(&self) -> &str {
        match self.error_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_text(&mut self) {
        self.error_text = ::std::option::Option::None;
    }

    pub fn has_error_text(&self) -> bool {
        self.error_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_text(&mut self, v: ::std::string::String) {
        self.error_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_text(&mut self) -> &mut ::std::string::String {
        if self.error_text.is_none() {
            self.error_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_text(&mut self) -> ::std::string::String {
        self.error_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_text",
            |m: &CMsgGCError| { &m.error_text },
            |m: &mut CMsgGCError| { &mut m.error_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCError>(
            "CMsgGCError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCError {
    const NAME: &'static str = "CMsgGCError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error_text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.error_text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCError {
        CMsgGCError::new()
    }

    fn clear(&mut self) {
        self.error_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCError {
        static instance: CMsgGCError = CMsgGCError {
            error_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRequestInventoryRefresh)
pub struct CMsgRequestInventoryRefresh {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRequestInventoryRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRequestInventoryRefresh {
    fn default() -> &'a CMsgRequestInventoryRefresh {
        <CMsgRequestInventoryRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRequestInventoryRefresh {
    pub fn new() -> CMsgRequestInventoryRefresh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRequestInventoryRefresh>(
            "CMsgRequestInventoryRefresh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRequestInventoryRefresh {
    const NAME: &'static str = "CMsgRequestInventoryRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRequestInventoryRefresh {
        CMsgRequestInventoryRefresh::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRequestInventoryRefresh {
        static instance: CMsgRequestInventoryRefresh = CMsgRequestInventoryRefresh {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRequestInventoryRefresh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRequestInventoryRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRequestInventoryRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRequestInventoryRefresh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgConVarValue)
pub struct CMsgConVarValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgConVarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgConVarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConVarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConVarValue {
    fn default() -> &'a CMsgConVarValue {
        <CMsgConVarValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConVarValue {
    pub fn new() -> CMsgConVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgConVarValue| { &m.name },
            |m: &mut CMsgConVarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgConVarValue| { &m.value },
            |m: &mut CMsgConVarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConVarValue>(
            "CMsgConVarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConVarValue {
    const NAME: &'static str = "CMsgConVarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConVarValue {
        CMsgConVarValue::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConVarValue {
        static instance: CMsgConVarValue = CMsgConVarValue {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConVarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConVarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConVarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgReplicateConVars)
pub struct CMsgReplicateConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplicateConVars.convars)
    pub convars: ::std::vec::Vec<CMsgConVarValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplicateConVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplicateConVars {
    fn default() -> &'a CMsgReplicateConVars {
        <CMsgReplicateConVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplicateConVars {
    pub fn new() -> CMsgReplicateConVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "convars",
            |m: &CMsgReplicateConVars| { &m.convars },
            |m: &mut CMsgReplicateConVars| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplicateConVars>(
            "CMsgReplicateConVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplicateConVars {
    const NAME: &'static str = "CMsgReplicateConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.convars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.convars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.convars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplicateConVars {
        CMsgReplicateConVars::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplicateConVars {
        static instance: CMsgReplicateConVars = CMsgReplicateConVars {
            convars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplicateConVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplicateConVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplicateConVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplicateConVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgUseItem)
pub struct CMsgUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgUseItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUseItem.gift__potential_targets)
    pub gift__potential_targets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.duel__class_lock)
    pub duel__class_lock: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgUseItem.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUseItem {
    fn default() -> &'a CMsgUseItem {
        <CMsgUseItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgUseItem {
    pub fn new() -> CMsgUseItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 2;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel__class_lock = 4;

    pub fn duel__class_lock(&self) -> u32 {
        self.duel__class_lock.unwrap_or(0)
    }

    pub fn clear_duel__class_lock(&mut self) {
        self.duel__class_lock = ::std::option::Option::None;
    }

    pub fn has_duel__class_lock(&self) -> bool {
        self.duel__class_lock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel__class_lock(&mut self, v: u32) {
        self.duel__class_lock = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 5;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgUseItem| { &m.item_id },
            |m: &mut CMsgUseItem| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgUseItem| { &m.target_steam_id },
            |m: &mut CMsgUseItem| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gift__potential_targets",
            |m: &CMsgUseItem| { &m.gift__potential_targets },
            |m: &mut CMsgUseItem| { &mut m.gift__potential_targets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duel__class_lock",
            |m: &CMsgUseItem| { &m.duel__class_lock },
            |m: &mut CMsgUseItem| { &mut m.duel__class_lock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initiator_steam_id",
            |m: &CMsgUseItem| { &m.initiator_steam_id },
            |m: &mut CMsgUseItem| { &mut m.initiator_steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgUseItem>(
            "CMsgUseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgUseItem {
    const NAME: &'static str = "CMsgUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.gift__potential_targets)?;
                },
                24 => {
                    self.gift__potential_targets.push(is.read_uint32()?);
                },
                32 => {
                    self.duel__class_lock = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        for value in &self.gift__potential_targets {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.duel__class_lock {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.gift__potential_targets {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.duel__class_lock {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUseItem {
        CMsgUseItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.gift__potential_targets.clear();
        self.duel__class_lock = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUseItem {
        static instance: CMsgUseItem = CMsgUseItem {
            item_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            gift__potential_targets: ::std::vec::Vec::new(),
            duel__class_lock: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgUseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgUseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgUseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgUseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgReplayUploadedToYouTube)
pub struct CMsgReplayUploadedToYouTube {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_url)
    pub youtube_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.youtube_account_name)
    pub youtube_account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplayUploadedToYouTube.session_id)
    pub session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplayUploadedToYouTube.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplayUploadedToYouTube {
    fn default() -> &'a CMsgReplayUploadedToYouTube {
        <CMsgReplayUploadedToYouTube as ::protobuf::Message>::default_instance()
    }
}

impl CMsgReplayUploadedToYouTube {
    pub fn new() -> CMsgReplayUploadedToYouTube {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;

    pub fn youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_url(&mut self) {
        self.youtube_url = ::std::option::Option::None;
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string youtube_account_name = 2;

    pub fn youtube_account_name(&self) -> &str {
        match self.youtube_account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_account_name(&mut self) {
        self.youtube_account_name = ::std::option::Option::None;
    }

    pub fn has_youtube_account_name(&self) -> bool {
        self.youtube_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_account_name(&mut self, v: ::std::string::String) {
        self.youtube_account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_account_name(&mut self) -> &mut ::std::string::String {
        if self.youtube_account_name.is_none() {
            self.youtube_account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_account_name(&mut self) -> ::std::string::String {
        self.youtube_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 session_id = 3;

    pub fn session_id(&self) -> u64 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u64) {
        self.session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "youtube_url",
            |m: &CMsgReplayUploadedToYouTube| { &m.youtube_url },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "youtube_account_name",
            |m: &CMsgReplayUploadedToYouTube| { &m.youtube_account_name },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.youtube_account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &CMsgReplayUploadedToYouTube| { &m.session_id },
            |m: &mut CMsgReplayUploadedToYouTube| { &mut m.session_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgReplayUploadedToYouTube>(
            "CMsgReplayUploadedToYouTube",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgReplayUploadedToYouTube {
    const NAME: &'static str = "CMsgReplayUploadedToYouTube";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.youtube_url = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.youtube_account_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.youtube_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.session_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.youtube_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.youtube_account_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplayUploadedToYouTube {
        CMsgReplayUploadedToYouTube::new()
    }

    fn clear(&mut self) {
        self.youtube_url = ::std::option::Option::None;
        self.youtube_account_name = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplayUploadedToYouTube {
        static instance: CMsgReplayUploadedToYouTube = CMsgReplayUploadedToYouTube {
            youtube_url: ::std::option::Option::None,
            youtube_account_name: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgReplayUploadedToYouTube {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgReplayUploadedToYouTube").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgReplayUploadedToYouTube {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgReplayUploadedToYouTube {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgConsumableExhausted)
pub struct CMsgConsumableExhausted {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumableExhausted.item_def_id)
    pub item_def_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumableExhausted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumableExhausted {
    fn default() -> &'a CMsgConsumableExhausted {
        <CMsgConsumableExhausted as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumableExhausted {
    pub fn new() -> CMsgConsumableExhausted {
        ::std::default::Default::default()
    }

    // optional int32 item_def_id = 1;

    pub fn item_def_id(&self) -> i32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: i32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_id",
            |m: &CMsgConsumableExhausted| { &m.item_def_id },
            |m: &mut CMsgConsumableExhausted| { &mut m.item_def_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConsumableExhausted>(
            "CMsgConsumableExhausted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConsumableExhausted {
    const NAME: &'static str = "CMsgConsumableExhausted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumableExhausted {
        CMsgConsumableExhausted::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumableExhausted {
        static instance: CMsgConsumableExhausted = CMsgConsumableExhausted {
            item_def_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConsumableExhausted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConsumableExhausted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConsumableExhausted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConsumableExhausted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgItemAcknowledged__DEPRECATED)
pub struct CMsgItemAcknowledged__DEPRECATED {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged__DEPRECATED.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAcknowledged__DEPRECATED.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged__DEPRECATED {
    fn default() -> &'a CMsgItemAcknowledged__DEPRECATED {
        <CMsgItemAcknowledged__DEPRECATED as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged__DEPRECATED {
    pub fn new() -> CMsgItemAcknowledged__DEPRECATED {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 7;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.account_id },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.inventory },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.def_index },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.quality },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.rarity },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.origin },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgItemAcknowledged__DEPRECATED| { &m.item_id },
            |m: &mut CMsgItemAcknowledged__DEPRECATED| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemAcknowledged__DEPRECATED>(
            "CMsgItemAcknowledged__DEPRECATED",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged__DEPRECATED {
    const NAME: &'static str = "CMsgItemAcknowledged__DEPRECATED";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged__DEPRECATED {
        CMsgItemAcknowledged__DEPRECATED::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged__DEPRECATED {
        static instance: CMsgItemAcknowledged__DEPRECATED = CMsgItemAcknowledged__DEPRECATED {
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemAcknowledged__DEPRECATED {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemAcknowledged__DEPRECATED").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemAcknowledged__DEPRECATED {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged__DEPRECATED {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSetItemPositions)
pub struct CMsgSetItemPositions {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemPositions.item_positions)
    pub item_positions: ::std::vec::Vec<cmsg_set_item_positions::ItemPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemPositions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_positions",
            |m: &CMsgSetItemPositions| { &m.item_positions },
            |m: &mut CMsgSetItemPositions| { &mut m.item_positions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSetItemPositions>(
            "CMsgSetItemPositions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSetItemPositions {
    const NAME: &'static str = "CMsgSetItemPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item_positions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.item_positions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn clear(&mut self) {
        self.item_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: CMsgSetItemPositions = CMsgSetItemPositions {
            item_positions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSetItemPositions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSetItemPositions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSetItemPositions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSetItemPositions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSetItemPositions`
pub mod cmsg_set_item_positions {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgSetItemPositions.ItemPosition)
    pub struct ItemPosition {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.legacy_item_id)
        pub legacy_item_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.position)
        pub position: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.item_id)
        pub item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetItemPositions.ItemPosition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPosition {
        fn default() -> &'a ItemPosition {
            <ItemPosition as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemPosition {
        pub fn new() -> ItemPosition {
            ::std::default::Default::default()
        }

        // optional uint32 legacy_item_id = 1;

        pub fn legacy_item_id(&self) -> u32 {
            self.legacy_item_id.unwrap_or(0)
        }

        pub fn clear_legacy_item_id(&mut self) {
            self.legacy_item_id = ::std::option::Option::None;
        }

        pub fn has_legacy_item_id(&self) -> bool {
            self.legacy_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_legacy_item_id(&mut self, v: u32) {
            self.legacy_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 position = 2;

        pub fn position(&self) -> u32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: u32) {
            self.position = ::std::option::Option::Some(v);
        }

        // optional uint64 item_id = 3;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "legacy_item_id",
                |m: &ItemPosition| { &m.legacy_item_id },
                |m: &mut ItemPosition| { &mut m.legacy_item_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position",
                |m: &ItemPosition| { &m.position },
                |m: &mut ItemPosition| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_id",
                |m: &ItemPosition| { &m.item_id },
                |m: &mut ItemPosition| { &mut m.item_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemPosition>(
                "CMsgSetItemPositions.ItemPosition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemPosition {
        const NAME: &'static str = "ItemPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.legacy_item_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.legacy_item_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.position {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.item_id {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.legacy_item_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.position {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.item_id {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPosition {
            ItemPosition::new()
        }

        fn clear(&mut self) {
            self.legacy_item_id = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPosition {
            static instance: ItemPosition = ItemPosition {
                legacy_item_id: ::std::option::Option::None,
                position: ::std::option::Option::None,
                item_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemPosition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSetItemPositions.ItemPosition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemPosition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemPosition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCReportAbuse)
pub struct CMsgGCReportAbuse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.abuse_type)
    pub abuse_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.content_type)
    pub content_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_ip)
    pub target_game_server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuse.target_game_server_port)
    pub target_game_server_port: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuse {
    fn default() -> &'a CMsgGCReportAbuse {
        <CMsgGCReportAbuse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuse {
    pub fn new() -> CMsgGCReportAbuse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gid = 5;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 abuse_type = 2;

    pub fn abuse_type(&self) -> u32 {
        self.abuse_type.unwrap_or(0)
    }

    pub fn clear_abuse_type(&mut self) {
        self.abuse_type = ::std::option::Option::None;
    }

    pub fn has_abuse_type(&self) -> bool {
        self.abuse_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abuse_type(&mut self, v: u32) {
        self.abuse_type = ::std::option::Option::Some(v);
    }

    // optional uint32 content_type = 3;

    pub fn content_type(&self) -> u32 {
        self.content_type.unwrap_or(0)
    }

    pub fn clear_content_type(&mut self) {
        self.content_type = ::std::option::Option::None;
    }

    pub fn has_content_type(&self) -> bool {
        self.content_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: u32) {
        self.content_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 target_game_server_ip = 6;

    pub fn target_game_server_ip(&self) -> u32 {
        self.target_game_server_ip.unwrap_or(0)
    }

    pub fn clear_target_game_server_ip(&mut self) {
        self.target_game_server_ip = ::std::option::Option::None;
    }

    pub fn has_target_game_server_ip(&self) -> bool {
        self.target_game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_ip(&mut self, v: u32) {
        self.target_game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 target_game_server_port = 7;

    pub fn target_game_server_port(&self) -> u32 {
        self.target_game_server_port.unwrap_or(0)
    }

    pub fn clear_target_game_server_port(&mut self) {
        self.target_game_server_port = ::std::option::Option::None;
    }

    pub fn has_target_game_server_port(&self) -> bool {
        self.target_game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_game_server_port(&mut self, v: u32) {
        self.target_game_server_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgGCReportAbuse| { &m.target_steam_id },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &CMsgGCReportAbuse| { &m.description },
            |m: &mut CMsgGCReportAbuse| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMsgGCReportAbuse| { &m.gid },
            |m: &mut CMsgGCReportAbuse| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abuse_type",
            |m: &CMsgGCReportAbuse| { &m.abuse_type },
            |m: &mut CMsgGCReportAbuse| { &mut m.abuse_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_type",
            |m: &CMsgGCReportAbuse| { &m.content_type },
            |m: &mut CMsgGCReportAbuse| { &mut m.content_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_game_server_ip",
            |m: &CMsgGCReportAbuse| { &m.target_game_server_ip },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_game_server_port",
            |m: &CMsgGCReportAbuse| { &m.target_game_server_port },
            |m: &mut CMsgGCReportAbuse| { &mut m.target_game_server_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCReportAbuse>(
            "CMsgGCReportAbuse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCReportAbuse {
    const NAME: &'static str = "CMsgGCReportAbuse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.abuse_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.content_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.target_game_server_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.target_game_server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.abuse_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.content_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.target_game_server_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.target_game_server_port {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.gid {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.abuse_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.content_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.target_game_server_ip {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.target_game_server_port {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuse {
        CMsgGCReportAbuse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.abuse_type = ::std::option::Option::None;
        self.content_type = ::std::option::Option::None;
        self.target_game_server_ip = ::std::option::Option::None;
        self.target_game_server_port = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuse {
        static instance: CMsgGCReportAbuse = CMsgGCReportAbuse {
            target_steam_id: ::std::option::Option::None,
            description: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            abuse_type: ::std::option::Option::None,
            content_type: ::std::option::Option::None,
            target_game_server_ip: ::std::option::Option::None,
            target_game_server_port: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCReportAbuse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCReportAbuse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCReportAbuse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCReportAbuseResponse)
pub struct CMsgGCReportAbuseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCReportAbuseResponse.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCReportAbuseResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCReportAbuseResponse {
    fn default() -> &'a CMsgGCReportAbuseResponse {
        <CMsgGCReportAbuseResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCReportAbuseResponse {
    pub fn new() -> CMsgGCReportAbuseResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 target_steam_id = 1;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string error_message = 3;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_steam_id",
            |m: &CMsgGCReportAbuseResponse| { &m.target_steam_id },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.target_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCReportAbuseResponse| { &m.result },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_message",
            |m: &CMsgGCReportAbuseResponse| { &m.error_message },
            |m: &mut CMsgGCReportAbuseResponse| { &mut m.error_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCReportAbuseResponse>(
            "CMsgGCReportAbuseResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCReportAbuseResponse {
    const NAME: &'static str = "CMsgGCReportAbuseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCReportAbuseResponse {
        CMsgGCReportAbuseResponse::new()
    }

    fn clear(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCReportAbuseResponse {
        static instance: CMsgGCReportAbuseResponse = CMsgGCReportAbuseResponse {
            target_steam_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCReportAbuseResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCReportAbuseResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCReportAbuseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCReportAbuseResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCNameItemNotification)
pub struct CMsgGCNameItemNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNameItemNotification.item_name_custom)
    pub item_name_custom: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNameItemNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNameItemNotification {
    fn default() -> &'a CMsgGCNameItemNotification {
        <CMsgGCNameItemNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNameItemNotification {
    pub fn new() -> CMsgGCNameItemNotification {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def_index = 2;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional string item_name_custom = 3;

    pub fn item_name_custom(&self) -> &str {
        match self.item_name_custom.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item_name_custom(&mut self) {
        self.item_name_custom = ::std::option::Option::None;
    }

    pub fn has_item_name_custom(&self) -> bool {
        self.item_name_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_name_custom(&mut self, v: ::std::string::String) {
        self.item_name_custom = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item_name_custom(&mut self) -> &mut ::std::string::String {
        if self.item_name_custom.is_none() {
            self.item_name_custom = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item_name_custom.as_mut().unwrap()
    }

    // Take field
    pub fn take_item_name_custom(&mut self) -> ::std::string::String {
        self.item_name_custom.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_steamid",
            |m: &CMsgGCNameItemNotification| { &m.player_steamid },
            |m: &mut CMsgGCNameItemNotification| { &mut m.player_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCNameItemNotification| { &m.item_def_index },
            |m: &mut CMsgGCNameItemNotification| { &mut m.item_def_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_name_custom",
            |m: &CMsgGCNameItemNotification| { &m.item_name_custom },
            |m: &mut CMsgGCNameItemNotification| { &mut m.item_name_custom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCNameItemNotification>(
            "CMsgGCNameItemNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCNameItemNotification {
    const NAME: &'static str = "CMsgGCNameItemNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.item_name_custom = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.item_def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_name_custom.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNameItemNotification {
        CMsgGCNameItemNotification::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.item_def_index = ::std::option::Option::None;
        self.item_name_custom = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNameItemNotification {
        static instance: CMsgGCNameItemNotification = CMsgGCNameItemNotification {
            player_steamid: ::std::option::Option::None,
            item_def_index: ::std::option::Option::None,
            item_name_custom: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCNameItemNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCNameItemNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCNameItemNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCNameItemNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientDisplayNotification)
pub struct CMsgGCClientDisplayNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_title_localization_key)
    pub notification_title_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.notification_body_localization_key)
    pub notification_body_localization_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_keys)
    pub body_substring_keys: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCClientDisplayNotification.body_substring_values)
    pub body_substring_values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientDisplayNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientDisplayNotification {
    fn default() -> &'a CMsgGCClientDisplayNotification {
        <CMsgGCClientDisplayNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientDisplayNotification {
    pub fn new() -> CMsgGCClientDisplayNotification {
        ::std::default::Default::default()
    }

    // optional string notification_title_localization_key = 1;

    pub fn notification_title_localization_key(&self) -> &str {
        match self.notification_title_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_title_localization_key(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_title_localization_key(&self) -> bool {
        self.notification_title_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_title_localization_key(&mut self, v: ::std::string::String) {
        self.notification_title_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_title_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_title_localization_key.is_none() {
            self.notification_title_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_title_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_title_localization_key(&mut self) -> ::std::string::String {
        self.notification_title_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string notification_body_localization_key = 2;

    pub fn notification_body_localization_key(&self) -> &str {
        match self.notification_body_localization_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_body_localization_key(&mut self) {
        self.notification_body_localization_key = ::std::option::Option::None;
    }

    pub fn has_notification_body_localization_key(&self) -> bool {
        self.notification_body_localization_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_body_localization_key(&mut self, v: ::std::string::String) {
        self.notification_body_localization_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_body_localization_key(&mut self) -> &mut ::std::string::String {
        if self.notification_body_localization_key.is_none() {
            self.notification_body_localization_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_body_localization_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_body_localization_key(&mut self) -> ::std::string::String {
        self.notification_body_localization_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_title_localization_key",
            |m: &CMsgGCClientDisplayNotification| { &m.notification_title_localization_key },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_title_localization_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "notification_body_localization_key",
            |m: &CMsgGCClientDisplayNotification| { &m.notification_body_localization_key },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.notification_body_localization_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_substring_keys",
            |m: &CMsgGCClientDisplayNotification| { &m.body_substring_keys },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "body_substring_values",
            |m: &CMsgGCClientDisplayNotification| { &m.body_substring_values },
            |m: &mut CMsgGCClientDisplayNotification| { &mut m.body_substring_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientDisplayNotification>(
            "CMsgGCClientDisplayNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientDisplayNotification {
    const NAME: &'static str = "CMsgGCClientDisplayNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notification_title_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.notification_body_localization_key = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.body_substring_keys.push(is.read_string()?);
                },
                34 => {
                    self.body_substring_values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.body_substring_keys {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.body_substring_values {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.notification_title_localization_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.notification_body_localization_key.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.body_substring_keys {
            os.write_string(3, &v)?;
        };
        for v in &self.body_substring_values {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientDisplayNotification {
        CMsgGCClientDisplayNotification::new()
    }

    fn clear(&mut self) {
        self.notification_title_localization_key = ::std::option::Option::None;
        self.notification_body_localization_key = ::std::option::Option::None;
        self.body_substring_keys.clear();
        self.body_substring_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientDisplayNotification {
        static instance: CMsgGCClientDisplayNotification = CMsgGCClientDisplayNotification {
            notification_title_localization_key: ::std::option::Option::None,
            notification_body_localization_key: ::std::option::Option::None,
            body_substring_keys: ::std::vec::Vec::new(),
            body_substring_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientDisplayNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientDisplayNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientDisplayNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientDisplayNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCShowItemsPickedUp)
pub struct CMsgGCShowItemsPickedUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCShowItemsPickedUp.player_steamid)
    pub player_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCShowItemsPickedUp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCShowItemsPickedUp {
    fn default() -> &'a CMsgGCShowItemsPickedUp {
        <CMsgGCShowItemsPickedUp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCShowItemsPickedUp {
    pub fn new() -> CMsgGCShowItemsPickedUp {
        ::std::default::Default::default()
    }

    // optional fixed64 player_steamid = 1;

    pub fn player_steamid(&self) -> u64 {
        self.player_steamid.unwrap_or(0)
    }

    pub fn clear_player_steamid(&mut self) {
        self.player_steamid = ::std::option::Option::None;
    }

    pub fn has_player_steamid(&self) -> bool {
        self.player_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_steamid(&mut self, v: u64) {
        self.player_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_steamid",
            |m: &CMsgGCShowItemsPickedUp| { &m.player_steamid },
            |m: &mut CMsgGCShowItemsPickedUp| { &mut m.player_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCShowItemsPickedUp>(
            "CMsgGCShowItemsPickedUp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCShowItemsPickedUp {
    const NAME: &'static str = "CMsgGCShowItemsPickedUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.player_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCShowItemsPickedUp {
        CMsgGCShowItemsPickedUp::new()
    }

    fn clear(&mut self) {
        self.player_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCShowItemsPickedUp {
        static instance: CMsgGCShowItemsPickedUp = CMsgGCShowItemsPickedUp {
            player_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCShowItemsPickedUp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCShowItemsPickedUp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCShowItemsPickedUp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCShowItemsPickedUp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCIncrementKillCountResponse)
pub struct CMsgGCIncrementKillCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.num_kills)
    pub num_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCIncrementKillCountResponse.level_type)
    pub level_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCIncrementKillCountResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCIncrementKillCountResponse {
    fn default() -> &'a CMsgGCIncrementKillCountResponse {
        <CMsgGCIncrementKillCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCIncrementKillCountResponse {
    pub fn new() -> CMsgGCIncrementKillCountResponse {
        ::std::default::Default::default()
    }

    // optional uint32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 num_kills = 2;

    pub fn num_kills(&self) -> u32 {
        self.num_kills.unwrap_or(0)
    }

    pub fn clear_num_kills(&mut self) {
        self.num_kills = ::std::option::Option::None;
    }

    pub fn has_num_kills(&self) -> bool {
        self.num_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_kills(&mut self, v: u32) {
        self.num_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 3;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 level_type = 4;

    pub fn level_type(&self) -> u32 {
        self.level_type.unwrap_or(0)
    }

    pub fn clear_level_type(&mut self) {
        self.level_type = ::std::option::Option::None;
    }

    pub fn has_level_type(&self) -> bool {
        self.level_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_type(&mut self, v: u32) {
        self.level_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killer_account_id",
            |m: &CMsgGCIncrementKillCountResponse| { &m.killer_account_id },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.killer_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_kills",
            |m: &CMsgGCIncrementKillCountResponse| { &m.num_kills },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.num_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def",
            |m: &CMsgGCIncrementKillCountResponse| { &m.item_def },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.item_def },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "level_type",
            |m: &CMsgGCIncrementKillCountResponse| { &m.level_type },
            |m: &mut CMsgGCIncrementKillCountResponse| { &mut m.level_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCIncrementKillCountResponse>(
            "CMsgGCIncrementKillCountResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCIncrementKillCountResponse {
    const NAME: &'static str = "CMsgGCIncrementKillCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.level_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_kills {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.level_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_kills {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.level_type {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCIncrementKillCountResponse {
        CMsgGCIncrementKillCountResponse::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.num_kills = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.level_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCIncrementKillCountResponse {
        static instance: CMsgGCIncrementKillCountResponse = CMsgGCIncrementKillCountResponse {
            killer_account_id: ::std::option::Option::None,
            num_kills: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            level_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCIncrementKillCountResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCIncrementKillCountResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCIncrementKillCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCIncrementKillCountResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemDropRateBonus)
pub struct CSOEconItemDropRateBonus {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.expiration_date)
    pub expiration_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.bonus)
    pub bonus: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.bonus_count)
    pub bonus_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItemDropRateBonus.def_index)
    pub def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemDropRateBonus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemDropRateBonus {
    fn default() -> &'a CSOEconItemDropRateBonus {
        <CSOEconItemDropRateBonus as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemDropRateBonus {
    pub fn new() -> CSOEconItemDropRateBonus {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 2;

    pub fn expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    // optional float bonus = 3;

    pub fn bonus(&self) -> f32 {
        self.bonus.unwrap_or(0.)
    }

    pub fn clear_bonus(&mut self) {
        self.bonus = ::std::option::Option::None;
    }

    pub fn has_bonus(&self) -> bool {
        self.bonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus(&mut self, v: f32) {
        self.bonus = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_count = 4;

    pub fn bonus_count(&self) -> u32 {
        self.bonus_count.unwrap_or(0)
    }

    pub fn clear_bonus_count(&mut self) {
        self.bonus_count = ::std::option::Option::None;
    }

    pub fn has_bonus_count(&self) -> bool {
        self.bonus_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_count(&mut self, v: u32) {
        self.bonus_count = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 5;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 6;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItemDropRateBonus| { &m.account_id },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_date",
            |m: &CSOEconItemDropRateBonus| { &m.expiration_date },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.expiration_date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus",
            |m: &CSOEconItemDropRateBonus| { &m.bonus },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_count",
            |m: &CSOEconItemDropRateBonus| { &m.bonus_count },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.bonus_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconItemDropRateBonus| { &m.item_id },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "def_index",
            |m: &CSOEconItemDropRateBonus| { &m.def_index },
            |m: &mut CSOEconItemDropRateBonus| { &mut m.def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemDropRateBonus>(
            "CSOEconItemDropRateBonus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemDropRateBonus {
    const NAME: &'static str = "CSOEconItemDropRateBonus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.expiration_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                29 => {
                    self.bonus = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.bonus_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.expiration_date {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus {
            my_size += 1 + 4;
        }
        if let Some(v) = self.bonus_count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.bonus {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.bonus_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemDropRateBonus {
        CSOEconItemDropRateBonus::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.bonus = ::std::option::Option::None;
        self.bonus_count = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemDropRateBonus {
        static instance: CSOEconItemDropRateBonus = CSOEconItemDropRateBonus {
            account_id: ::std::option::Option::None,
            expiration_date: ::std::option::Option::None,
            bonus: ::std::option::Option::None,
            bonus_count: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemDropRateBonus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemDropRateBonus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemDropRateBonus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemDropRateBonus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemLeagueViewPass)
pub struct CSOEconItemLeagueViewPass {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemLeagueViewPass.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemLeagueViewPass.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemLeagueViewPass.admin)
    pub admin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemLeagueViewPass.itemindex)
    pub itemindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemLeagueViewPass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemLeagueViewPass {
    fn default() -> &'a CSOEconItemLeagueViewPass {
        <CSOEconItemLeagueViewPass as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemLeagueViewPass {
    pub fn new() -> CSOEconItemLeagueViewPass {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 admin = 3;

    pub fn admin(&self) -> u32 {
        self.admin.unwrap_or(0)
    }

    pub fn clear_admin(&mut self) {
        self.admin = ::std::option::Option::None;
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: u32) {
        self.admin = ::std::option::Option::Some(v);
    }

    // optional uint32 itemindex = 4;

    pub fn itemindex(&self) -> u32 {
        self.itemindex.unwrap_or(0)
    }

    pub fn clear_itemindex(&mut self) {
        self.itemindex = ::std::option::Option::None;
    }

    pub fn has_itemindex(&self) -> bool {
        self.itemindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemindex(&mut self, v: u32) {
        self.itemindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItemLeagueViewPass| { &m.account_id },
            |m: &mut CSOEconItemLeagueViewPass| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CSOEconItemLeagueViewPass| { &m.league_id },
            |m: &mut CSOEconItemLeagueViewPass| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "admin",
            |m: &CSOEconItemLeagueViewPass| { &m.admin },
            |m: &mut CSOEconItemLeagueViewPass| { &mut m.admin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemindex",
            |m: &CSOEconItemLeagueViewPass| { &m.itemindex },
            |m: &mut CSOEconItemLeagueViewPass| { &mut m.itemindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemLeagueViewPass>(
            "CSOEconItemLeagueViewPass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemLeagueViewPass {
    const NAME: &'static str = "CSOEconItemLeagueViewPass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.admin = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.itemindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.admin {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.itemindex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.admin {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.itemindex {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemLeagueViewPass {
        CSOEconItemLeagueViewPass::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.admin = ::std::option::Option::None;
        self.itemindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemLeagueViewPass {
        static instance: CSOEconItemLeagueViewPass = CSOEconItemLeagueViewPass {
            account_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            admin: ::std::option::Option::None,
            itemindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemLeagueViewPass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemLeagueViewPass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemLeagueViewPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemLeagueViewPass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconItemEventTicket)
pub struct CSOEconItemEventTicket {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemEventTicket.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEventTicket.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEventTicket.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemEventTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEventTicket {
    fn default() -> &'a CSOEconItemEventTicket {
        <CSOEconItemEventTicket as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEventTicket {
    pub fn new() -> CSOEconItemEventTicket {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconItemEventTicket| { &m.account_id },
            |m: &mut CSOEconItemEventTicket| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CSOEconItemEventTicket| { &m.event_id },
            |m: &mut CSOEconItemEventTicket| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconItemEventTicket| { &m.item_id },
            |m: &mut CSOEconItemEventTicket| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconItemEventTicket>(
            "CSOEconItemEventTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconItemEventTicket {
    const NAME: &'static str = "CSOEconItemEventTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEventTicket {
        CSOEconItemEventTicket::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEventTicket {
        static instance: CSOEconItemEventTicket = CSOEconItemEventTicket {
            account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconItemEventTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconItemEventTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconItemEventTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconItemEventTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCItemPreviewItemBoughtNotification)
pub struct CMsgGCItemPreviewItemBoughtNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemPreviewItemBoughtNotification.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemPreviewItemBoughtNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemPreviewItemBoughtNotification {
    fn default() -> &'a CMsgGCItemPreviewItemBoughtNotification {
        <CMsgGCItemPreviewItemBoughtNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemPreviewItemBoughtNotification {
    pub fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_def_index",
            |m: &CMsgGCItemPreviewItemBoughtNotification| { &m.item_def_index },
            |m: &mut CMsgGCItemPreviewItemBoughtNotification| { &mut m.item_def_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCItemPreviewItemBoughtNotification>(
            "CMsgGCItemPreviewItemBoughtNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCItemPreviewItemBoughtNotification {
    const NAME: &'static str = "CMsgGCItemPreviewItemBoughtNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemPreviewItemBoughtNotification {
        CMsgGCItemPreviewItemBoughtNotification::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemPreviewItemBoughtNotification {
        static instance: CMsgGCItemPreviewItemBoughtNotification = CMsgGCItemPreviewItemBoughtNotification {
            item_def_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCItemPreviewItemBoughtNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCItemPreviewItemBoughtNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCItemPreviewItemBoughtNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCItemPreviewItemBoughtNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancel)
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancel.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseCancel| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseCancel| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancel>(
            "CMsgGCStorePurchaseCancel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancel {
    const NAME: &'static str = "CMsgGCStorePurchaseCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: CMsgGCStorePurchaseCancel = CMsgGCStorePurchaseCancel {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancelResponse)
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancelResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseCancelResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseCancelResponse| { &mut m.result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseCancelResponse>(
            "CMsgGCStorePurchaseCancelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseCancelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: CMsgGCStorePurchaseCancelResponse = CMsgGCStorePurchaseCancelResponse {
            result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseCancelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseCancelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseCancelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseCancelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalize)
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalize.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalize.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_id",
            |m: &CMsgGCStorePurchaseFinalize| { &m.txn_id },
            |m: &mut CMsgGCStorePurchaseFinalize| { &mut m.txn_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalize>(
            "CMsgGCStorePurchaseFinalize",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalize {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: CMsgGCStorePurchaseFinalize = CMsgGCStorePurchaseFinalize {
            txn_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalize {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalize").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalize {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalize {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalizeResponse)
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalizeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.result },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_ids",
            |m: &CMsgGCStorePurchaseFinalizeResponse| { &m.item_ids },
            |m: &mut CMsgGCStorePurchaseFinalizeResponse| { &mut m.item_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCStorePurchaseFinalizeResponse>(
            "CMsgGCStorePurchaseFinalizeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: CMsgGCStorePurchaseFinalizeResponse = CMsgGCStorePurchaseFinalizeResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCStorePurchaseFinalizeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCStorePurchaseFinalizeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCStorePurchaseFinalizeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCStorePurchaseFinalizeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCBannedWordListRequest)
pub struct CMsgGCBannedWordListRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.ban_list_group_id)
    pub ban_list_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBannedWordListRequest.word_id)
    pub word_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBannedWordListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListRequest {
    fn default() -> &'a CMsgGCBannedWordListRequest {
        <CMsgGCBannedWordListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListRequest {
    pub fn new() -> CMsgGCBannedWordListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;

    pub fn ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }

    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 word_id = 2;

    pub fn word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }

    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_list_group_id",
            |m: &CMsgGCBannedWordListRequest| { &m.ban_list_group_id },
            |m: &mut CMsgGCBannedWordListRequest| { &mut m.ban_list_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word_id",
            |m: &CMsgGCBannedWordListRequest| { &m.word_id },
            |m: &mut CMsgGCBannedWordListRequest| { &mut m.word_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBannedWordListRequest>(
            "CMsgGCBannedWordListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListRequest {
    const NAME: &'static str = "CMsgGCBannedWordListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ban_list_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.word_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBannedWordListRequest {
        CMsgGCBannedWordListRequest::new()
    }

    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBannedWordListRequest {
        static instance: CMsgGCBannedWordListRequest = CMsgGCBannedWordListRequest {
            ban_list_group_id: ::std::option::Option::None,
            word_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBannedWordListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBannedWordListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBannedWordListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRequestAnnouncements)
pub struct CMsgGCRequestAnnouncements {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestAnnouncements.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestAnnouncements {
    fn default() -> &'a CMsgGCRequestAnnouncements {
        <CMsgGCRequestAnnouncements as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestAnnouncements {
    pub fn new() -> CMsgGCRequestAnnouncements {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestAnnouncements>(
            "CMsgGCRequestAnnouncements",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestAnnouncements {
    const NAME: &'static str = "CMsgGCRequestAnnouncements";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestAnnouncements {
        CMsgGCRequestAnnouncements::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestAnnouncements {
        static instance: CMsgGCRequestAnnouncements = CMsgGCRequestAnnouncements {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestAnnouncements {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestAnnouncements").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestAnnouncements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestAnnouncements {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCRequestAnnouncementsResponse)
pub struct CMsgGCRequestAnnouncementsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestAnnouncementsResponse.announcement_title)
    pub announcement_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCRequestAnnouncementsResponse.announcement)
    pub announcement: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCRequestAnnouncementsResponse.nextmatch_title)
    pub nextmatch_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCRequestAnnouncementsResponse.nextmatch)
    pub nextmatch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestAnnouncementsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestAnnouncementsResponse {
    fn default() -> &'a CMsgGCRequestAnnouncementsResponse {
        <CMsgGCRequestAnnouncementsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestAnnouncementsResponse {
    pub fn new() -> CMsgGCRequestAnnouncementsResponse {
        ::std::default::Default::default()
    }

    // optional string announcement_title = 1;

    pub fn announcement_title(&self) -> &str {
        match self.announcement_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement_title(&mut self) {
        self.announcement_title = ::std::option::Option::None;
    }

    pub fn has_announcement_title(&self) -> bool {
        self.announcement_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_title(&mut self, v: ::std::string::String) {
        self.announcement_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_title(&mut self) -> &mut ::std::string::String {
        if self.announcement_title.is_none() {
            self.announcement_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.announcement_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_title(&mut self) -> ::std::string::String {
        self.announcement_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string announcement = 2;

    pub fn announcement(&self) -> &str {
        match self.announcement.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_announcement(&mut self) {
        self.announcement = ::std::option::Option::None;
    }

    pub fn has_announcement(&self) -> bool {
        self.announcement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: ::std::string::String) {
        self.announcement = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement(&mut self) -> &mut ::std::string::String {
        if self.announcement.is_none() {
            self.announcement = ::std::option::Option::Some(::std::string::String::new());
        }
        self.announcement.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement(&mut self) -> ::std::string::String {
        self.announcement.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nextmatch_title = 3;

    pub fn nextmatch_title(&self) -> &str {
        match self.nextmatch_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nextmatch_title(&mut self) {
        self.nextmatch_title = ::std::option::Option::None;
    }

    pub fn has_nextmatch_title(&self) -> bool {
        self.nextmatch_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextmatch_title(&mut self, v: ::std::string::String) {
        self.nextmatch_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nextmatch_title(&mut self) -> &mut ::std::string::String {
        if self.nextmatch_title.is_none() {
            self.nextmatch_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nextmatch_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_nextmatch_title(&mut self) -> ::std::string::String {
        self.nextmatch_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nextmatch = 4;

    pub fn nextmatch(&self) -> &str {
        match self.nextmatch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nextmatch(&mut self) {
        self.nextmatch = ::std::option::Option::None;
    }

    pub fn has_nextmatch(&self) -> bool {
        self.nextmatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nextmatch(&mut self, v: ::std::string::String) {
        self.nextmatch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nextmatch(&mut self) -> &mut ::std::string::String {
        if self.nextmatch.is_none() {
            self.nextmatch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nextmatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_nextmatch(&mut self) -> ::std::string::String {
        self.nextmatch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "announcement_title",
            |m: &CMsgGCRequestAnnouncementsResponse| { &m.announcement_title },
            |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.announcement_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "announcement",
            |m: &CMsgGCRequestAnnouncementsResponse| { &m.announcement },
            |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.announcement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextmatch_title",
            |m: &CMsgGCRequestAnnouncementsResponse| { &m.nextmatch_title },
            |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.nextmatch_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nextmatch",
            |m: &CMsgGCRequestAnnouncementsResponse| { &m.nextmatch },
            |m: &mut CMsgGCRequestAnnouncementsResponse| { &mut m.nextmatch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestAnnouncementsResponse>(
            "CMsgGCRequestAnnouncementsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestAnnouncementsResponse {
    const NAME: &'static str = "CMsgGCRequestAnnouncementsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.announcement_title = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.announcement = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.nextmatch_title = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nextmatch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.announcement_title.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.announcement.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.nextmatch_title.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nextmatch.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.announcement_title.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.announcement.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.nextmatch_title.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nextmatch.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestAnnouncementsResponse {
        CMsgGCRequestAnnouncementsResponse::new()
    }

    fn clear(&mut self) {
        self.announcement_title = ::std::option::Option::None;
        self.announcement = ::std::option::Option::None;
        self.nextmatch_title = ::std::option::Option::None;
        self.nextmatch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestAnnouncementsResponse {
        static instance: CMsgGCRequestAnnouncementsResponse = CMsgGCRequestAnnouncementsResponse {
            announcement_title: ::std::option::Option::None,
            announcement: ::std::option::Option::None,
            nextmatch_title: ::std::option::Option::None,
            nextmatch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestAnnouncementsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestAnnouncementsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestAnnouncementsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestAnnouncementsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCBannedWord)
pub struct CMsgGCBannedWord {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBannedWord.word_id)
    pub word_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBannedWord.word_type)
    pub word_type: ::std::option::Option<::protobuf::EnumOrUnknown<GC_BannedWordType>>,
    // @@protoc_insertion_point(field:CMsgGCBannedWord.word)
    pub word: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBannedWord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWord {
    fn default() -> &'a CMsgGCBannedWord {
        <CMsgGCBannedWord as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWord {
    pub fn new() -> CMsgGCBannedWord {
        ::std::default::Default::default()
    }

    // optional uint32 word_id = 1;

    pub fn word_id(&self) -> u32 {
        self.word_id.unwrap_or(0)
    }

    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: u32) {
        self.word_id = ::std::option::Option::Some(v);
    }

    // optional .GC_BannedWordType word_type = 2;

    pub fn word_type(&self) -> GC_BannedWordType {
        match self.word_type {
            Some(e) => e.enum_value_or(GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD),
            None => GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD,
        }
    }

    pub fn clear_word_type(&mut self) {
        self.word_type = ::std::option::Option::None;
    }

    pub fn has_word_type(&self) -> bool {
        self.word_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_type(&mut self, v: GC_BannedWordType) {
        self.word_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string word = 3;

    pub fn word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_word(&mut self) {
        self.word = ::std::option::Option::None;
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word_id",
            |m: &CMsgGCBannedWord| { &m.word_id },
            |m: &mut CMsgGCBannedWord| { &mut m.word_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word_type",
            |m: &CMsgGCBannedWord| { &m.word_type },
            |m: &mut CMsgGCBannedWord| { &mut m.word_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "word",
            |m: &CMsgGCBannedWord| { &m.word },
            |m: &mut CMsgGCBannedWord| { &mut m.word },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBannedWord>(
            "CMsgGCBannedWord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBannedWord {
    const NAME: &'static str = "CMsgGCBannedWord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.word_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.word_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.word = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.word_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.word.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.word_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.word_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.word.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBannedWord {
        CMsgGCBannedWord::new()
    }

    fn clear(&mut self) {
        self.word_id = ::std::option::Option::None;
        self.word_type = ::std::option::Option::None;
        self.word = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBannedWord {
        static instance: CMsgGCBannedWord = CMsgGCBannedWord {
            word_id: ::std::option::Option::None,
            word_type: ::std::option::Option::None,
            word: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBannedWord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBannedWord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBannedWord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCBannedWordListResponse)
pub struct CMsgGCBannedWordListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBannedWordListResponse.ban_list_group_id)
    pub ban_list_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBannedWordListResponse.word_list)
    pub word_list: ::std::vec::Vec<CMsgGCBannedWord>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBannedWordListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBannedWordListResponse {
    fn default() -> &'a CMsgGCBannedWordListResponse {
        <CMsgGCBannedWordListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBannedWordListResponse {
    pub fn new() -> CMsgGCBannedWordListResponse {
        ::std::default::Default::default()
    }

    // optional uint32 ban_list_group_id = 1;

    pub fn ban_list_group_id(&self) -> u32 {
        self.ban_list_group_id.unwrap_or(0)
    }

    pub fn clear_ban_list_group_id(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
    }

    pub fn has_ban_list_group_id(&self) -> bool {
        self.ban_list_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_list_group_id(&mut self, v: u32) {
        self.ban_list_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_list_group_id",
            |m: &CMsgGCBannedWordListResponse| { &m.ban_list_group_id },
            |m: &mut CMsgGCBannedWordListResponse| { &mut m.ban_list_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "word_list",
            |m: &CMsgGCBannedWordListResponse| { &m.word_list },
            |m: &mut CMsgGCBannedWordListResponse| { &mut m.word_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCBannedWordListResponse>(
            "CMsgGCBannedWordListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCBannedWordListResponse {
    const NAME: &'static str = "CMsgGCBannedWordListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ban_list_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.word_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ban_list_group_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.word_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ban_list_group_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.word_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBannedWordListResponse {
        CMsgGCBannedWordListResponse::new()
    }

    fn clear(&mut self) {
        self.ban_list_group_id = ::std::option::Option::None;
        self.word_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBannedWordListResponse {
        static instance: CMsgGCBannedWordListResponse = CMsgGCBannedWordListResponse {
            ban_list_group_id: ::std::option::Option::None,
            word_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCBannedWordListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCBannedWordListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCBannedWordListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCBannedWordListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCBannedWordListBroadcast)
pub struct CMsgGCToGCBannedWordListBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBannedWordListBroadcast.broadcast)
    pub broadcast: ::protobuf::MessageField<CMsgGCBannedWordListResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBannedWordListBroadcast.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListBroadcast {
    fn default() -> &'a CMsgGCToGCBannedWordListBroadcast {
        <CMsgGCToGCBannedWordListBroadcast as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListBroadcast {
    pub fn new() -> CMsgGCToGCBannedWordListBroadcast {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCBannedWordListResponse>(
            "broadcast",
            |m: &CMsgGCToGCBannedWordListBroadcast| { &m.broadcast },
            |m: &mut CMsgGCToGCBannedWordListBroadcast| { &mut m.broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBannedWordListBroadcast>(
            "CMsgGCToGCBannedWordListBroadcast",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBannedWordListBroadcast {
    const NAME: &'static str = "CMsgGCToGCBannedWordListBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.broadcast.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBannedWordListBroadcast {
        CMsgGCToGCBannedWordListBroadcast::new()
    }

    fn clear(&mut self) {
        self.broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListBroadcast {
        static instance: CMsgGCToGCBannedWordListBroadcast = CMsgGCToGCBannedWordListBroadcast {
            broadcast: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBannedWordListBroadcast {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBannedWordListBroadcast").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBannedWordListBroadcast {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBannedWordListBroadcast {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCBannedWordListUpdated)
pub struct CMsgGCToGCBannedWordListUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBannedWordListUpdated.group_id)
    pub group_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBannedWordListUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListUpdated {
    fn default() -> &'a CMsgGCToGCBannedWordListUpdated {
        <CMsgGCToGCBannedWordListUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListUpdated {
    pub fn new() -> CMsgGCToGCBannedWordListUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 group_id = 1;

    pub fn group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "group_id",
            |m: &CMsgGCToGCBannedWordListUpdated| { &m.group_id },
            |m: &mut CMsgGCToGCBannedWordListUpdated| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBannedWordListUpdated>(
            "CMsgGCToGCBannedWordListUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBannedWordListUpdated {
    const NAME: &'static str = "CMsgGCToGCBannedWordListUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBannedWordListUpdated {
        CMsgGCToGCBannedWordListUpdated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListUpdated {
        static instance: CMsgGCToGCBannedWordListUpdated = CMsgGCToGCBannedWordListUpdated {
            group_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBannedWordListUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBannedWordListUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBannedWordListUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBannedWordListUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconDefaultEquippedDefinitionInstanceClient)
pub struct CSOEconDefaultEquippedDefinitionInstanceClient {
    // message fields
    // @@protoc_insertion_point(field:CSOEconDefaultEquippedDefinitionInstanceClient.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconDefaultEquippedDefinitionInstanceClient.item_definition)
    pub item_definition: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconDefaultEquippedDefinitionInstanceClient.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconDefaultEquippedDefinitionInstanceClient.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconDefaultEquippedDefinitionInstanceClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconDefaultEquippedDefinitionInstanceClient {
    fn default() -> &'a CSOEconDefaultEquippedDefinitionInstanceClient {
        <CSOEconDefaultEquippedDefinitionInstanceClient as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconDefaultEquippedDefinitionInstanceClient {
    pub fn new() -> CSOEconDefaultEquippedDefinitionInstanceClient {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_definition = 2;

    pub fn item_definition(&self) -> u32 {
        self.item_definition.unwrap_or(0)
    }

    pub fn clear_item_definition(&mut self) {
        self.item_definition = ::std::option::Option::None;
    }

    pub fn has_item_definition(&self) -> bool {
        self.item_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition(&mut self, v: u32) {
        self.item_definition = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 3;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 4;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.account_id },
            |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_definition",
            |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.item_definition },
            |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.item_definition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.class_id },
            |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CSOEconDefaultEquippedDefinitionInstanceClient| { &m.slot_id },
            |m: &mut CSOEconDefaultEquippedDefinitionInstanceClient| { &mut m.slot_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconDefaultEquippedDefinitionInstanceClient>(
            "CSOEconDefaultEquippedDefinitionInstanceClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconDefaultEquippedDefinitionInstanceClient {
    const NAME: &'static str = "CSOEconDefaultEquippedDefinitionInstanceClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_definition = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_definition {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_definition {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconDefaultEquippedDefinitionInstanceClient {
        CSOEconDefaultEquippedDefinitionInstanceClient::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_definition = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconDefaultEquippedDefinitionInstanceClient {
        static instance: CSOEconDefaultEquippedDefinitionInstanceClient = CSOEconDefaultEquippedDefinitionInstanceClient {
            account_id: ::std::option::Option::None,
            item_definition: ::std::option::Option::None,
            class_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconDefaultEquippedDefinitionInstanceClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconDefaultEquippedDefinitionInstanceClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconDefaultEquippedDefinitionInstanceClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCDirtySDOCache)
pub struct CMsgGCToGCDirtySDOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCDirtySDOCache.sdo_type)
    pub sdo_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCDirtySDOCache.key_uint64)
    pub key_uint64: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCDirtySDOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtySDOCache {
    fn default() -> &'a CMsgGCToGCDirtySDOCache {
        <CMsgGCToGCDirtySDOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtySDOCache {
    pub fn new() -> CMsgGCToGCDirtySDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;

    pub fn sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    // optional uint64 key_uint64 = 2;

    pub fn key_uint64(&self) -> u64 {
        self.key_uint64.unwrap_or(0)
    }

    pub fn clear_key_uint64(&mut self) {
        self.key_uint64 = ::std::option::Option::None;
    }

    pub fn has_key_uint64(&self) -> bool {
        self.key_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_uint64(&mut self, v: u64) {
        self.key_uint64 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdo_type",
            |m: &CMsgGCToGCDirtySDOCache| { &m.sdo_type },
            |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.sdo_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_uint64",
            |m: &CMsgGCToGCDirtySDOCache| { &m.key_uint64 },
            |m: &mut CMsgGCToGCDirtySDOCache| { &mut m.key_uint64 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCDirtySDOCache>(
            "CMsgGCToGCDirtySDOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCDirtySDOCache {
    const NAME: &'static str = "CMsgGCToGCDirtySDOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.key_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key_uint64 {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key_uint64 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCDirtySDOCache {
        CMsgGCToGCDirtySDOCache::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCDirtySDOCache {
        static instance: CMsgGCToGCDirtySDOCache = CMsgGCToGCDirtySDOCache {
            sdo_type: ::std::option::Option::None,
            key_uint64: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCDirtySDOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCDirtySDOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCDirtySDOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCDirtySDOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCDirtyMultipleSDOCache)
pub struct CMsgGCToGCDirtyMultipleSDOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCDirtyMultipleSDOCache.sdo_type)
    pub sdo_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCDirtyMultipleSDOCache.key_uint64)
    pub key_uint64: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCDirtyMultipleSDOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtyMultipleSDOCache {
    fn default() -> &'a CMsgGCToGCDirtyMultipleSDOCache {
        <CMsgGCToGCDirtyMultipleSDOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtyMultipleSDOCache {
    pub fn new() -> CMsgGCToGCDirtyMultipleSDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;

    pub fn sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdo_type",
            |m: &CMsgGCToGCDirtyMultipleSDOCache| { &m.sdo_type },
            |m: &mut CMsgGCToGCDirtyMultipleSDOCache| { &mut m.sdo_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "key_uint64",
            |m: &CMsgGCToGCDirtyMultipleSDOCache| { &m.key_uint64 },
            |m: &mut CMsgGCToGCDirtyMultipleSDOCache| { &mut m.key_uint64 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCDirtyMultipleSDOCache>(
            "CMsgGCToGCDirtyMultipleSDOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCDirtyMultipleSDOCache {
    const NAME: &'static str = "CMsgGCToGCDirtyMultipleSDOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.key_uint64)?;
                },
                16 => {
                    self.key_uint64.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.key_uint64 {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        for v in &self.key_uint64 {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCDirtyMultipleSDOCache {
        CMsgGCToGCDirtyMultipleSDOCache::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCDirtyMultipleSDOCache {
        static instance: CMsgGCToGCDirtyMultipleSDOCache = CMsgGCToGCDirtyMultipleSDOCache {
            sdo_type: ::std::option::Option::None,
            key_uint64: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCDirtyMultipleSDOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCDirtyMultipleSDOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCDirtyMultipleSDOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCDirtyMultipleSDOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCollectItem)
pub struct CMsgGCCollectItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCollectItem.collection_item_id)
    pub collection_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCollectItem.subject_item_id)
    pub subject_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCollectItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCollectItem {
    fn default() -> &'a CMsgGCCollectItem {
        <CMsgGCCollectItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCollectItem {
    pub fn new() -> CMsgGCCollectItem {
        ::std::default::Default::default()
    }

    // optional uint64 collection_item_id = 1;

    pub fn collection_item_id(&self) -> u64 {
        self.collection_item_id.unwrap_or(0)
    }

    pub fn clear_collection_item_id(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
    }

    pub fn has_collection_item_id(&self) -> bool {
        self.collection_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_collection_item_id(&mut self, v: u64) {
        self.collection_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 subject_item_id = 2;

    pub fn subject_item_id(&self) -> u64 {
        self.subject_item_id.unwrap_or(0)
    }

    pub fn clear_subject_item_id(&mut self) {
        self.subject_item_id = ::std::option::Option::None;
    }

    pub fn has_subject_item_id(&self) -> bool {
        self.subject_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subject_item_id(&mut self, v: u64) {
        self.subject_item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "collection_item_id",
            |m: &CMsgGCCollectItem| { &m.collection_item_id },
            |m: &mut CMsgGCCollectItem| { &mut m.collection_item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subject_item_id",
            |m: &CMsgGCCollectItem| { &m.subject_item_id },
            |m: &mut CMsgGCCollectItem| { &mut m.subject_item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCollectItem>(
            "CMsgGCCollectItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCollectItem {
    const NAME: &'static str = "CMsgGCCollectItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.collection_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.subject_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.collection_item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.subject_item_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.collection_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.subject_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCollectItem {
        CMsgGCCollectItem::new()
    }

    fn clear(&mut self) {
        self.collection_item_id = ::std::option::Option::None;
        self.subject_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCollectItem {
        static instance: CMsgGCCollectItem = CMsgGCCollectItem {
            collection_item_id: ::std::option::Option::None,
            subject_item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCollectItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCollectItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCollectItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCollectItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgSDONoMemcached)
pub struct CMsgSDONoMemcached {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSDONoMemcached.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDONoMemcached {
    fn default() -> &'a CMsgSDONoMemcached {
        <CMsgSDONoMemcached as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSDONoMemcached {
    pub fn new() -> CMsgSDONoMemcached {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSDONoMemcached>(
            "CMsgSDONoMemcached",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSDONoMemcached {
    const NAME: &'static str = "CMsgSDONoMemcached";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDONoMemcached {
        CMsgSDONoMemcached::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDONoMemcached {
        static instance: CMsgSDONoMemcached = CMsgSDONoMemcached {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSDONoMemcached {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSDONoMemcached").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSDONoMemcached {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSDONoMemcached {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCUpdateSQLKeyValue)
pub struct CMsgGCToGCUpdateSQLKeyValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSQLKeyValue.key_name)
    pub key_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUpdateSQLKeyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSQLKeyValue {
    fn default() -> &'a CMsgGCToGCUpdateSQLKeyValue {
        <CMsgGCToGCUpdateSQLKeyValue as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSQLKeyValue {
    pub fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        ::std::default::Default::default()
    }

    // optional string key_name = 1;

    pub fn key_name(&self) -> &str {
        match self.key_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key_name(&mut self) {
        self.key_name = ::std::option::Option::None;
    }

    pub fn has_key_name(&self) -> bool {
        self.key_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_name(&mut self, v: ::std::string::String) {
        self.key_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_name(&mut self) -> &mut ::std::string::String {
        if self.key_name.is_none() {
            self.key_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_name(&mut self) -> ::std::string::String {
        self.key_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_name",
            |m: &CMsgGCToGCUpdateSQLKeyValue| { &m.key_name },
            |m: &mut CMsgGCToGCUpdateSQLKeyValue| { &mut m.key_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCUpdateSQLKeyValue>(
            "CMsgGCToGCUpdateSQLKeyValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCUpdateSQLKeyValue {
    const NAME: &'static str = "CMsgGCToGCUpdateSQLKeyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        CMsgGCToGCUpdateSQLKeyValue::new()
    }

    fn clear(&mut self) {
        self.key_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSQLKeyValue {
        static instance: CMsgGCToGCUpdateSQLKeyValue = CMsgGCToGCUpdateSQLKeyValue {
            key_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCUpdateSQLKeyValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCUpdateSQLKeyValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCUpdateSQLKeyValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCUpdateSQLKeyValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCIsTrustedServer)
pub struct CMsgGCToGCIsTrustedServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCIsTrustedServer.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCIsTrustedServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIsTrustedServer {
    fn default() -> &'a CMsgGCToGCIsTrustedServer {
        <CMsgGCToGCIsTrustedServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIsTrustedServer {
    pub fn new() -> CMsgGCToGCIsTrustedServer {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGCToGCIsTrustedServer| { &m.steam_id },
            |m: &mut CMsgGCToGCIsTrustedServer| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCIsTrustedServer>(
            "CMsgGCToGCIsTrustedServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCIsTrustedServer {
    const NAME: &'static str = "CMsgGCToGCIsTrustedServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCIsTrustedServer {
        CMsgGCToGCIsTrustedServer::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCIsTrustedServer {
        static instance: CMsgGCToGCIsTrustedServer = CMsgGCToGCIsTrustedServer {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCIsTrustedServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCIsTrustedServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCIsTrustedServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIsTrustedServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCIsTrustedServerResponse)
pub struct CMsgGCToGCIsTrustedServerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCIsTrustedServerResponse.is_trusted)
    pub is_trusted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCIsTrustedServerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCIsTrustedServerResponse {
    fn default() -> &'a CMsgGCToGCIsTrustedServerResponse {
        <CMsgGCToGCIsTrustedServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCIsTrustedServerResponse {
    pub fn new() -> CMsgGCToGCIsTrustedServerResponse {
        ::std::default::Default::default()
    }

    // optional bool is_trusted = 1;

    pub fn is_trusted(&self) -> bool {
        self.is_trusted.unwrap_or(false)
    }

    pub fn clear_is_trusted(&mut self) {
        self.is_trusted = ::std::option::Option::None;
    }

    pub fn has_is_trusted(&self) -> bool {
        self.is_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_trusted(&mut self, v: bool) {
        self.is_trusted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_trusted",
            |m: &CMsgGCToGCIsTrustedServerResponse| { &m.is_trusted },
            |m: &mut CMsgGCToGCIsTrustedServerResponse| { &mut m.is_trusted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCIsTrustedServerResponse>(
            "CMsgGCToGCIsTrustedServerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCIsTrustedServerResponse {
    const NAME: &'static str = "CMsgGCToGCIsTrustedServerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_trusted {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_trusted {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCIsTrustedServerResponse {
        CMsgGCToGCIsTrustedServerResponse::new()
    }

    fn clear(&mut self) {
        self.is_trusted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCIsTrustedServerResponse {
        static instance: CMsgGCToGCIsTrustedServerResponse = CMsgGCToGCIsTrustedServerResponse {
            is_trusted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCIsTrustedServerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCIsTrustedServerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCIsTrustedServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCIsTrustedServerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCBroadcastConsoleCommand)
pub struct CMsgGCToGCBroadcastConsoleCommand {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBroadcastConsoleCommand.con_command)
    pub con_command: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBroadcastConsoleCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBroadcastConsoleCommand {
    fn default() -> &'a CMsgGCToGCBroadcastConsoleCommand {
        <CMsgGCToGCBroadcastConsoleCommand as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBroadcastConsoleCommand {
    pub fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        ::std::default::Default::default()
    }

    // optional string con_command = 1;

    pub fn con_command(&self) -> &str {
        match self.con_command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_con_command(&mut self) {
        self.con_command = ::std::option::Option::None;
    }

    pub fn has_con_command(&self) -> bool {
        self.con_command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_con_command(&mut self, v: ::std::string::String) {
        self.con_command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_con_command(&mut self) -> &mut ::std::string::String {
        if self.con_command.is_none() {
            self.con_command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.con_command.as_mut().unwrap()
    }

    // Take field
    pub fn take_con_command(&mut self) -> ::std::string::String {
        self.con_command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "con_command",
            |m: &CMsgGCToGCBroadcastConsoleCommand| { &m.con_command },
            |m: &mut CMsgGCToGCBroadcastConsoleCommand| { &mut m.con_command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCBroadcastConsoleCommand>(
            "CMsgGCToGCBroadcastConsoleCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCBroadcastConsoleCommand {
    const NAME: &'static str = "CMsgGCToGCBroadcastConsoleCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.con_command = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.con_command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.con_command.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBroadcastConsoleCommand {
        CMsgGCToGCBroadcastConsoleCommand::new()
    }

    fn clear(&mut self) {
        self.con_command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBroadcastConsoleCommand {
        static instance: CMsgGCToGCBroadcastConsoleCommand = CMsgGCToGCBroadcastConsoleCommand {
            con_command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCBroadcastConsoleCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCBroadcastConsoleCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCBroadcastConsoleCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCBroadcastConsoleCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCServerVersionUpdated)
pub struct CMsgGCServerVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCServerVersionUpdated.server_version)
    pub server_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCServerVersionUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCServerVersionUpdated {
    fn default() -> &'a CMsgGCServerVersionUpdated {
        <CMsgGCServerVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCServerVersionUpdated {
    pub fn new() -> CMsgGCServerVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCServerVersionUpdated| { &m.server_version },
            |m: &mut CMsgGCServerVersionUpdated| { &mut m.server_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCServerVersionUpdated>(
            "CMsgGCServerVersionUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCServerVersionUpdated {
    const NAME: &'static str = "CMsgGCServerVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCServerVersionUpdated {
        CMsgGCServerVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCServerVersionUpdated {
        static instance: CMsgGCServerVersionUpdated = CMsgGCServerVersionUpdated {
            server_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCServerVersionUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCServerVersionUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCServerVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCServerVersionUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCClientVersionUpdated)
pub struct CMsgGCClientVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientVersionUpdated.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientVersionUpdated.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientVersionUpdated {
    fn default() -> &'a CMsgGCClientVersionUpdated {
        <CMsgGCClientVersionUpdated as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientVersionUpdated {
    pub fn new() -> CMsgGCClientVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgGCClientVersionUpdated| { &m.client_version },
            |m: &mut CMsgGCClientVersionUpdated| { &mut m.client_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCClientVersionUpdated>(
            "CMsgGCClientVersionUpdated",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCClientVersionUpdated {
    const NAME: &'static str = "CMsgGCClientVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientVersionUpdated {
        CMsgGCClientVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientVersionUpdated {
        static instance: CMsgGCClientVersionUpdated = CMsgGCClientVersionUpdated {
            client_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCClientVersionUpdated {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCClientVersionUpdated").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCClientVersionUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCClientVersionUpdated {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCWebAPIAccountChanged)
pub struct CMsgGCToGCWebAPIAccountChanged {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCWebAPIAccountChanged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCWebAPIAccountChanged {
    fn default() -> &'a CMsgGCToGCWebAPIAccountChanged {
        <CMsgGCToGCWebAPIAccountChanged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCWebAPIAccountChanged {
    pub fn new() -> CMsgGCToGCWebAPIAccountChanged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCWebAPIAccountChanged>(
            "CMsgGCToGCWebAPIAccountChanged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCWebAPIAccountChanged {
    const NAME: &'static str = "CMsgGCToGCWebAPIAccountChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCWebAPIAccountChanged {
        CMsgGCToGCWebAPIAccountChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCWebAPIAccountChanged {
        static instance: CMsgGCToGCWebAPIAccountChanged = CMsgGCToGCWebAPIAccountChanged {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCWebAPIAccountChanged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCWebAPIAccountChanged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCWebAPIAccountChanged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCWebAPIAccountChanged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCRequestPassportItemGrant)
pub struct CMsgGCToGCRequestPassportItemGrant {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCRequestPassportItemGrant.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCRequestPassportItemGrant.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCRequestPassportItemGrant.reward_flag)
    pub reward_flag: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCRequestPassportItemGrant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCRequestPassportItemGrant {
    fn default() -> &'a CMsgGCToGCRequestPassportItemGrant {
        <CMsgGCToGCRequestPassportItemGrant as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCRequestPassportItemGrant {
    pub fn new() -> CMsgGCToGCRequestPassportItemGrant {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional int32 reward_flag = 3;

    pub fn reward_flag(&self) -> i32 {
        self.reward_flag.unwrap_or(0)
    }

    pub fn clear_reward_flag(&mut self) {
        self.reward_flag = ::std::option::Option::None;
    }

    pub fn has_reward_flag(&self) -> bool {
        self.reward_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_flag(&mut self, v: i32) {
        self.reward_flag = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CMsgGCToGCRequestPassportItemGrant| { &m.steam_id },
            |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "league_id",
            |m: &CMsgGCToGCRequestPassportItemGrant| { &m.league_id },
            |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.league_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_flag",
            |m: &CMsgGCToGCRequestPassportItemGrant| { &m.reward_flag },
            |m: &mut CMsgGCToGCRequestPassportItemGrant| { &mut m.reward_flag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCRequestPassportItemGrant>(
            "CMsgGCToGCRequestPassportItemGrant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCRequestPassportItemGrant {
    const NAME: &'static str = "CMsgGCToGCRequestPassportItemGrant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.reward_flag = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.league_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.reward_flag {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.reward_flag {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCRequestPassportItemGrant {
        CMsgGCToGCRequestPassportItemGrant::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.reward_flag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCRequestPassportItemGrant {
        static instance: CMsgGCToGCRequestPassportItemGrant = CMsgGCToGCRequestPassportItemGrant {
            steam_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            reward_flag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCRequestPassportItemGrant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCRequestPassportItemGrant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCRequestPassportItemGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCRequestPassportItemGrant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGameServerInfo)
pub struct CMsgGameServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_public_ip_addr)
    pub server_public_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_private_ip_addr)
    pub server_private_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_tv_port)
    pub server_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_key)
    pub server_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_hibernation)
    pub server_hibernation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_type)
    pub server_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_game_server_info::ServerType>>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_loadavg)
    pub server_loadavg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_tv_broadcast_time)
    pub server_tv_broadcast_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_game_time)
    pub server_game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_relay_connected_steam_id)
    pub server_relay_connected_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relay_slots_max)
    pub relay_slots_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relays_connected)
    pub relays_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relay_clients_connected)
    pub relay_clients_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relayed_game_server_steam_id)
    pub relayed_game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.parent_relay_count)
    pub parent_relay_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.tv_secret_code)
    pub tv_secret_code: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerInfo {
    fn default() -> &'a CMsgGameServerInfo {
        <CMsgGameServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerInfo {
    pub fn new() -> CMsgGameServerInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 server_public_ip_addr = 1;

    pub fn server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_private_ip_addr = 2;

    pub fn server_private_ip_addr(&self) -> u32 {
        self.server_private_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_private_ip_addr(&mut self) {
        self.server_private_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_private_ip_addr(&self) -> bool {
        self.server_private_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_private_ip_addr(&mut self, v: u32) {
        self.server_private_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tv_port = 4;

    pub fn server_tv_port(&self) -> u32 {
        self.server_tv_port.unwrap_or(0)
    }

    pub fn clear_server_tv_port(&mut self) {
        self.server_tv_port = ::std::option::Option::None;
    }

    pub fn has_server_tv_port(&self) -> bool {
        self.server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_port(&mut self, v: u32) {
        self.server_tv_port = ::std::option::Option::Some(v);
    }

    // optional string server_key = 5;

    pub fn server_key(&self) -> &str {
        match self.server_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_key(&mut self) {
        self.server_key = ::std::option::Option::None;
    }

    pub fn has_server_key(&self) -> bool {
        self.server_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_key(&mut self, v: ::std::string::String) {
        self.server_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_key(&mut self) -> &mut ::std::string::String {
        if self.server_key.is_none() {
            self.server_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_key(&mut self) -> ::std::string::String {
        self.server_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool server_hibernation = 6;

    pub fn server_hibernation(&self) -> bool {
        self.server_hibernation.unwrap_or(false)
    }

    pub fn clear_server_hibernation(&mut self) {
        self.server_hibernation = ::std::option::Option::None;
    }

    pub fn has_server_hibernation(&self) -> bool {
        self.server_hibernation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_hibernation(&mut self, v: bool) {
        self.server_hibernation = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerInfo.ServerType server_type = 7;

    pub fn server_type(&self) -> cmsg_game_server_info::ServerType {
        match self.server_type {
            Some(e) => e.enum_value_or(cmsg_game_server_info::ServerType::UNSPECIFIED),
            None => cmsg_game_server_info::ServerType::UNSPECIFIED,
        }
    }

    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: cmsg_game_server_info::ServerType) {
        self.server_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 server_region = 8;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 9;

    pub fn server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional float server_tv_broadcast_time = 10;

    pub fn server_tv_broadcast_time(&self) -> f32 {
        self.server_tv_broadcast_time.unwrap_or(0.)
    }

    pub fn clear_server_tv_broadcast_time(&mut self) {
        self.server_tv_broadcast_time = ::std::option::Option::None;
    }

    pub fn has_server_tv_broadcast_time(&self) -> bool {
        self.server_tv_broadcast_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_broadcast_time(&mut self, v: f32) {
        self.server_tv_broadcast_time = ::std::option::Option::Some(v);
    }

    // optional float server_game_time = 11;

    pub fn server_game_time(&self) -> f32 {
        self.server_game_time.unwrap_or(0.)
    }

    pub fn clear_server_game_time(&mut self) {
        self.server_game_time = ::std::option::Option::None;
    }

    pub fn has_server_game_time(&self) -> bool {
        self.server_game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_game_time(&mut self, v: f32) {
        self.server_game_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_relay_connected_steam_id = 12;

    pub fn server_relay_connected_steam_id(&self) -> u64 {
        self.server_relay_connected_steam_id.unwrap_or(0)
    }

    pub fn clear_server_relay_connected_steam_id(&mut self) {
        self.server_relay_connected_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_relay_connected_steam_id(&self) -> bool {
        self.server_relay_connected_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_relay_connected_steam_id(&mut self, v: u64) {
        self.server_relay_connected_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_slots_max = 13;

    pub fn relay_slots_max(&self) -> u32 {
        self.relay_slots_max.unwrap_or(0)
    }

    pub fn clear_relay_slots_max(&mut self) {
        self.relay_slots_max = ::std::option::Option::None;
    }

    pub fn has_relay_slots_max(&self) -> bool {
        self.relay_slots_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_slots_max(&mut self, v: u32) {
        self.relay_slots_max = ::std::option::Option::Some(v);
    }

    // optional int32 relays_connected = 14;

    pub fn relays_connected(&self) -> i32 {
        self.relays_connected.unwrap_or(0)
    }

    pub fn clear_relays_connected(&mut self) {
        self.relays_connected = ::std::option::Option::None;
    }

    pub fn has_relays_connected(&self) -> bool {
        self.relays_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relays_connected(&mut self, v: i32) {
        self.relays_connected = ::std::option::Option::Some(v);
    }

    // optional int32 relay_clients_connected = 15;

    pub fn relay_clients_connected(&self) -> i32 {
        self.relay_clients_connected.unwrap_or(0)
    }

    pub fn clear_relay_clients_connected(&mut self) {
        self.relay_clients_connected = ::std::option::Option::None;
    }

    pub fn has_relay_clients_connected(&self) -> bool {
        self.relay_clients_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_clients_connected(&mut self, v: i32) {
        self.relay_clients_connected = ::std::option::Option::Some(v);
    }

    // optional fixed64 relayed_game_server_steam_id = 16;

    pub fn relayed_game_server_steam_id(&self) -> u64 {
        self.relayed_game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_relayed_game_server_steam_id(&mut self) {
        self.relayed_game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_relayed_game_server_steam_id(&self) -> bool {
        self.relayed_game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relayed_game_server_steam_id(&mut self, v: u64) {
        self.relayed_game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_relay_count = 17;

    pub fn parent_relay_count(&self) -> u32 {
        self.parent_relay_count.unwrap_or(0)
    }

    pub fn clear_parent_relay_count(&mut self) {
        self.parent_relay_count = ::std::option::Option::None;
    }

    pub fn has_parent_relay_count(&self) -> bool {
        self.parent_relay_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_relay_count(&mut self, v: u32) {
        self.parent_relay_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_secret_code = 18;

    pub fn tv_secret_code(&self) -> u64 {
        self.tv_secret_code.unwrap_or(0)
    }

    pub fn clear_tv_secret_code(&mut self) {
        self.tv_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_secret_code(&self) -> bool {
        self.tv_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_secret_code(&mut self, v: u64) {
        self.tv_secret_code = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_public_ip_addr",
            |m: &CMsgGameServerInfo| { &m.server_public_ip_addr },
            |m: &mut CMsgGameServerInfo| { &mut m.server_public_ip_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_private_ip_addr",
            |m: &CMsgGameServerInfo| { &m.server_private_ip_addr },
            |m: &mut CMsgGameServerInfo| { &mut m.server_private_ip_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGameServerInfo| { &m.server_port },
            |m: &mut CMsgGameServerInfo| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tv_port",
            |m: &CMsgGameServerInfo| { &m.server_tv_port },
            |m: &mut CMsgGameServerInfo| { &mut m.server_tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_key",
            |m: &CMsgGameServerInfo| { &m.server_key },
            |m: &mut CMsgGameServerInfo| { &mut m.server_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_hibernation",
            |m: &CMsgGameServerInfo| { &m.server_hibernation },
            |m: &mut CMsgGameServerInfo| { &mut m.server_hibernation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_type",
            |m: &CMsgGameServerInfo| { &m.server_type },
            |m: &mut CMsgGameServerInfo| { &mut m.server_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_region",
            |m: &CMsgGameServerInfo| { &m.server_region },
            |m: &mut CMsgGameServerInfo| { &mut m.server_region },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_loadavg",
            |m: &CMsgGameServerInfo| { &m.server_loadavg },
            |m: &mut CMsgGameServerInfo| { &mut m.server_loadavg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tv_broadcast_time",
            |m: &CMsgGameServerInfo| { &m.server_tv_broadcast_time },
            |m: &mut CMsgGameServerInfo| { &mut m.server_tv_broadcast_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_game_time",
            |m: &CMsgGameServerInfo| { &m.server_game_time },
            |m: &mut CMsgGameServerInfo| { &mut m.server_game_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_relay_connected_steam_id",
            |m: &CMsgGameServerInfo| { &m.server_relay_connected_steam_id },
            |m: &mut CMsgGameServerInfo| { &mut m.server_relay_connected_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_slots_max",
            |m: &CMsgGameServerInfo| { &m.relay_slots_max },
            |m: &mut CMsgGameServerInfo| { &mut m.relay_slots_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relays_connected",
            |m: &CMsgGameServerInfo| { &m.relays_connected },
            |m: &mut CMsgGameServerInfo| { &mut m.relays_connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_clients_connected",
            |m: &CMsgGameServerInfo| { &m.relay_clients_connected },
            |m: &mut CMsgGameServerInfo| { &mut m.relay_clients_connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relayed_game_server_steam_id",
            |m: &CMsgGameServerInfo| { &m.relayed_game_server_steam_id },
            |m: &mut CMsgGameServerInfo| { &mut m.relayed_game_server_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parent_relay_count",
            |m: &CMsgGameServerInfo| { &m.parent_relay_count },
            |m: &mut CMsgGameServerInfo| { &mut m.parent_relay_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_secret_code",
            |m: &CMsgGameServerInfo| { &m.tv_secret_code },
            |m: &mut CMsgGameServerInfo| { &mut m.tv_secret_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGameServerInfo>(
            "CMsgGameServerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGameServerInfo {
    const NAME: &'static str = "CMsgGameServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.server_public_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.server_private_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.server_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.server_hibernation = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.server_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.server_loadavg = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.server_tv_broadcast_time = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.server_game_time = ::std::option::Option::Some(is.read_float()?);
                },
                97 => {
                    self.server_relay_connected_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                104 => {
                    self.relay_slots_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.relays_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.relay_clients_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                129 => {
                    self.relayed_game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                136 => {
                    self.parent_relay_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                145 => {
                    self.tv_secret_code = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_public_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_private_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_tv_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.server_key.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_hibernation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_type {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.server_region {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_slots_max {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.relays_connected {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.relay_clients_connected {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.parent_relay_count {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.tv_secret_code {
            my_size += 2 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_private_ip_addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_tv_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.server_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.server_hibernation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.server_type {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_game_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.relay_slots_max {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.relays_connected {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.relay_clients_connected {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            os.write_fixed64(16, v)?;
        }
        if let Some(v) = self.parent_relay_count {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_secret_code {
            os.write_fixed64(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerInfo {
        CMsgGameServerInfo::new()
    }

    fn clear(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_private_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_tv_port = ::std::option::Option::None;
        self.server_key = ::std::option::Option::None;
        self.server_hibernation = ::std::option::Option::None;
        self.server_type = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_tv_broadcast_time = ::std::option::Option::None;
        self.server_game_time = ::std::option::Option::None;
        self.server_relay_connected_steam_id = ::std::option::Option::None;
        self.relay_slots_max = ::std::option::Option::None;
        self.relays_connected = ::std::option::Option::None;
        self.relay_clients_connected = ::std::option::Option::None;
        self.relayed_game_server_steam_id = ::std::option::Option::None;
        self.parent_relay_count = ::std::option::Option::None;
        self.tv_secret_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerInfo {
        static instance: CMsgGameServerInfo = CMsgGameServerInfo {
            server_public_ip_addr: ::std::option::Option::None,
            server_private_ip_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            server_tv_port: ::std::option::Option::None,
            server_key: ::std::option::Option::None,
            server_hibernation: ::std::option::Option::None,
            server_type: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            server_loadavg: ::std::option::Option::None,
            server_tv_broadcast_time: ::std::option::Option::None,
            server_game_time: ::std::option::Option::None,
            server_relay_connected_steam_id: ::std::option::Option::None,
            relay_slots_max: ::std::option::Option::None,
            relays_connected: ::std::option::Option::None,
            relay_clients_connected: ::std::option::Option::None,
            relayed_game_server_steam_id: ::std::option::Option::None,
            parent_relay_count: ::std::option::Option::None,
            tv_secret_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGameServerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGameServerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGameServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGameServerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGameServerInfo`
pub mod cmsg_game_server_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerInfo.ServerType)
    pub enum ServerType {
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.GAME)
        GAME = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.PROXY)
        PROXY = 2,
    }

    impl ::protobuf::Enum for ServerType {
        const NAME: &'static str = "ServerType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ServerType> {
            match value {
                0 => ::std::option::Option::Some(ServerType::UNSPECIFIED),
                1 => ::std::option::Option::Some(ServerType::GAME),
                2 => ::std::option::Option::Some(ServerType::PROXY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ServerType] = &[
            ServerType::UNSPECIFIED,
            ServerType::GAME,
            ServerType::PROXY,
        ];
    }

    impl ::protobuf::EnumFull for ServerType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgGameServerInfo.ServerType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ServerType {
        fn default() -> Self {
            ServerType::UNSPECIFIED
        }
    }

    impl ServerType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServerType>("CMsgGameServerInfo.ServerType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconEquipSlot)
pub struct CSOEconEquipSlot {
    // message fields
    // @@protoc_insertion_point(field:CSOEconEquipSlot.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconEquipSlot.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconEquipSlot.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconEquipSlot.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconEquipSlot.item_definition)
    pub item_definition: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconEquipSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconEquipSlot {
    fn default() -> &'a CSOEconEquipSlot {
        <CSOEconEquipSlot as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconEquipSlot {
    pub fn new() -> CSOEconEquipSlot {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 class_id = 2;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 4;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_definition = 5;

    pub fn item_definition(&self) -> u32 {
        self.item_definition.unwrap_or(0)
    }

    pub fn clear_item_definition(&mut self) {
        self.item_definition = ::std::option::Option::None;
    }

    pub fn has_item_definition(&self) -> bool {
        self.item_definition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_definition(&mut self, v: u32) {
        self.item_definition = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CSOEconEquipSlot| { &m.account_id },
            |m: &mut CSOEconEquipSlot| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CSOEconEquipSlot| { &m.class_id },
            |m: &mut CSOEconEquipSlot| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CSOEconEquipSlot| { &m.slot_id },
            |m: &mut CSOEconEquipSlot| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CSOEconEquipSlot| { &m.item_id },
            |m: &mut CSOEconEquipSlot| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_definition",
            |m: &CSOEconEquipSlot| { &m.item_definition },
            |m: &mut CSOEconEquipSlot| { &mut m.item_definition },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconEquipSlot>(
            "CSOEconEquipSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconEquipSlot {
    const NAME: &'static str = "CSOEconEquipSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.item_definition = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.item_definition {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.item_definition {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconEquipSlot {
        CSOEconEquipSlot::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.item_definition = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconEquipSlot {
        static instance: CSOEconEquipSlot = CSOEconEquipSlot {
            account_id: ::std::option::Option::None,
            class_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            item_definition: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconEquipSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconEquipSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconEquipSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconEquipSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAdjustEquipSlot)
pub struct CMsgAdjustEquipSlot {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustEquipSlot.class_id)
    pub class_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustEquipSlot.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAdjustEquipSlot.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustEquipSlot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustEquipSlot {
    fn default() -> &'a CMsgAdjustEquipSlot {
        <CMsgAdjustEquipSlot as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustEquipSlot {
    pub fn new() -> CMsgAdjustEquipSlot {
        ::std::default::Default::default()
    }

    // optional uint32 class_id = 1;

    pub fn class_id(&self) -> u32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: u32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CMsgAdjustEquipSlot| { &m.class_id },
            |m: &mut CMsgAdjustEquipSlot| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot_id",
            |m: &CMsgAdjustEquipSlot| { &m.slot_id },
            |m: &mut CMsgAdjustEquipSlot| { &mut m.slot_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &CMsgAdjustEquipSlot| { &m.item_id },
            |m: &mut CMsgAdjustEquipSlot| { &mut m.item_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustEquipSlot>(
            "CMsgAdjustEquipSlot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustEquipSlot {
    const NAME: &'static str = "CMsgAdjustEquipSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.class_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.class_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustEquipSlot {
        CMsgAdjustEquipSlot::new()
    }

    fn clear(&mut self) {
        self.class_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustEquipSlot {
        static instance: CMsgAdjustEquipSlot = CMsgAdjustEquipSlot {
            class_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustEquipSlot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustEquipSlot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustEquipSlot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustEquipSlot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgAdjustEquipSlots)
pub struct CMsgAdjustEquipSlots {
    // message fields
    // @@protoc_insertion_point(field:CMsgAdjustEquipSlots.slots)
    pub slots: ::std::vec::Vec<CMsgAdjustEquipSlot>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAdjustEquipSlots.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAdjustEquipSlots {
    fn default() -> &'a CMsgAdjustEquipSlots {
        <CMsgAdjustEquipSlots as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAdjustEquipSlots {
    pub fn new() -> CMsgAdjustEquipSlots {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "slots",
            |m: &CMsgAdjustEquipSlots| { &m.slots },
            |m: &mut CMsgAdjustEquipSlots| { &mut m.slots },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAdjustEquipSlots>(
            "CMsgAdjustEquipSlots",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAdjustEquipSlots {
    const NAME: &'static str = "CMsgAdjustEquipSlots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slots.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.slots {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAdjustEquipSlots {
        CMsgAdjustEquipSlots::new()
    }

    fn clear(&mut self) {
        self.slots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAdjustEquipSlots {
        static instance: CMsgAdjustEquipSlots = CMsgAdjustEquipSlots {
            slots: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAdjustEquipSlots {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAdjustEquipSlots").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAdjustEquipSlots {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAdjustEquipSlots {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseMsg)
pub enum EGCBaseMsg {
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCSystemMessage)
    k_EMsgGCSystemMessage = 4001,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplicateConVars)
    k_EMsgGCReplicateConVars = 4002,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCConVarUpdated)
    k_EMsgGCConVarUpdated = 4003,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInQueue)
    k_EMsgGCInQueue = 4008,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInviteToParty)
    k_EMsgGCInviteToParty = 4501,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInvitationCreated)
    k_EMsgGCInvitationCreated = 4502,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCPartyInviteResponse)
    k_EMsgGCPartyInviteResponse = 4503,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCKickFromParty)
    k_EMsgGCKickFromParty = 4504,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLeaveParty)
    k_EMsgGCLeaveParty = 4505,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCServerAvailable)
    k_EMsgGCServerAvailable = 4506,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCClientConnectToServer)
    k_EMsgGCClientConnectToServer = 4507,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCGameServerInfo)
    k_EMsgGCGameServerInfo = 4508,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCError)
    k_EMsgGCError = 4509,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCReplay_UploadedToYouTube)
    k_EMsgGCReplay_UploadedToYouTube = 4510,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLANServerAvailable)
    k_EMsgGCLANServerAvailable = 4511,
}

impl ::protobuf::Enum for EGCBaseMsg {
    const NAME: &'static str = "EGCBaseMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4001 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCSystemMessage),
            4002 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplicateConVars),
            4003 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCConVarUpdated),
            4008 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInQueue),
            4501 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            4502 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            4503 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            4504 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            4505 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4509 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCError),
            4510 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseMsg] = &[
        EGCBaseMsg::k_EMsgGCSystemMessage,
        EGCBaseMsg::k_EMsgGCReplicateConVars,
        EGCBaseMsg::k_EMsgGCConVarUpdated,
        EGCBaseMsg::k_EMsgGCInQueue,
        EGCBaseMsg::k_EMsgGCInviteToParty,
        EGCBaseMsg::k_EMsgGCInvitationCreated,
        EGCBaseMsg::k_EMsgGCPartyInviteResponse,
        EGCBaseMsg::k_EMsgGCKickFromParty,
        EGCBaseMsg::k_EMsgGCLeaveParty,
        EGCBaseMsg::k_EMsgGCServerAvailable,
        EGCBaseMsg::k_EMsgGCClientConnectToServer,
        EGCBaseMsg::k_EMsgGCGameServerInfo,
        EGCBaseMsg::k_EMsgGCError,
        EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube,
        EGCBaseMsg::k_EMsgGCLANServerAvailable,
    ];
}

impl ::protobuf::EnumFull for EGCBaseMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseMsg::k_EMsgGCSystemMessage => 0,
            EGCBaseMsg::k_EMsgGCReplicateConVars => 1,
            EGCBaseMsg::k_EMsgGCConVarUpdated => 2,
            EGCBaseMsg::k_EMsgGCInQueue => 3,
            EGCBaseMsg::k_EMsgGCInviteToParty => 4,
            EGCBaseMsg::k_EMsgGCInvitationCreated => 5,
            EGCBaseMsg::k_EMsgGCPartyInviteResponse => 6,
            EGCBaseMsg::k_EMsgGCKickFromParty => 7,
            EGCBaseMsg::k_EMsgGCLeaveParty => 8,
            EGCBaseMsg::k_EMsgGCServerAvailable => 9,
            EGCBaseMsg::k_EMsgGCClientConnectToServer => 10,
            EGCBaseMsg::k_EMsgGCGameServerInfo => 11,
            EGCBaseMsg::k_EMsgGCError => 12,
            EGCBaseMsg::k_EMsgGCReplay_UploadedToYouTube => 13,
            EGCBaseMsg::k_EMsgGCLANServerAvailable => 14,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCSystemMessage
    }
}

impl EGCBaseMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseMsg>("EGCBaseMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseProtoObjectTypes)
pub enum EGCBaseProtoObjectTypes {
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectPartyInvite)
    k_EProtoObjectPartyInvite = 1001,
    // @@protoc_insertion_point(enum_value:EGCBaseProtoObjectTypes.k_EProtoObjectLobbyInvite)
    k_EProtoObjectLobbyInvite = 1002,
}

impl ::protobuf::Enum for EGCBaseProtoObjectTypes {
    const NAME: &'static str = "EGCBaseProtoObjectTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseProtoObjectTypes> {
        match value {
            1001 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite),
            1002 => ::std::option::Option::Some(EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseProtoObjectTypes] = &[
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite,
        EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite,
    ];
}

impl ::protobuf::EnumFull for EGCBaseProtoObjectTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGCBaseProtoObjectTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite => 0,
            EGCBaseProtoObjectTypes::k_EProtoObjectLobbyInvite => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseProtoObjectTypes {
    fn default() -> Self {
        EGCBaseProtoObjectTypes::k_EProtoObjectPartyInvite
    }
}

impl EGCBaseProtoObjectTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGCBaseProtoObjectTypes>("EGCBaseProtoObjectTypes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GC_BannedWordType)
pub enum GC_BannedWordType {
    // @@protoc_insertion_point(enum_value:GC_BannedWordType.GC_BANNED_WORD_DISABLE_WORD)
    GC_BANNED_WORD_DISABLE_WORD = 0,
    // @@protoc_insertion_point(enum_value:GC_BannedWordType.GC_BANNED_WORD_ENABLE_WORD)
    GC_BANNED_WORD_ENABLE_WORD = 1,
}

impl ::protobuf::Enum for GC_BannedWordType {
    const NAME: &'static str = "GC_BannedWordType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GC_BannedWordType> {
        match value {
            0 => ::std::option::Option::Some(GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD),
            1 => ::std::option::Option::Some(GC_BannedWordType::GC_BANNED_WORD_ENABLE_WORD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GC_BannedWordType] = &[
        GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD,
        GC_BannedWordType::GC_BANNED_WORD_ENABLE_WORD,
    ];
}

impl ::protobuf::EnumFull for GC_BannedWordType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GC_BannedWordType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GC_BannedWordType {
    fn default() -> Self {
        GC_BannedWordType::GC_BANNED_WORD_DISABLE_WORD
    }
}

impl GC_BannedWordType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GC_BannedWordType>("GC_BannedWordType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1abase_gcmessages_csgo.proto\x1a\x13steammessages.proto\"\xb5\x01\n\
    \x1dCGCStorePurchaseInit_LineItem\x12\x1e\n\x0bitem_def_id\x18\x01\x20\
    \x01(\rR\titemDefId\x12\x1a\n\x08quantity\x18\x02\x20\x01(\rR\x08quantit\
    y\x123\n\x16cost_in_local_currency\x18\x03\x20\x01(\rR\x13costInLocalCur\
    rency\x12#\n\rpurchase_type\x18\x04\x20\x01(\rR\x0cpurchaseType\"\xaa\
    \x01\n\x17CMsgGCStorePurchaseInit\x12\x18\n\x07country\x18\x01\x20\x01(\
    \tR\x07country\x12\x1a\n\x08language\x18\x02\x20\x01(\x05R\x08language\
    \x12\x1a\n\x08currency\x18\x03\x20\x01(\x05R\x08currency\x12=\n\nline_it\
    ems\x18\x04\x20\x03(\x0b2\x1e.CGCStorePurchaseInit_LineItemR\tlineItems\
    \"}\n\x1fCMsgGCStorePurchaseInitResponse\x12\x16\n\x06result\x18\x01\x20\
    \x01(\x05R\x06result\x12\x15\n\x06txn_id\x18\x02\x20\x01(\x04R\x05txnId\
    \x12\x10\n\x03url\x18\x03\x20\x01(\tR\x03url\x12\x19\n\x08item_ids\x18\
    \x04\x20\x03(\x04R\x07itemIds\"o\n\x0eCSOPartyInvite\x12\x1f\n\x08group_\
    id\x18\x01\x20\x01(\x04R\x07groupIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tsend\
    er_id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bsender_name\x18\x03\
    \x20\x01(\tR\nsenderName\"o\n\x0eCSOLobbyInvite\x12\x1f\n\x08group_id\
    \x18\x01\x20\x01(\x04R\x07groupIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tsender\
    _id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bsender_name\x18\x03\
    \x20\x01(\tR\nsenderName\"/\n\x13CMsgSystemBroadcast\x12\x18\n\x07messag\
    e\x18\x01\x20\x01(\tR\x07message\"v\n\x11CMsgInviteToParty\x12\x19\n\x08\
    steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12%\n\x0eclient_version\x18\
    \x02\x20\x01(\rR\rclientVersion\x12\x1f\n\x0bteam_invite\x18\x03\x20\x01\
    (\rR\nteamInvite\"M\n\x15CMsgInvitationCreated\x12\x19\n\x08group_id\x18\
    \x01\x20\x01(\x04R\x07groupId\x12\x19\n\x08steam_id\x18\x02\x20\x01(\x06\
    R\x07steamId\"\x94\x01\n\x17CMsgPartyInviteResponse\x12\x19\n\x08party_i\
    d\x18\x01\x20\x01(\x04R\x07partyId\x12\x16\n\x06accept\x18\x02\x20\x01(\
    \x08R\x06accept\x12%\n\x0eclient_version\x18\x03\x20\x01(\rR\rclientVers\
    ion\x12\x1f\n\x0bteam_invite\x18\x04\x20\x01(\rR\nteamInvite\".\n\x11CMs\
    gKickFromParty\x12\x19\n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\"\
    \x10\n\x0eCMsgLeaveParty\"\x15\n\x13CMsgServerAvailable\"3\n\x16CMsgLANS\
    erverAvailable\x12\x19\n\x08lobby_id\x18\x01\x20\x01(\x06R\x07lobbyId\"\
    \x9a\x02\n\x18CSOEconGameAccountClient\x12=\n\x19additional_backpack_slo\
    ts\x18\x01\x20\x01(\r:\x010R\x17additionalBackpackSlots\x12;\n\x1abonus_\
    xp_timestamp_refresh\x18\x0c\x20\x01(\x07R\x17bonusXpTimestampRefresh\
    \x12,\n\x12bonus_xp_usedflags\x18\r\x20\x01(\rR\x10bonusXpUsedflags\x12%\
    \n\x0eelevated_state\x18\x0e\x20\x01(\rR\relevatedState\x12-\n\x12elevat\
    ed_timestamp\x18\x0f\x20\x01(\rR\x11elevatedTimestamp\"\xa0\x01\n\x18CSO\
    ItemCriteriaCondition\x12\x0e\n\x02op\x18\x01\x20\x01(\x05R\x02op\x12\
    \x14\n\x05field\x18\x02\x20\x01(\tR\x05field\x12\x1a\n\x08required\x18\
    \x03\x20\x01(\x08R\x08required\x12\x1f\n\x0bfloat_value\x18\x04\x20\x01(\
    \x02R\nfloatValue\x12!\n\x0cstring_value\x18\x05\x20\x01(\tR\x0bstringVa\
    lue\"\xd0\x03\n\x0fCSOItemCriteria\x12\x1d\n\nitem_level\x18\x01\x20\x01\
    (\rR\titemLevel\x12!\n\x0citem_quality\x18\x02\x20\x01(\x05R\x0bitemQual\
    ity\x12$\n\x0eitem_level_set\x18\x03\x20\x01(\x08R\x0citemLevelSet\x12(\
    \n\x10item_quality_set\x18\x04\x20\x01(\x08R\x0eitemQualitySet\x12+\n\
    \x11initial_inventory\x18\x05\x20\x01(\rR\x10initialInventory\x12)\n\x10\
    initial_quantity\x18\x06\x20\x01(\rR\x0finitialQuantity\x12.\n\x13ignore\
    _enabled_flag\x18\x08\x20\x01(\x08R\x11ignoreEnabledFlag\x129\n\nconditi\
    ons\x18\t\x20\x03(\x0b2\x19.CSOItemCriteriaConditionR\nconditions\x12\
    \x1f\n\x0bitem_rarity\x18\n\x20\x01(\x05R\nitemRarity\x12&\n\x0fitem_rar\
    ity_set\x18\x0b\x20\x01(\x08R\ritemRaritySet\x12\x1f\n\x0brecent_only\
    \x18\x0c\x20\x01(\x08R\nrecentOnly\"\xc0\x05\n\rCSOItemRecipe\x12\x1b\n\
    \tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x0f\n\x03n_a\x18\x03\x20\x01(\tR\x02nA\x12\x1f\
    \n\x0bdesc_inputs\x18\x04\x20\x01(\tR\ndescInputs\x12!\n\x0cdesc_outputs\
    \x18\x05\x20\x01(\tR\x0bdescOutputs\x12\x11\n\x04di_a\x18\x06\x20\x01(\t\
    R\x03diA\x12\x11\n\x04di_b\x18\x07\x20\x01(\tR\x03diB\x12\x11\n\x04di_c\
    \x18\x08\x20\x01(\tR\x03diC\x12\x11\n\x04do_a\x18\t\x20\x01(\tR\x03doA\
    \x12\x11\n\x04do_b\x18\n\x20\x01(\tR\x03doB\x12\x11\n\x04do_c\x18\x0b\
    \x20\x01(\tR\x03doC\x125\n\x17requires_all_same_class\x18\x0c\x20\x01(\
    \x08R\x14requiresAllSameClass\x123\n\x16requires_all_same_slot\x18\r\x20\
    \x01(\x08R\x13requiresAllSameSlot\x123\n\x16class_usage_for_output\x18\
    \x0e\x20\x01(\x05R\x13classUsageForOutput\x121\n\x15slot_usage_for_outpu\
    t\x18\x0f\x20\x01(\x05R\x12slotUsageForOutput\x12$\n\x0eset_for_output\
    \x18\x10\x20\x01(\x05R\x0csetForOutput\x12B\n\x14input_items_criteria\
    \x18\x14\x20\x03(\x0b2\x10.CSOItemCriteriaR\x12inputItemsCriteria\x12D\n\
    \x15output_items_criteria\x18\x15\x20\x03(\x0b2\x10.CSOItemCriteriaR\x13\
    outputItemsCriteria\x123\n\x16input_item_dupe_counts\x18\x16\x20\x03(\rR\
    \x13inputItemDupeCounts\"a\n\x15CMsgDevNewItemRequest\x12\x1a\n\x08recei\
    ver\x18\x01\x20\x01(\x06R\x08receiver\x12,\n\x08criteria\x18\x02\x20\x01\
    (\x0b2\x10.CSOItemCriteriaR\x08criteria\"\xc9\x01\n\x1fCMsgIncrementKill\
    CountAttribute\x12*\n\x11killer_account_id\x18\x01\x20\x01(\x07R\x0fkill\
    erAccountId\x12*\n\x11victim_account_id\x18\x02\x20\x01(\x07R\x0fvictimA\
    ccountId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\x12\x1d\n\
    \nevent_type\x18\x04\x20\x01(\rR\teventType\x12\x16\n\x06amount\x18\x05\
    \x20\x01(\rR\x06amount\"\xcb\x01\n\x10CMsgApplySticker\x12&\n\x0fsticker\
    _item_id\x18\x01\x20\x01(\x04R\rstickerItemId\x12\x20\n\x0citem_item_id\
    \x18\x02\x20\x01(\x04R\nitemItemId\x12!\n\x0csticker_slot\x18\x03\x20\
    \x01(\rR\x0bstickerSlot\x12'\n\x0fbaseitem_defidx\x18\x04\x20\x01(\rR\
    \x0ebaseitemDefidx\x12!\n\x0csticker_wear\x18\x05\x20\x01(\x02R\x0bstick\
    erWear\"r\n\x17CMsgModifyItemAttribute\x12\x17\n\x07item_id\x18\x01\x20\
    \x01(\x04R\x06itemId\x12\x1f\n\x0battr_defidx\x18\x02\x20\x01(\rR\nattrD\
    efidx\x12\x1d\n\nattr_value\x18\x03\x20\x01(\rR\tattrValue\"\x83\x01\n\
    \x15CMsgApplyStatTrakSwap\x12\x20\n\x0ctool_item_id\x18\x01\x20\x01(\x04\
    R\ntoolItemId\x12#\n\x0eitem_1_item_id\x18\x02\x20\x01(\x04R\x0bitem1Ite\
    mId\x12#\n\x0eitem_2_item_id\x18\x03\x20\x01(\x04R\x0bitem2ItemId\"i\n\
    \x14CMsgApplyStrangePart\x12/\n\x14strange_part_item_id\x18\x01\x20\x01(\
    \x04R\x11strangePartItemId\x12\x20\n\x0citem_item_id\x18\x02\x20\x01(\
    \x04R\nitemItemId\"i\n\x17CMsgApplyPennantUpgrade\x12&\n\x0fupgrade_item\
    _id\x18\x01\x20\x01(\x04R\rupgradeItemId\x12&\n\x0fpennant_item_id\x18\
    \x02\x20\x01(\x04R\rpennantItemId\"]\n\x13CMsgApplyEggEssence\x12&\n\x0f\
    essence_item_id\x18\x01\x20\x01(\x04R\ressenceItemId\x12\x1e\n\x0begg_it\
    em_id\x18\x02\x20\x01(\x04R\teggItemId\"j\n\x14CSOEconItemAttribute\x12\
    \x1b\n\tdef_index\x18\x01\x20\x01(\rR\x08defIndex\x12\x14\n\x05value\x18\
    \x02\x20\x01(\rR\x05value\x12\x1f\n\x0bvalue_bytes\x18\x03\x20\x01(\x0cR\
    \nvalueBytes\"M\n\x13CSOEconItemEquipped\x12\x1b\n\tnew_class\x18\x01\
    \x20\x01(\rR\x08newClass\x12\x19\n\x08new_slot\x18\x02\x20\x01(\rR\x07ne\
    wSlot\"\xce\x04\n\x0bCSOEconItem\x12\x0e\n\x02id\x18\x01\x20\x01(\x04R\
    \x02id\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1c\n\ti\
    nventory\x18\x03\x20\x01(\rR\tinventory\x12\x1b\n\tdef_index\x18\x04\x20\
    \x01(\rR\x08defIndex\x12\x1a\n\x08quantity\x18\x05\x20\x01(\rR\x08quanti\
    ty\x12\x14\n\x05level\x18\x06\x20\x01(\rR\x05level\x12\x18\n\x07quality\
    \x18\x07\x20\x01(\rR\x07quality\x12\x17\n\x05flags\x18\x08\x20\x01(\r:\
    \x010R\x05flags\x12\x16\n\x06origin\x18\t\x20\x01(\rR\x06origin\x12\x1f\
    \n\x0bcustom_name\x18\n\x20\x01(\tR\ncustomName\x12\x1f\n\x0bcustom_desc\
    \x18\x0b\x20\x01(\tR\ncustomDesc\x123\n\tattribute\x18\x0c\x20\x03(\x0b2\
    \x15.CSOEconItemAttributeR\tattribute\x121\n\rinterior_item\x18\r\x20\
    \x01(\x0b2\x0c.CSOEconItemR\x0cinteriorItem\x12\x1c\n\x06in_use\x18\x0e\
    \x20\x01(\x08:\x05falseR\x05inUse\x12\x17\n\x05style\x18\x0f\x20\x01(\r:\
    \x010R\x05style\x12\"\n\x0boriginal_id\x18\x10\x20\x01(\x04:\x010R\norig\
    inalId\x12;\n\x0eequipped_state\x18\x12\x20\x03(\x0b2\x14.CSOEconItemEqu\
    ippedR\requippedState\x12\x16\n\x06rarity\x18\x13\x20\x01(\rR\x06rarity\
    \"\x82\x01\n\x1bCMsgAdjustItemEquippedState\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x04R\x06itemId\x12\x1b\n\tnew_class\x18\x02\x20\x01(\rR\x08new\
    Class\x12\x19\n\x08new_slot\x18\x03\x20\x01(\rR\x07newSlot\x12\x12\n\x04\
    swap\x18\x04\x20\x01(\x08R\x04swap\"\x7f\n\x20CMsgAdjustItemEquippedStat\
    eMulti\x12\x19\n\x08t_equips\x18\x01\x20\x03(\x04R\x07tEquips\x12\x1b\n\
    \tct_equips\x18\x02\x20\x03(\x04R\x08ctEquips\x12#\n\rnoteam_equips\x18\
    \x03\x20\x03(\x04R\x0cnoteamEquips\",\n\rCMsgSortItems\x12\x1b\n\tsort_t\
    ype\x18\x01\x20\x01(\rR\x08sortType\"\x87\x01\n\x10CSOEconClaimCode\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1b\n\tcode_type\
    \x18\x02\x20\x01(\rR\x08codeType\x12#\n\rtime_acquired\x18\x03\x20\x01(\
    \rR\x0ctimeAcquired\x12\x12\n\x04code\x18\x04\x20\x01(\tR\x04code\"b\n\
    \x14CMsgStoreGetUserData\x12.\n\x13price_sheet_version\x18\x01\x20\x01(\
    \x07R\x11priceSheetVersion\x12\x1a\n\x08currency\x18\x02\x20\x01(\x05R\
    \x08currency\"\xe7\x01\n\x1cCMsgStoreGetUserDataResponse\x12\x16\n\x06re\
    sult\x18\x01\x20\x01(\x05R\x06result\x12/\n\x13currency_deprecated\x18\
    \x02\x20\x01(\x05R\x12currencyDeprecated\x12-\n\x12country_deprecated\
    \x18\x03\x20\x01(\tR\x11countryDeprecated\x12.\n\x13price_sheet_version\
    \x18\x04\x20\x01(\x07R\x11priceSheetVersion\x12\x1f\n\x0bprice_sheet\x18\
    \x08\x20\x01(\x0cR\npriceSheet\"\x8b\x01\n\x14CMsgUpdateItemSchema\x12\
    \x1d\n\nitems_game\x18\x01\x20\x01(\x0cR\titemsGame\x12.\n\x13item_schem\
    a_version\x18\x02\x20\x01(\x07R\x11itemSchemaVersion\x12$\n\x0eitems_gam\
    e_url\x18\x04\x20\x01(\tR\x0citemsGameUrl\",\n\x0bCMsgGCError\x12\x1d\n\
    \nerror_text\x18\x01\x20\x01(\tR\terrorText\"\x1d\n\x1bCMsgRequestInvent\
    oryRefresh\";\n\x0fCMsgConVarValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"B\n\x14CMsgRep\
    licateConVars\x12*\n\x07convars\x18\x01\x20\x03(\x0b2\x10.CMsgConVarValu\
    eR\x07convars\"\xdc\x01\n\x0bCMsgUseItem\x12\x17\n\x07item_id\x18\x01\
    \x20\x01(\x04R\x06itemId\x12&\n\x0ftarget_steam_id\x18\x02\x20\x01(\x06R\
    \rtargetSteamId\x125\n\x17gift__potential_targets\x18\x03\x20\x03(\rR\
    \x14giftPotentialTargets\x12'\n\x10duel__class_lock\x18\x04\x20\x01(\rR\
    \rduelClassLock\x12,\n\x12initiator_steam_id\x18\x05\x20\x01(\x06R\x10in\
    itiatorSteamId\"\x8f\x01\n\x1bCMsgReplayUploadedToYouTube\x12\x1f\n\x0by\
    outube_url\x18\x01\x20\x01(\tR\nyoutubeUrl\x120\n\x14youtube_account_nam\
    e\x18\x02\x20\x01(\tR\x12youtubeAccountName\x12\x1d\n\nsession_id\x18\
    \x03\x20\x01(\x04R\tsessionId\"9\n\x17CMsgConsumableExhausted\x12\x1e\n\
    \x0bitem_def_id\x18\x01\x20\x01(\x05R\titemDefId\"\xdf\x01\n\x20CMsgItem\
    Acknowledged__DEPRECATED\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tacco\
    untId\x12\x1c\n\tinventory\x18\x02\x20\x01(\rR\tinventory\x12\x1b\n\tdef\
    _index\x18\x03\x20\x01(\rR\x08defIndex\x12\x18\n\x07quality\x18\x04\x20\
    \x01(\rR\x07quality\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\x06rarity\
    \x12\x16\n\x06origin\x18\x06\x20\x01(\rR\x06origin\x12\x17\n\x07item_id\
    \x18\x07\x20\x01(\x04R\x06itemId\"\xcc\x01\n\x14CMsgSetItemPositions\x12\
    I\n\x0eitem_positions\x18\x01\x20\x03(\x0b2\".CMsgSetItemPositions.ItemP\
    ositionR\ritemPositions\x1ai\n\x0cItemPosition\x12$\n\x0elegacy_item_id\
    \x18\x01\x20\x01(\rR\x0clegacyItemId\x12\x1a\n\x08position\x18\x02\x20\
    \x01(\rR\x08position\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemI\
    d\"\x9b\x02\n\x11CMsgGCReportAbuse\x12&\n\x0ftarget_steam_id\x18\x01\x20\
    \x01(\x06R\rtargetSteamId\x12\x20\n\x0bdescription\x18\x04\x20\x01(\tR\
    \x0bdescription\x12\x10\n\x03gid\x18\x05\x20\x01(\x04R\x03gid\x12\x1d\n\
    \nabuse_type\x18\x02\x20\x01(\rR\tabuseType\x12!\n\x0ccontent_type\x18\
    \x03\x20\x01(\rR\x0bcontentType\x121\n\x15target_game_server_ip\x18\x06\
    \x20\x01(\x07R\x12targetGameServerIp\x125\n\x17target_game_server_port\
    \x18\x07\x20\x01(\rR\x14targetGameServerPort\"\x80\x01\n\x19CMsgGCReport\
    AbuseResponse\x12&\n\x0ftarget_steam_id\x18\x01\x20\x01(\x06R\rtargetSte\
    amId\x12\x16\n\x06result\x18\x02\x20\x01(\rR\x06result\x12#\n\rerror_mes\
    sage\x18\x03\x20\x01(\tR\x0cerrorMessage\"\x93\x01\n\x1aCMsgGCNameItemNo\
    tification\x12%\n\x0eplayer_steamid\x18\x01\x20\x01(\x06R\rplayerSteamid\
    \x12$\n\x0eitem_def_index\x18\x02\x20\x01(\rR\x0citemDefIndex\x12(\n\x10\
    item_name_custom\x18\x03\x20\x01(\tR\x0eitemNameCustom\"\xa1\x02\n\x1fCM\
    sgGCClientDisplayNotification\x12M\n#notification_title_localization_key\
    \x18\x01\x20\x01(\tR\x20notificationTitleLocalizationKey\x12K\n\"notific\
    ation_body_localization_key\x18\x02\x20\x01(\tR\x1fnotificationBodyLocal\
    izationKey\x12.\n\x13body_substring_keys\x18\x03\x20\x03(\tR\x11bodySubs\
    tringKeys\x122\n\x15body_substring_values\x18\x04\x20\x03(\tR\x13bodySub\
    stringValues\"@\n\x17CMsgGCShowItemsPickedUp\x12%\n\x0eplayer_steamid\
    \x18\x01\x20\x01(\x06R\rplayerSteamid\"\xab\x01\n\x20CMsgGCIncrementKill\
    CountResponse\x120\n\x11killer_account_id\x18\x01\x20\x01(\rR\x0fkillerA\
    ccountIdB\x04\x80\xa6\x1d\x01\x12\x1b\n\tnum_kills\x18\x02\x20\x01(\rR\
    \x08numKills\x12\x19\n\x08item_def\x18\x03\x20\x01(\rR\x07itemDef\x12\
    \x1d\n\nlevel_type\x18\x04\x20\x01(\rR\tlevelType\"\xcf\x01\n\x18CSOEcon\
    ItemDropRateBonus\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\
    \x12'\n\x0fexpiration_date\x18\x02\x20\x01(\x07R\x0eexpirationDate\x12\
    \x14\n\x05bonus\x18\x03\x20\x01(\x02R\x05bonus\x12\x1f\n\x0bbonus_count\
    \x18\x04\x20\x01(\rR\nbonusCount\x12\x17\n\x07item_id\x18\x05\x20\x01(\
    \x04R\x06itemId\x12\x1b\n\tdef_index\x18\x06\x20\x01(\rR\x08defIndex\"\
    \x97\x01\n\x19CSOEconItemLeagueViewPass\x12#\n\naccount_id\x18\x01\x20\
    \x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12!\n\tleague_id\x18\x02\x20\
    \x01(\rR\x08leagueIdB\x04\x80\xa6\x1d\x01\x12\x14\n\x05admin\x18\x03\x20\
    \x01(\rR\x05admin\x12\x1c\n\titemindex\x18\x04\x20\x01(\rR\titemindex\"k\
    \n\x16CSOEconItemEventTicket\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\t\
    accountId\x12\x19\n\x08event_id\x18\x02\x20\x01(\rR\x07eventId\x12\x17\n\
    \x07item_id\x18\x03\x20\x01(\x04R\x06itemId\"O\n'CMsgGCItemPreviewItemBo\
    ughtNotification\x12$\n\x0eitem_def_index\x18\x01\x20\x01(\rR\x0citemDef\
    Index\"2\n\x19CMsgGCStorePurchaseCancel\x12\x15\n\x06txn_id\x18\x01\x20\
    \x01(\x04R\x05txnId\";\n!CMsgGCStorePurchaseCancelResponse\x12\x16\n\x06\
    result\x18\x01\x20\x01(\rR\x06result\"4\n\x1bCMsgGCStorePurchaseFinalize\
    \x12\x15\n\x06txn_id\x18\x01\x20\x01(\x04R\x05txnId\"X\n#CMsgGCStorePurc\
    haseFinalizeResponse\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\
    \x12\x19\n\x08item_ids\x18\x02\x20\x03(\x04R\x07itemIds\"a\n\x1bCMsgGCBa\
    nnedWordListRequest\x12)\n\x11ban_list_group_id\x18\x01\x20\x01(\rR\x0eb\
    anListGroupId\x12\x17\n\x07word_id\x18\x02\x20\x01(\rR\x06wordId\"\x1c\n\
    \x1aCMsgGCRequestAnnouncements\"\xbe\x01\n\"CMsgGCRequestAnnouncementsRe\
    sponse\x12-\n\x12announcement_title\x18\x01\x20\x01(\tR\x11announcementT\
    itle\x12\"\n\x0cannouncement\x18\x02\x20\x01(\tR\x0cannouncement\x12'\n\
    \x0fnextmatch_title\x18\x03\x20\x01(\tR\x0enextmatchTitle\x12\x1c\n\tnex\
    tmatch\x18\x04\x20\x01(\tR\tnextmatch\"\x8d\x01\n\x10CMsgGCBannedWord\
    \x12\x17\n\x07word_id\x18\x01\x20\x01(\rR\x06wordId\x12L\n\tword_type\
    \x18\x02\x20\x01(\x0e2\x12.GC_BannedWordType:\x1bGC_BANNED_WORD_DISABLE_\
    WORDR\x08wordType\x12\x12\n\x04word\x18\x03\x20\x01(\tR\x04word\"y\n\x1c\
    CMsgGCBannedWordListResponse\x12)\n\x11ban_list_group_id\x18\x01\x20\x01\
    (\rR\x0ebanListGroupId\x12.\n\tword_list\x18\x02\x20\x03(\x0b2\x11.CMsgG\
    CBannedWordR\x08wordList\"`\n!CMsgGCToGCBannedWordListBroadcast\x12;\n\t\
    broadcast\x18\x01\x20\x01(\x0b2\x1d.CMsgGCBannedWordListResponseR\tbroad\
    cast\"<\n\x1fCMsgGCToGCBannedWordListUpdated\x12\x19\n\x08group_id\x18\
    \x01\x20\x01(\rR\x07groupId\"\xbe\x01\n.CSOEconDefaultEquippedDefinition\
    InstanceClient\x12#\n\naccount_id\x18\x01\x20\x01(\rR\taccountIdB\x04\
    \x80\xa6\x1d\x01\x12'\n\x0fitem_definition\x18\x02\x20\x01(\rR\x0eitemDe\
    finition\x12\x1f\n\x08class_id\x18\x03\x20\x01(\rR\x07classIdB\x04\x80\
    \xa6\x1d\x01\x12\x1d\n\x07slot_id\x18\x04\x20\x01(\rR\x06slotIdB\x04\x80\
    \xa6\x1d\x01\"S\n\x17CMsgGCToGCDirtySDOCache\x12\x19\n\x08sdo_type\x18\
    \x01\x20\x01(\rR\x07sdoType\x12\x1d\n\nkey_uint64\x18\x02\x20\x01(\x04R\
    \tkeyUint64\"[\n\x1fCMsgGCToGCDirtyMultipleSDOCache\x12\x19\n\x08sdo_typ\
    e\x18\x01\x20\x01(\rR\x07sdoType\x12\x1d\n\nkey_uint64\x18\x02\x20\x03(\
    \x04R\tkeyUint64\"i\n\x11CMsgGCCollectItem\x12,\n\x12collection_item_id\
    \x18\x01\x20\x01(\x04R\x10collectionItemId\x12&\n\x0fsubject_item_id\x18\
    \x02\x20\x01(\x04R\rsubjectItemId\"\x14\n\x12CMsgSDONoMemcached\"8\n\x1b\
    CMsgGCToGCUpdateSQLKeyValue\x12\x19\n\x08key_name\x18\x01\x20\x01(\tR\
    \x07keyName\"6\n\x19CMsgGCToGCIsTrustedServer\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x06R\x07steamId\"B\n!CMsgGCToGCIsTrustedServerResponse\x12\
    \x1d\n\nis_trusted\x18\x01\x20\x01(\x08R\tisTrusted\"D\n!CMsgGCToGCBroad\
    castConsoleCommand\x12\x1f\n\x0bcon_command\x18\x01\x20\x01(\tR\nconComm\
    and\"C\n\x1aCMsgGCServerVersionUpdated\x12%\n\x0eserver_version\x18\x01\
    \x20\x01(\rR\rserverVersion\"C\n\x1aCMsgGCClientVersionUpdated\x12%\n\
    \x0eclient_version\x18\x01\x20\x01(\rR\rclientVersion\"\x20\n\x1eCMsgGCT\
    oGCWebAPIAccountChanged\"}\n\"CMsgGCToGCRequestPassportItemGrant\x12\x19\
    \n\x08steam_id\x18\x01\x20\x01(\x06R\x07steamId\x12\x1b\n\tleague_id\x18\
    \x02\x20\x01(\rR\x08leagueId\x12\x1f\n\x0breward_flag\x18\x03\x20\x01(\
    \x05R\nrewardFlag\"\xa7\x07\n\x12CMsgGameServerInfo\x121\n\x15server_pub\
    lic_ip_addr\x18\x01\x20\x01(\x07R\x12serverPublicIpAddr\x123\n\x16server\
    _private_ip_addr\x18\x02\x20\x01(\x07R\x13serverPrivateIpAddr\x12\x1f\n\
    \x0bserver_port\x18\x03\x20\x01(\rR\nserverPort\x12$\n\x0eserver_tv_port\
    \x18\x04\x20\x01(\rR\x0cserverTvPort\x12\x1d\n\nserver_key\x18\x05\x20\
    \x01(\tR\tserverKey\x12-\n\x12server_hibernation\x18\x06\x20\x01(\x08R\
    \x11serverHibernation\x12L\n\x0bserver_type\x18\x07\x20\x01(\x0e2\x1e.CM\
    sgGameServerInfo.ServerType:\x0bUNSPECIFIEDR\nserverType\x12#\n\rserver_\
    region\x18\x08\x20\x01(\rR\x0cserverRegion\x12%\n\x0eserver_loadavg\x18\
    \t\x20\x01(\x02R\rserverLoadavg\x127\n\x18server_tv_broadcast_time\x18\n\
    \x20\x01(\x02R\x15serverTvBroadcastTime\x12(\n\x10server_game_time\x18\
    \x0b\x20\x01(\x02R\x0eserverGameTime\x12D\n\x1fserver_relay_connected_st\
    eam_id\x18\x0c\x20\x01(\x06R\x1bserverRelayConnectedSteamId\x12&\n\x0fre\
    lay_slots_max\x18\r\x20\x01(\rR\rrelaySlotsMax\x12)\n\x10relays_connecte\
    d\x18\x0e\x20\x01(\x05R\x0frelaysConnected\x126\n\x17relay_clients_conne\
    cted\x18\x0f\x20\x01(\x05R\x15relayClientsConnected\x12>\n\x1crelayed_ga\
    me_server_steam_id\x18\x10\x20\x01(\x06R\x18relayedGameServerSteamId\x12\
    ,\n\x12parent_relay_count\x18\x11\x20\x01(\rR\x10parentRelayCount\x12$\n\
    \x0etv_secret_code\x18\x12\x20\x01(\x06R\x0ctvSecretCode\"2\n\nServerTyp\
    e\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x08\n\x04GAME\x10\x01\x12\t\n\x05PR\
    OXY\x10\x02\"\xb9\x01\n\x10CSOEconEquipSlot\x12#\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountIdB\x04\x80\xa6\x1d\x01\x12\x1f\n\x08class_id\x18\
    \x02\x20\x01(\rR\x07classIdB\x04\x80\xa6\x1d\x01\x12\x1d\n\x07slot_id\
    \x18\x03\x20\x01(\rR\x06slotIdB\x04\x80\xa6\x1d\x01\x12\x17\n\x07item_id\
    \x18\x04\x20\x01(\x04R\x06itemId\x12'\n\x0fitem_definition\x18\x05\x20\
    \x01(\rR\x0eitemDefinition\"b\n\x13CMsgAdjustEquipSlot\x12\x19\n\x08clas\
    s_id\x18\x01\x20\x01(\rR\x07classId\x12\x17\n\x07slot_id\x18\x02\x20\x01\
    (\rR\x06slotId\x12\x17\n\x07item_id\x18\x03\x20\x01(\x04R\x06itemId\"B\n\
    \x14CMsgAdjustEquipSlots\x12*\n\x05slots\x18\x01\x20\x03(\x0b2\x14.CMsgA\
    djustEquipSlotR\x05slots*\xc7\x03\n\nEGCBaseMsg\x12\x1a\n\x15k_EMsgGCSys\
    temMessage\x10\xa1\x1f\x12\x1d\n\x18k_EMsgGCReplicateConVars\x10\xa2\x1f\
    \x12\x1a\n\x15k_EMsgGCConVarUpdated\x10\xa3\x1f\x12\x14\n\x0fk_EMsgGCInQ\
    ueue\x10\xa8\x1f\x12\x1a\n\x15k_EMsgGCInviteToParty\x10\x95#\x12\x1e\n\
    \x19k_EMsgGCInvitationCreated\x10\x96#\x12\x20\n\x1bk_EMsgGCPartyInviteR\
    esponse\x10\x97#\x12\x1a\n\x15k_EMsgGCKickFromParty\x10\x98#\x12\x17\n\
    \x12k_EMsgGCLeaveParty\x10\x99#\x12\x1c\n\x17k_EMsgGCServerAvailable\x10\
    \x9a#\x12\"\n\x1dk_EMsgGCClientConnectToServer\x10\x9b#\x12\x1b\n\x16k_E\
    MsgGCGameServerInfo\x10\x9c#\x12\x12\n\rk_EMsgGCError\x10\x9d#\x12%\n\
    \x20k_EMsgGCReplay_UploadedToYouTube\x10\x9e#\x12\x1f\n\x1ak_EMsgGCLANSe\
    rverAvailable\x10\x9f#*Y\n\x17EGCBaseProtoObjectTypes\x12\x1e\n\x19k_EPr\
    otoObjectPartyInvite\x10\xe9\x07\x12\x1e\n\x19k_EProtoObjectLobbyInvite\
    \x10\xea\x07*T\n\x11GC_BannedWordType\x12\x1f\n\x1bGC_BANNED_WORD_DISABL\
    E_WORD\x10\0\x12\x1e\n\x1aGC_BANNED_WORD_ENABLE_WORD\x10\x01J\x8d\xb4\
    \x01\n\x07\x12\x05\0\0\xa2\x04\x01\n\t\n\x02\x03\0\x12\x03\0\0\x1d\n\n\n\
    \x02\x05\0\x12\x04\x02\0\x12\x01\n\n\n\x03\x05\0\x01\x12\x03\x02\x05\x0f\
    \n\x0b\n\x04\x05\0\x02\0\x12\x03\x03\x08%\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\x03\x08\x1d\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x03\x20$\n\x0b\
    \n\x04\x05\0\x02\x01\x12\x03\x04\x08(\n\x0c\n\x05\x05\0\x02\x01\x01\x12\
    \x03\x04\x08\x20\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x04#'\n\x0b\n\x04\
    \x05\0\x02\x02\x12\x03\x05\x08%\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\
    \x05\x08\x1d\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x05\x20$\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03\x06\x08\x1f\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\
    \x06\x08\x17\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\x06\x1a\x1e\n\x0b\n\
    \x04\x05\0\x02\x04\x12\x03\x07\x08%\n\x0c\n\x05\x05\0\x02\x04\x01\x12\
    \x03\x07\x08\x1d\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03\x07\x20$\n\x0b\n\
    \x04\x05\0\x02\x05\x12\x03\x08\x08)\n\x0c\n\x05\x05\0\x02\x05\x01\x12\
    \x03\x08\x08!\n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03\x08$(\n\x0b\n\x04\
    \x05\0\x02\x06\x12\x03\t\x08+\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\t\
    \x08#\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\t&*\n\x0b\n\x04\x05\0\x02\
    \x07\x12\x03\n\x08%\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\n\x08\x1d\n\
    \x0c\n\x05\x05\0\x02\x07\x02\x12\x03\n\x20$\n\x0b\n\x04\x05\0\x02\x08\
    \x12\x03\x0b\x08\"\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x0b\x08\x1a\n\
    \x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x0b\x1d!\n\x0b\n\x04\x05\0\x02\t\
    \x12\x03\x0c\x08'\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x0c\x08\x1f\n\x0c\
    \n\x05\x05\0\x02\t\x02\x12\x03\x0c\"&\n\x0b\n\x04\x05\0\x02\n\x12\x03\r\
    \x08-\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\r\x08%\n\x0c\n\x05\x05\0\x02\n\
    \x02\x12\x03\r(,\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x0e\x08&\n\x0c\n\x05\
    \x05\0\x02\x0b\x01\x12\x03\x0e\x08\x1e\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\
    \x03\x0e!%\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x0f\x08\x1d\n\x0c\n\x05\x05\
    \0\x02\x0c\x01\x12\x03\x0f\x08\x15\n\x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\
    \x0f\x18\x1c\n\x0b\n\x04\x05\0\x02\r\x12\x03\x10\x080\n\x0c\n\x05\x05\0\
    \x02\r\x01\x12\x03\x10\x08(\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\x10+/\n\
    \x0b\n\x04\x05\0\x02\x0e\x12\x03\x11\x08*\n\x0c\n\x05\x05\0\x02\x0e\x01\
    \x12\x03\x11\x08\"\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x11%)\n\n\n\x02\
    \x05\x01\x12\x04\x14\0\x17\x01\n\n\n\x03\x05\x01\x01\x12\x03\x14\x05\x1c\
    \n\x0b\n\x04\x05\x01\x02\0\x12\x03\x15\x08)\n\x0c\n\x05\x05\x01\x02\0\
    \x01\x12\x03\x15\x08!\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x15$(\n\x0b\
    \n\x04\x05\x01\x02\x01\x12\x03\x16\x08)\n\x0c\n\x05\x05\x01\x02\x01\x01\
    \x12\x03\x16\x08!\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x16$(\n\n\n\
    \x02\x05\x02\x12\x04\x19\0\x1c\x01\n\n\n\x03\x05\x02\x01\x12\x03\x19\x05\
    \x16\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x1a\x08(\n\x0c\n\x05\x05\x02\x02\
    \0\x01\x12\x03\x1a\x08#\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x1a&'\n\
    \x0b\n\x04\x05\x02\x02\x01\x12\x03\x1b\x08'\n\x0c\n\x05\x05\x02\x02\x01\
    \x01\x12\x03\x1b\x08\"\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03\x1b%&\n\n\
    \n\x02\x04\0\x12\x04\x1e\0#\x01\n\n\n\x03\x04\0\x01\x12\x03\x1e\x08%\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03\x1f\x08(\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03\x1f\x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x1f\x11\x17\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03\x1f\x18#\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03\x1f&'\n\x0b\n\x04\x04\0\x02\x01\x12\x03\x20\x08%\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03\x20\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\
    \x20\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x20\x18\x20\n\x0c\n\
    \x05\x04\0\x02\x01\x03\x12\x03\x20#$\n\x0b\n\x04\x04\0\x02\x02\x12\x03!\
    \x083\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03!\x08\x10\n\x0c\n\x05\x04\0\
    \x02\x02\x05\x12\x03!\x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03!\x18\
    .\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03!12\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03\"\x08*\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\"\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03\"\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\"\x18%\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\"()\n\n\n\x02\x04\x01\
    \x12\x04%\0*\x01\n\n\n\x03\x04\x01\x01\x12\x03%\x08\x1f\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03&\x08$\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03&\x08\x10\
    \n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03&\x11\x17\n\x0c\n\x05\x04\x01\x02\
    \0\x01\x12\x03&\x18\x1f\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03&\"#\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03'\x08$\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03'\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03'\x11\x16\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03'\x17\x1f\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03'\"#\n\x0b\n\x04\x04\x01\x02\x02\x12\x03(\x08$\n\x0c\n\x05\
    \x04\x01\x02\x02\x04\x12\x03(\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\
    \x12\x03(\x11\x16\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03(\x17\x1f\n\x0c\
    \n\x05\x04\x01\x02\x02\x03\x12\x03(\"#\n\x0b\n\x04\x04\x01\x02\x03\x12\
    \x03)\x08?\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03)\x08\x10\n\x0c\n\x05\
    \x04\x01\x02\x03\x06\x12\x03)\x11/\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\
    \x03)0:\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03)=>\n\n\n\x02\x04\x02\x12\
    \x04,\01\x01\n\n\n\x03\x04\x02\x01\x12\x03,\x08'\n\x0b\n\x04\x04\x02\x02\
    \0\x12\x03-\x08\"\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03-\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\0\x05\x12\x03-\x11\x16\n\x0c\n\x05\x04\x02\x02\0\x01\
    \x12\x03-\x17\x1d\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03-\x20!\n\x0b\n\
    \x04\x04\x02\x02\x01\x12\x03.\x08#\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\
    \x03.\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03.\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x01\x01\x12\x03.\x18\x1e\n\x0c\n\x05\x04\x02\x02\x01\
    \x03\x12\x03.!\"\n\x0b\n\x04\x04\x02\x02\x02\x12\x03/\x08\x20\n\x0c\n\
    \x05\x04\x02\x02\x02\x04\x12\x03/\x08\x10\n\x0c\n\x05\x04\x02\x02\x02\
    \x05\x12\x03/\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03/\x18\x1b\n\
    \x0c\n\x05\x04\x02\x02\x02\x03\x12\x03/\x1e\x1f\n\x0b\n\x04\x04\x02\x02\
    \x03\x12\x030\x08%\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x030\x08\x10\n\
    \x0c\n\x05\x04\x02\x02\x03\x05\x12\x030\x11\x17\n\x0c\n\x05\x04\x02\x02\
    \x03\x01\x12\x030\x18\x20\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x030#$\n\n\
    \n\x02\x04\x03\x12\x043\07\x01\n\n\n\x03\x04\x03\x01\x12\x033\x08\x16\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x034\x08:\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x034\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x034\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x034\x18\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\
    \x034#$\n\x0c\n\x05\x04\x03\x02\0\x08\x12\x034%9\n\x0f\n\x08\x04\x03\x02\
    \0\x08\xe0\xd4\x03\x12\x034&8\n\x0b\n\x04\x04\x03\x02\x01\x12\x035\x08'\
    \n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x035\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x01\x05\x12\x035\x11\x18\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x035\
    \x19\"\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x035%&\n\x0b\n\x04\x04\x03\
    \x02\x02\x12\x036\x08(\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x036\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x036\x11\x17\n\x0c\n\x05\x04\x03\
    \x02\x02\x01\x12\x036\x18#\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x036&'\n\
    \n\n\x02\x04\x04\x12\x049\0=\x01\n\n\n\x03\x04\x04\x01\x12\x039\x08\x16\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03:\x08:\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x03:\x08\x10\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03:\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03:\x18\x20\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03:#$\n\x0c\n\x05\x04\x04\x02\0\x08\x12\x03:%9\n\x0f\n\x08\x04\x04\
    \x02\0\x08\xe0\xd4\x03\x12\x03:&8\n\x0b\n\x04\x04\x04\x02\x01\x12\x03;\
    \x08'\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03;\x08\x10\n\x0c\n\x05\x04\
    \x04\x02\x01\x05\x12\x03;\x11\x18\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\
    \x03;\x19\"\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03;%&\n\x0b\n\x04\x04\
    \x04\x02\x02\x12\x03<\x08(\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03<\x08\
    \x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03<\x11\x17\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x03<\x18#\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03<&\
    '\n\n\n\x02\x04\x05\x12\x04?\0A\x01\n\n\n\x03\x04\x05\x01\x12\x03?\x08\
    \x1b\n\x0b\n\x04\x04\x05\x02\0\x12\x03@\x08$\n\x0c\n\x05\x04\x05\x02\0\
    \x04\x12\x03@\x08\x10\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03@\x11\x17\n\
    \x0c\n\x05\x04\x05\x02\0\x01\x12\x03@\x18\x1f\n\x0c\n\x05\x04\x05\x02\0\
    \x03\x12\x03@\"#\n\n\n\x02\x04\x06\x12\x04C\0G\x01\n\n\n\x03\x04\x06\x01\
    \x12\x03C\x08\x19\n\x0b\n\x04\x04\x06\x02\0\x12\x03D\x08&\n\x0c\n\x05\
    \x04\x06\x02\0\x04\x12\x03D\x08\x10\n\x0c\n\x05\x04\x06\x02\0\x05\x12\
    \x03D\x11\x18\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03D\x19!\n\x0c\n\x05\
    \x04\x06\x02\0\x03\x12\x03D$%\n\x0b\n\x04\x04\x06\x02\x01\x12\x03E\x08+\
    \n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03E\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\x01\x05\x12\x03E\x11\x17\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03E\
    \x18&\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03E)*\n\x0b\n\x04\x04\x06\x02\
    \x02\x12\x03F\x08(\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03F\x08\x10\n\
    \x0c\n\x05\x04\x06\x02\x02\x05\x12\x03F\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \x02\x01\x12\x03F\x18#\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03F&'\n\n\n\
    \x02\x04\x07\x12\x04I\0L\x01\n\n\n\x03\x04\x07\x01\x12\x03I\x08\x1d\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03J\x08%\n\x0c\n\x05\x04\x07\x02\0\x04\x12\
    \x03J\x08\x10\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03J\x11\x17\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03J\x18\x20\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03J#$\n\x0b\n\x04\x04\x07\x02\x01\x12\x03K\x08&\n\x0c\n\x05\x04\x07\
    \x02\x01\x04\x12\x03K\x08\x10\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03K\
    \x11\x18\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03K\x19!\n\x0c\n\x05\x04\
    \x07\x02\x01\x03\x12\x03K$%\n\n\n\x02\x04\x08\x12\x04N\0S\x01\n\n\n\x03\
    \x04\x08\x01\x12\x03N\x08\x1f\n\x0b\n\x04\x04\x08\x02\0\x12\x03O\x08%\n\
    \x0c\n\x05\x04\x08\x02\0\x04\x12\x03O\x08\x10\n\x0c\n\x05\x04\x08\x02\0\
    \x05\x12\x03O\x11\x17\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03O\x18\x20\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03O#$\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03P\x08!\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03P\x08\x10\n\x0c\n\x05\
    \x04\x08\x02\x01\x05\x12\x03P\x11\x15\n\x0c\n\x05\x04\x08\x02\x01\x01\
    \x12\x03P\x16\x1c\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03P\x1f\x20\n\x0b\
    \n\x04\x04\x08\x02\x02\x12\x03Q\x08+\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\
    \x03Q\x08\x10\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03Q\x11\x17\n\x0c\n\
    \x05\x04\x08\x02\x02\x01\x12\x03Q\x18&\n\x0c\n\x05\x04\x08\x02\x02\x03\
    \x12\x03Q)*\n\x0b\n\x04\x04\x08\x02\x03\x12\x03R\x08(\n\x0c\n\x05\x04\
    \x08\x02\x03\x04\x12\x03R\x08\x10\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\
    \x03R\x11\x17\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03R\x18#\n\x0c\n\x05\
    \x04\x08\x02\x03\x03\x12\x03R&'\n\n\n\x02\x04\t\x12\x04U\0W\x01\n\n\n\
    \x03\x04\t\x01\x12\x03U\x08\x19\n\x0b\n\x04\x04\t\x02\0\x12\x03V\x08&\n\
    \x0c\n\x05\x04\t\x02\0\x04\x12\x03V\x08\x10\n\x0c\n\x05\x04\t\x02\0\x05\
    \x12\x03V\x11\x18\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03V\x19!\n\x0c\n\x05\
    \x04\t\x02\0\x03\x12\x03V$%\n\n\n\x02\x04\n\x12\x04Y\0Z\x01\n\n\n\x03\
    \x04\n\x01\x12\x03Y\x08\x16\n\n\n\x02\x04\x0b\x12\x04\\\0]\x01\n\n\n\x03\
    \x04\x0b\x01\x12\x03\\\x08\x1b\n\n\n\x02\x04\x0c\x12\x04_\0a\x01\n\n\n\
    \x03\x04\x0c\x01\x12\x03_\x08\x1e\n\x0b\n\x04\x04\x0c\x02\0\x12\x03`\x08\
    &\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x0c\x02\
    \0\x05\x12\x03`\x11\x18\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03`\x19!\n\
    \x0c\n\x05\x04\x0c\x02\0\x03\x12\x03`$%\n\n\n\x02\x04\r\x12\x04c\0i\x01\
    \n\n\n\x03\x04\r\x01\x12\x03c\x08\x20\n\x0b\n\x04\x04\r\x02\0\x12\x03d\
    \x08D\n\x0c\n\x05\x04\r\x02\0\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\r\x02\
    \0\x05\x12\x03d\x11\x17\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03d\x181\n\x0c\
    \n\x05\x04\r\x02\0\x03\x12\x03d45\n\x0c\n\x05\x04\r\x02\0\x08\x12\x03d6C\
    \n\x0c\n\x05\x04\r\x02\0\x07\x12\x03dAB\n\x0b\n\x04\x04\r\x02\x01\x12\
    \x03e\x089\n\x0c\n\x05\x04\r\x02\x01\x04\x12\x03e\x08\x10\n\x0c\n\x05\
    \x04\r\x02\x01\x05\x12\x03e\x11\x18\n\x0c\n\x05\x04\r\x02\x01\x01\x12\
    \x03e\x193\n\x0c\n\x05\x04\r\x02\x01\x03\x12\x03e68\n\x0b\n\x04\x04\r\
    \x02\x02\x12\x03f\x080\n\x0c\n\x05\x04\r\x02\x02\x04\x12\x03f\x08\x10\n\
    \x0c\n\x05\x04\r\x02\x02\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\r\x02\x02\
    \x01\x12\x03f\x18*\n\x0c\n\x05\x04\r\x02\x02\x03\x12\x03f-/\n\x0b\n\x04\
    \x04\r\x02\x03\x12\x03g\x08,\n\x0c\n\x05\x04\r\x02\x03\x04\x12\x03g\x08\
    \x10\n\x0c\n\x05\x04\r\x02\x03\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\r\
    \x02\x03\x01\x12\x03g\x18&\n\x0c\n\x05\x04\r\x02\x03\x03\x12\x03g)+\n\
    \x0b\n\x04\x04\r\x02\x04\x12\x03h\x080\n\x0c\n\x05\x04\r\x02\x04\x04\x12\
    \x03h\x08\x10\n\x0c\n\x05\x04\r\x02\x04\x05\x12\x03h\x11\x17\n\x0c\n\x05\
    \x04\r\x02\x04\x01\x12\x03h\x18*\n\x0c\n\x05\x04\r\x02\x04\x03\x12\x03h-\
    /\n\n\n\x02\x04\x0e\x12\x04k\0q\x01\n\n\n\x03\x04\x0e\x01\x12\x03k\x08\
    \x20\n\x0b\n\x04\x04\x0e\x02\0\x12\x03l\x08\x1e\n\x0c\n\x05\x04\x0e\x02\
    \0\x04\x12\x03l\x08\x10\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03l\x11\x16\n\
    \x0c\n\x05\x04\x0e\x02\0\x01\x12\x03l\x17\x19\n\x0c\n\x05\x04\x0e\x02\0\
    \x03\x12\x03l\x1c\x1d\n\x0b\n\x04\x04\x0e\x02\x01\x12\x03m\x08\"\n\x0c\n\
    \x05\x04\x0e\x02\x01\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\x0e\x02\x01\
    \x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\x0e\x02\x01\x01\x12\x03m\x18\x1d\n\
    \x0c\n\x05\x04\x0e\x02\x01\x03\x12\x03m\x20!\n\x0b\n\x04\x04\x0e\x02\x02\
    \x12\x03n\x08#\n\x0c\n\x05\x04\x0e\x02\x02\x04\x12\x03n\x08\x10\n\x0c\n\
    \x05\x04\x0e\x02\x02\x05\x12\x03n\x11\x15\n\x0c\n\x05\x04\x0e\x02\x02\
    \x01\x12\x03n\x16\x1e\n\x0c\n\x05\x04\x0e\x02\x02\x03\x12\x03n!\"\n\x0b\
    \n\x04\x04\x0e\x02\x03\x12\x03o\x08'\n\x0c\n\x05\x04\x0e\x02\x03\x04\x12\
    \x03o\x08\x10\n\x0c\n\x05\x04\x0e\x02\x03\x05\x12\x03o\x11\x16\n\x0c\n\
    \x05\x04\x0e\x02\x03\x01\x12\x03o\x17\"\n\x0c\n\x05\x04\x0e\x02\x03\x03\
    \x12\x03o%&\n\x0b\n\x04\x04\x0e\x02\x04\x12\x03p\x08)\n\x0c\n\x05\x04\
    \x0e\x02\x04\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x0e\x02\x04\x05\x12\
    \x03p\x11\x17\n\x0c\n\x05\x04\x0e\x02\x04\x01\x12\x03p\x18$\n\x0c\n\x05\
    \x04\x0e\x02\x04\x03\x12\x03p'(\n\n\n\x02\x04\x0f\x12\x04s\0\x7f\x01\n\n\
    \n\x03\x04\x0f\x01\x12\x03s\x08\x17\n\x0b\n\x04\x04\x0f\x02\0\x12\x03t\
    \x08'\n\x0c\n\x05\x04\x0f\x02\0\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x0f\
    \x02\0\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03t\x18\"\
    \n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03t%&\n\x0b\n\x04\x04\x0f\x02\x01\
    \x12\x03u\x08(\n\x0c\n\x05\x04\x0f\x02\x01\x04\x12\x03u\x08\x10\n\x0c\n\
    \x05\x04\x0f\x02\x01\x05\x12\x03u\x11\x16\n\x0c\n\x05\x04\x0f\x02\x01\
    \x01\x12\x03u\x17#\n\x0c\n\x05\x04\x0f\x02\x01\x03\x12\x03u&'\n\x0b\n\
    \x04\x04\x0f\x02\x02\x12\x03v\x08)\n\x0c\n\x05\x04\x0f\x02\x02\x04\x12\
    \x03v\x08\x10\n\x0c\n\x05\x04\x0f\x02\x02\x05\x12\x03v\x11\x15\n\x0c\n\
    \x05\x04\x0f\x02\x02\x01\x12\x03v\x16$\n\x0c\n\x05\x04\x0f\x02\x02\x03\
    \x12\x03v'(\n\x0b\n\x04\x04\x0f\x02\x03\x12\x03w\x08+\n\x0c\n\x05\x04\
    \x0f\x02\x03\x04\x12\x03w\x08\x10\n\x0c\n\x05\x04\x0f\x02\x03\x05\x12\
    \x03w\x11\x15\n\x0c\n\x05\x04\x0f\x02\x03\x01\x12\x03w\x16&\n\x0c\n\x05\
    \x04\x0f\x02\x03\x03\x12\x03w)*\n\x0b\n\x04\x04\x0f\x02\x04\x12\x03x\x08\
    .\n\x0c\n\x05\x04\x0f\x02\x04\x04\x12\x03x\x08\x10\n\x0c\n\x05\x04\x0f\
    \x02\x04\x05\x12\x03x\x11\x17\n\x0c\n\x05\x04\x0f\x02\x04\x01\x12\x03x\
    \x18)\n\x0c\n\x05\x04\x0f\x02\x04\x03\x12\x03x,-\n\x0b\n\x04\x04\x0f\x02\
    \x05\x12\x03y\x08-\n\x0c\n\x05\x04\x0f\x02\x05\x04\x12\x03y\x08\x10\n\
    \x0c\n\x05\x04\x0f\x02\x05\x05\x12\x03y\x11\x17\n\x0c\n\x05\x04\x0f\x02\
    \x05\x01\x12\x03y\x18(\n\x0c\n\x05\x04\x0f\x02\x05\x03\x12\x03y+,\n\x0b\
    \n\x04\x04\x0f\x02\x06\x12\x03z\x08.\n\x0c\n\x05\x04\x0f\x02\x06\x04\x12\
    \x03z\x08\x10\n\x0c\n\x05\x04\x0f\x02\x06\x05\x12\x03z\x11\x15\n\x0c\n\
    \x05\x04\x0f\x02\x06\x01\x12\x03z\x16)\n\x0c\n\x05\x04\x0f\x02\x06\x03\
    \x12\x03z,-\n\x0b\n\x04\x04\x0f\x02\x07\x12\x03{\x08:\n\x0c\n\x05\x04\
    \x0f\x02\x07\x04\x12\x03{\x08\x10\n\x0c\n\x05\x04\x0f\x02\x07\x06\x12\
    \x03{\x11*\n\x0c\n\x05\x04\x0f\x02\x07\x01\x12\x03{+5\n\x0c\n\x05\x04\
    \x0f\x02\x07\x03\x12\x03{89\n\x0b\n\x04\x04\x0f\x02\x08\x12\x03|\x08(\n\
    \x0c\n\x05\x04\x0f\x02\x08\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x0f\x02\
    \x08\x05\x12\x03|\x11\x16\n\x0c\n\x05\x04\x0f\x02\x08\x01\x12\x03|\x17\"\
    \n\x0c\n\x05\x04\x0f\x02\x08\x03\x12\x03|%'\n\x0b\n\x04\x04\x0f\x02\t\
    \x12\x03}\x08+\n\x0c\n\x05\x04\x0f\x02\t\x04\x12\x03}\x08\x10\n\x0c\n\
    \x05\x04\x0f\x02\t\x05\x12\x03}\x11\x15\n\x0c\n\x05\x04\x0f\x02\t\x01\
    \x12\x03}\x16%\n\x0c\n\x05\x04\x0f\x02\t\x03\x12\x03}(*\n\x0b\n\x04\x04\
    \x0f\x02\n\x12\x03~\x08'\n\x0c\n\x05\x04\x0f\x02\n\x04\x12\x03~\x08\x10\
    \n\x0c\n\x05\x04\x0f\x02\n\x05\x12\x03~\x11\x15\n\x0c\n\x05\x04\x0f\x02\
    \n\x01\x12\x03~\x16!\n\x0c\n\x05\x04\x0f\x02\n\x03\x12\x03~$&\n\x0c\n\
    \x02\x04\x10\x12\x06\x81\x01\0\x95\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\x81\x01\x08\x15\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x82\x01\x08&\n\r\
    \n\x05\x04\x10\x02\0\x04\x12\x04\x82\x01\x08\x10\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x82\x01\
    \x18!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x82\x01$%\n\x0c\n\x04\x04\x10\
    \x02\x01\x12\x04\x83\x01\x08!\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x83\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\x83\x01\x11\x17\n\r\n\
    \x05\x04\x10\x02\x01\x01\x12\x04\x83\x01\x18\x1c\n\r\n\x05\x04\x10\x02\
    \x01\x03\x12\x04\x83\x01\x1f\x20\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\x84\
    \x01\x08\x20\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\x84\x01\x08\x10\n\r\n\
    \x05\x04\x10\x02\x02\x05\x12\x04\x84\x01\x11\x17\n\r\n\x05\x04\x10\x02\
    \x02\x01\x12\x04\x84\x01\x18\x1b\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\
    \x84\x01\x1e\x1f\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\x85\x01\x08(\n\r\n\
    \x05\x04\x10\x02\x03\x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x10\x02\
    \x03\x05\x12\x04\x85\x01\x11\x17\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\
    \x85\x01\x18#\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\x85\x01&'\n\x0c\n\
    \x04\x04\x10\x02\x04\x12\x04\x86\x01\x08)\n\r\n\x05\x04\x10\x02\x04\x04\
    \x12\x04\x86\x01\x08\x10\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\x86\x01\
    \x11\x17\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\x86\x01\x18$\n\r\n\x05\
    \x04\x10\x02\x04\x03\x12\x04\x86\x01'(\n\x0c\n\x04\x04\x10\x02\x05\x12\
    \x04\x87\x01\x08!\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\x87\x01\x08\x10\
    \n\r\n\x05\x04\x10\x02\x05\x05\x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x10\
    \x02\x05\x01\x12\x04\x87\x01\x18\x1c\n\r\n\x05\x04\x10\x02\x05\x03\x12\
    \x04\x87\x01\x1f\x20\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\x88\x01\x08!\n\
    \r\n\x05\x04\x10\x02\x06\x04\x12\x04\x88\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\x06\x05\x12\x04\x88\x01\x11\x17\n\r\n\x05\x04\x10\x02\x06\x01\x12\
    \x04\x88\x01\x18\x1c\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\x88\x01\x1f\
    \x20\n\x0c\n\x04\x04\x10\x02\x07\x12\x04\x89\x01\x08!\n\r\n\x05\x04\x10\
    \x02\x07\x04\x12\x04\x89\x01\x08\x10\n\r\n\x05\x04\x10\x02\x07\x05\x12\
    \x04\x89\x01\x11\x17\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\x89\x01\x18\
    \x1c\n\r\n\x05\x04\x10\x02\x07\x03\x12\x04\x89\x01\x1f\x20\n\x0c\n\x04\
    \x04\x10\x02\x08\x12\x04\x8a\x01\x08!\n\r\n\x05\x04\x10\x02\x08\x04\x12\
    \x04\x8a\x01\x08\x10\n\r\n\x05\x04\x10\x02\x08\x05\x12\x04\x8a\x01\x11\
    \x17\n\r\n\x05\x04\x10\x02\x08\x01\x12\x04\x8a\x01\x18\x1c\n\r\n\x05\x04\
    \x10\x02\x08\x03\x12\x04\x8a\x01\x1f\x20\n\x0c\n\x04\x04\x10\x02\t\x12\
    \x04\x8b\x01\x08\"\n\r\n\x05\x04\x10\x02\t\x04\x12\x04\x8b\x01\x08\x10\n\
    \r\n\x05\x04\x10\x02\t\x05\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x10\x02\
    \t\x01\x12\x04\x8b\x01\x18\x1c\n\r\n\x05\x04\x10\x02\t\x03\x12\x04\x8b\
    \x01\x1f!\n\x0c\n\x04\x04\x10\x02\n\x12\x04\x8c\x01\x08\"\n\r\n\x05\x04\
    \x10\x02\n\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x10\x02\n\x05\x12\
    \x04\x8c\x01\x11\x17\n\r\n\x05\x04\x10\x02\n\x01\x12\x04\x8c\x01\x18\x1c\
    \n\r\n\x05\x04\x10\x02\n\x03\x12\x04\x8c\x01\x1f!\n\x0c\n\x04\x04\x10\
    \x02\x0b\x12\x04\x8d\x01\x083\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\x8d\
    \x01\x08\x10\n\r\n\x05\x04\x10\x02\x0b\x05\x12\x04\x8d\x01\x11\x15\n\r\n\
    \x05\x04\x10\x02\x0b\x01\x12\x04\x8d\x01\x16-\n\r\n\x05\x04\x10\x02\x0b\
    \x03\x12\x04\x8d\x0102\n\x0c\n\x04\x04\x10\x02\x0c\x12\x04\x8e\x01\x082\
    \n\r\n\x05\x04\x10\x02\x0c\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\x0c\x05\x12\x04\x8e\x01\x11\x15\n\r\n\x05\x04\x10\x02\x0c\x01\x12\
    \x04\x8e\x01\x16,\n\r\n\x05\x04\x10\x02\x0c\x03\x12\x04\x8e\x01/1\n\x0c\
    \n\x04\x04\x10\x02\r\x12\x04\x8f\x01\x083\n\r\n\x05\x04\x10\x02\r\x04\
    \x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x10\x02\r\x05\x12\x04\x8f\x01\x11\
    \x16\n\r\n\x05\x04\x10\x02\r\x01\x12\x04\x8f\x01\x17-\n\r\n\x05\x04\x10\
    \x02\r\x03\x12\x04\x8f\x0102\n\x0c\n\x04\x04\x10\x02\x0e\x12\x04\x90\x01\
    \x082\n\r\n\x05\x04\x10\x02\x0e\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\
    \x04\x10\x02\x0e\x05\x12\x04\x90\x01\x11\x16\n\r\n\x05\x04\x10\x02\x0e\
    \x01\x12\x04\x90\x01\x17,\n\r\n\x05\x04\x10\x02\x0e\x03\x12\x04\x90\x01/\
    1\n\x0c\n\x04\x04\x10\x02\x0f\x12\x04\x91\x01\x08+\n\r\n\x05\x04\x10\x02\
    \x0f\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x10\x02\x0f\x05\x12\x04\
    \x91\x01\x11\x16\n\r\n\x05\x04\x10\x02\x0f\x01\x12\x04\x91\x01\x17%\n\r\
    \n\x05\x04\x10\x02\x0f\x03\x12\x04\x91\x01(*\n\x0c\n\x04\x04\x10\x02\x10\
    \x12\x04\x92\x01\x08<\n\r\n\x05\x04\x10\x02\x10\x04\x12\x04\x92\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\x10\x06\x12\x04\x92\x01\x11!\n\r\n\x05\x04\
    \x10\x02\x10\x01\x12\x04\x92\x01\"6\n\r\n\x05\x04\x10\x02\x10\x03\x12\
    \x04\x92\x019;\n\x0c\n\x04\x04\x10\x02\x11\x12\x04\x93\x01\x08=\n\r\n\
    \x05\x04\x10\x02\x11\x04\x12\x04\x93\x01\x08\x10\n\r\n\x05\x04\x10\x02\
    \x11\x06\x12\x04\x93\x01\x11!\n\r\n\x05\x04\x10\x02\x11\x01\x12\x04\x93\
    \x01\"7\n\r\n\x05\x04\x10\x02\x11\x03\x12\x04\x93\x01:<\n\x0c\n\x04\x04\
    \x10\x02\x12\x12\x04\x94\x01\x084\n\r\n\x05\x04\x10\x02\x12\x04\x12\x04\
    \x94\x01\x08\x10\n\r\n\x05\x04\x10\x02\x12\x05\x12\x04\x94\x01\x11\x17\n\
    \r\n\x05\x04\x10\x02\x12\x01\x12\x04\x94\x01\x18.\n\r\n\x05\x04\x10\x02\
    \x12\x03\x12\x04\x94\x0113\n\x0c\n\x02\x04\x11\x12\x06\x97\x01\0\x9a\x01\
    \x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x97\x01\x08\x1d\n\x0c\n\x04\x04\x11\
    \x02\0\x12\x04\x98\x01\x08&\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\x98\x01\
    \x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\x98\x01\x11\x18\n\r\n\x05\
    \x04\x11\x02\0\x01\x12\x04\x98\x01\x19!\n\r\n\x05\x04\x11\x02\0\x03\x12\
    \x04\x98\x01$%\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\x99\x01\x08/\n\r\n\
    \x05\x04\x11\x02\x01\x04\x12\x04\x99\x01\x08\x10\n\r\n\x05\x04\x11\x02\
    \x01\x06\x12\x04\x99\x01\x11!\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x99\
    \x01\"*\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\x99\x01-.\n\x0c\n\x02\x04\
    \x12\x12\x06\x9c\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x9c\
    \x01\x08'\n\x0c\n\x04\x04\x12\x02\0\x12\x04\x9d\x01\x08/\n\r\n\x05\x04\
    \x12\x02\0\x04\x12\x04\x9d\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\
    \x04\x9d\x01\x11\x18\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\x9d\x01\x19*\n\
    \r\n\x05\x04\x12\x02\0\x03\x12\x04\x9d\x01-.\n\x0c\n\x04\x04\x12\x02\x01\
    \x12\x04\x9e\x01\x08/\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\x9e\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\x9e\x01\x11\x18\n\r\n\x05\x04\
    \x12\x02\x01\x01\x12\x04\x9e\x01\x19*\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\x9e\x01-.\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\x9f\x01\x08$\n\r\n\
    \x05\x04\x12\x02\x02\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\x04\x12\x02\
    \x02\x05\x12\x04\x9f\x01\x11\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\
    \x9f\x01\x18\x1f\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\x9f\x01\"#\n\x0c\
    \n\x04\x04\x12\x02\x03\x12\x04\xa0\x01\x08'\n\r\n\x05\x04\x12\x02\x03\
    \x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\xa0\
    \x01\x11\x17\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xa0\x01\x18\"\n\r\n\
    \x05\x04\x12\x02\x03\x03\x12\x04\xa0\x01%&\n\x0c\n\x04\x04\x12\x02\x04\
    \x12\x04\xa1\x01\x08#\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\xa1\x01\x08\
    \x10\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xa1\x01\x11\x17\n\r\n\x05\x04\
    \x12\x02\x04\x01\x12\x04\xa1\x01\x18\x1e\n\r\n\x05\x04\x12\x02\x04\x03\
    \x12\x04\xa1\x01!\"\n\x0c\n\x02\x04\x13\x12\x06\xa4\x01\0\xaa\x01\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\xa4\x01\x08\x18\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xa5\x01\x08,\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xa5\x01\x08\
    \x10\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\
    \x13\x02\0\x01\x12\x04\xa5\x01\x18'\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xa5\x01*+\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\xa6\x01\x08)\n\r\n\x05\
    \x04\x13\x02\x01\x04\x12\x04\xa6\x01\x08\x10\n\r\n\x05\x04\x13\x02\x01\
    \x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xa6\
    \x01\x18$\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\xa6\x01'(\n\x0c\n\x04\
    \x04\x13\x02\x02\x12\x04\xa7\x01\x08)\n\r\n\x05\x04\x13\x02\x02\x04\x12\
    \x04\xa7\x01\x08\x10\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xa7\x01\x11\
    \x17\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xa7\x01\x18$\n\r\n\x05\x04\
    \x13\x02\x02\x03\x12\x04\xa7\x01'(\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\
    \xa8\x01\x08,\n\r\n\x05\x04\x13\x02\x03\x04\x12\x04\xa8\x01\x08\x10\n\r\
    \n\x05\x04\x13\x02\x03\x05\x12\x04\xa8\x01\x11\x17\n\r\n\x05\x04\x13\x02\
    \x03\x01\x12\x04\xa8\x01\x18'\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xa8\
    \x01*+\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xa9\x01\x08(\n\r\n\x05\x04\
    \x13\x02\x04\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x13\x02\x04\x05\
    \x12\x04\xa9\x01\x11\x16\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xa9\x01\
    \x17#\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xa9\x01&'\n\x0c\n\x02\x04\
    \x14\x12\x06\xac\x01\0\xb0\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xac\
    \x01\x08\x1f\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xad\x01\x08$\n\r\n\x05\
    \x04\x14\x02\0\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x14\x02\0\x05\
    \x12\x04\xad\x01\x11\x17\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xad\x01\x18\
    \x1f\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xad\x01\"#\n\x0c\n\x04\x04\x14\
    \x02\x01\x12\x04\xae\x01\x08(\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xae\
    \x01\x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xae\x01\x11\x17\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\xae\x01\x18#\n\r\n\x05\x04\x14\x02\x01\
    \x03\x12\x04\xae\x01&'\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xaf\x01\x08'\
    \n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x14\
    \x02\x02\x05\x12\x04\xaf\x01\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\
    \x04\xaf\x01\x18\"\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xaf\x01%&\n\x0c\
    \n\x02\x04\x15\x12\x06\xb2\x01\0\xb6\x01\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\xb2\x01\x08\x1d\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xb3\x01\x08)\n\r\
    \n\x05\x04\x15\x02\0\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xb3\x01\
    \x18$\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb3\x01'(\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\xb4\x01\x08+\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xb4\
    \x01\x08\x10\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xb4\x01\x11\x17\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\xb4\x01\x18&\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\xb4\x01)*\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xb5\x01\x08+\
    \n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x15\
    \x02\x02\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x15\x02\x02\x01\x12\
    \x04\xb5\x01\x18&\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xb5\x01)*\n\x0c\
    \n\x02\x04\x16\x12\x06\xb8\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xb8\x01\x08\x1c\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xb9\x01\x081\n\r\
    \n\x05\x04\x16\x02\0\x04\x12\x04\xb9\x01\x08\x10\n\r\n\x05\x04\x16\x02\0\
    \x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb9\x01\
    \x18,\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xb9\x01/0\n\x0c\n\x04\x04\x16\
    \x02\x01\x12\x04\xba\x01\x08)\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xba\
    \x01\x08\x10\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xba\x01\x11\x17\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\xba\x01\x18$\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\xba\x01'(\n\x0c\n\x02\x04\x17\x12\x06\xbd\x01\0\xc0\x01\x01\
    \n\x0b\n\x03\x04\x17\x01\x12\x04\xbd\x01\x08\x1f\n\x0c\n\x04\x04\x17\x02\
    \0\x12\x04\xbe\x01\x08,\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xbe\x01\x08\
    \x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\xbe\x01\x18'\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\
    \xbe\x01*+\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xbf\x01\x08,\n\r\n\x05\
    \x04\x17\x02\x01\x04\x12\x04\xbf\x01\x08\x10\n\r\n\x05\x04\x17\x02\x01\
    \x05\x12\x04\xbf\x01\x11\x17\n\r\n\x05\x04\x17\x02\x01\x01\x12\x04\xbf\
    \x01\x18'\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xbf\x01*+\n\x0c\n\x02\
    \x04\x18\x12\x06\xc2\x01\0\xc5\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \xc2\x01\x08\x1b\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xc3\x01\x08,\n\r\n\
    \x05\x04\x18\x02\0\x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xc3\x01\
    \x18'\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xc3\x01*+\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\xc4\x01\x08(\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xc4\
    \x01\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xc4\x01\x11\x17\n\r\n\
    \x05\x04\x18\x02\x01\x01\x12\x04\xc4\x01\x18#\n\r\n\x05\x04\x18\x02\x01\
    \x03\x12\x04\xc4\x01&'\n\x0c\n\x02\x04\x19\x12\x06\xc7\x01\0\xcb\x01\x01\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\xc7\x01\x08\x1c\n\x0c\n\x04\x04\x19\x02\
    \0\x12\x04\xc8\x01\x08&\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xc8\x01\x08\
    \x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xc8\x01\x11\x17\n\r\n\x05\x04\
    \x19\x02\0\x01\x12\x04\xc8\x01\x18!\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\
    \xc8\x01$%\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\xc9\x01\x08\"\n\r\n\x05\
    \x04\x19\x02\x01\x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\x19\x02\x01\
    \x05\x12\x04\xc9\x01\x11\x17\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xc9\
    \x01\x18\x1d\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xc9\x01\x20!\n\x0c\n\
    \x04\x04\x19\x02\x02\x12\x04\xca\x01\x08'\n\r\n\x05\x04\x19\x02\x02\x04\
    \x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xca\x01\
    \x11\x16\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xca\x01\x17\"\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\xca\x01%&\n\x0c\n\x02\x04\x1a\x12\x06\xcd\
    \x01\0\xd0\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\xcd\x01\x08\x1b\n\x0c\
    \n\x04\x04\x1a\x02\0\x12\x04\xce\x01\x08&\n\r\n\x05\x04\x1a\x02\0\x04\
    \x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xce\x01\x11\
    \x17\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xce\x01\x18!\n\r\n\x05\x04\x1a\
    \x02\0\x03\x12\x04\xce\x01$%\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xcf\x01\
    \x08%\n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xcf\x01\x08\x10\n\r\n\x05\
    \x04\x1a\x02\x01\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x1a\x02\x01\
    \x01\x12\x04\xcf\x01\x18\x20\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xcf\
    \x01#$\n\x0c\n\x02\x04\x1b\x12\x06\xd2\x01\0\xe5\x01\x01\n\x0b\n\x03\x04\
    \x1b\x01\x12\x04\xd2\x01\x08\x13\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xd3\
    \x01\x08\x1f\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xd3\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\0\x05\x12\x04\xd3\x01\x11\x17\n\r\n\x05\x04\x1b\x02\0\
    \x01\x12\x04\xd3\x01\x18\x1a\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xd3\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xd4\x01\x08'\n\r\n\x05\x04\
    \x1b\x02\x01\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x01\x05\
    \x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xd4\x01\
    \x18\"\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xd4\x01%&\n\x0c\n\x04\x04\
    \x1b\x02\x02\x12\x04\xd5\x01\x08&\n\r\n\x05\x04\x1b\x02\x02\x04\x12\x04\
    \xd5\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xd5\x01\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xd5\x01\x18!\n\r\n\x05\x04\x1b\x02\
    \x02\x03\x12\x04\xd5\x01$%\n\x0c\n\x04\x04\x1b\x02\x03\x12\x04\xd6\x01\
    \x08&\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xd6\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x03\x05\x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x03\
    \x01\x12\x04\xd6\x01\x18!\n\r\n\x05\x04\x1b\x02\x03\x03\x12\x04\xd6\x01$\
    %\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xd7\x01\x08%\n\r\n\x05\x04\x1b\x02\
    \x04\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\
    \xd7\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xd7\x01\x18\x20\n\
    \r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xd7\x01#$\n\x0c\n\x04\x04\x1b\x02\
    \x05\x12\x04\xd8\x01\x08\"\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\xd8\x01\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xd8\x01\x11\x17\n\r\n\x05\
    \x04\x1b\x02\x05\x01\x12\x04\xd8\x01\x18\x1d\n\r\n\x05\x04\x1b\x02\x05\
    \x03\x12\x04\xd8\x01\x20!\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xd9\x01\
    \x08$\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xd9\x01\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x06\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x06\
    \x01\x12\x04\xd9\x01\x18\x1f\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xd9\
    \x01\"#\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xda\x01\x080\n\r\n\x05\x04\
    \x1b\x02\x07\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\
    \x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xda\x01\
    \x18\x1d\n\r\n\x05\x04\x1b\x02\x07\x03\x12\x04\xda\x01\x20!\n\r\n\x05\
    \x04\x1b\x02\x07\x08\x12\x04\xda\x01\"/\n\r\n\x05\x04\x1b\x02\x07\x07\
    \x12\x04\xda\x01-.\n\x0c\n\x04\x04\x1b\x02\x08\x12\x04\xdb\x01\x08#\n\r\
    \n\x05\x04\x1b\x02\x08\x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x08\x05\x12\x04\xdb\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x08\x01\x12\x04\
    \xdb\x01\x18\x1e\n\r\n\x05\x04\x1b\x02\x08\x03\x12\x04\xdb\x01!\"\n\x0c\
    \n\x04\x04\x1b\x02\t\x12\x04\xdc\x01\x08)\n\r\n\x05\x04\x1b\x02\t\x04\
    \x12\x04\xdc\x01\x08\x10\n\r\n\x05\x04\x1b\x02\t\x05\x12\x04\xdc\x01\x11\
    \x17\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\xdc\x01\x18#\n\r\n\x05\x04\x1b\
    \x02\t\x03\x12\x04\xdc\x01&(\n\x0c\n\x04\x04\x1b\x02\n\x12\x04\xdd\x01\
    \x08)\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\xdd\x01\x08\x10\n\r\n\x05\x04\
    \x1b\x02\n\x05\x12\x04\xdd\x01\x11\x17\n\r\n\x05\x04\x1b\x02\n\x01\x12\
    \x04\xdd\x01\x18#\n\r\n\x05\x04\x1b\x02\n\x03\x12\x04\xdd\x01&(\n\x0c\n\
    \x04\x04\x1b\x02\x0b\x12\x04\xde\x01\x086\n\r\n\x05\x04\x1b\x02\x0b\x04\
    \x12\x04\xde\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0b\x06\x12\x04\xde\x01\
    \x11&\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\xde\x01'0\n\r\n\x05\x04\x1b\
    \x02\x0b\x03\x12\x04\xde\x0135\n\x0c\n\x04\x04\x1b\x02\x0c\x12\x04\xdf\
    \x01\x081\n\r\n\x05\x04\x1b\x02\x0c\x04\x12\x04\xdf\x01\x08\x10\n\r\n\
    \x05\x04\x1b\x02\x0c\x06\x12\x04\xdf\x01\x11\x1d\n\r\n\x05\x04\x1b\x02\
    \x0c\x01\x12\x04\xdf\x01\x1e+\n\r\n\x05\x04\x1b\x02\x0c\x03\x12\x04\xdf\
    \x01.0\n\x0c\n\x04\x04\x1b\x02\r\x12\x04\xe0\x01\x084\n\r\n\x05\x04\x1b\
    \x02\r\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x1b\x02\r\x05\x12\x04\
    \xe0\x01\x11\x15\n\r\n\x05\x04\x1b\x02\r\x01\x12\x04\xe0\x01\x16\x1c\n\r\
    \n\x05\x04\x1b\x02\r\x03\x12\x04\xe0\x01\x1f!\n\r\n\x05\x04\x1b\x02\r\
    \x08\x12\x04\xe0\x01\"3\n\r\n\x05\x04\x1b\x02\r\x07\x12\x04\xe0\x01-2\n\
    \x0c\n\x04\x04\x1b\x02\x0e\x12\x04\xe1\x01\x081\n\r\n\x05\x04\x1b\x02\
    \x0e\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0e\x05\x12\x04\
    \xe1\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0e\x01\x12\x04\xe1\x01\x18\x1d\n\
    \r\n\x05\x04\x1b\x02\x0e\x03\x12\x04\xe1\x01\x20\"\n\r\n\x05\x04\x1b\x02\
    \x0e\x08\x12\x04\xe1\x01#0\n\r\n\x05\x04\x1b\x02\x0e\x07\x12\x04\xe1\x01\
    ./\n\x0c\n\x04\x04\x1b\x02\x0f\x12\x04\xe2\x01\x087\n\r\n\x05\x04\x1b\
    \x02\x0f\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x0f\x05\x12\
    \x04\xe2\x01\x11\x17\n\r\n\x05\x04\x1b\x02\x0f\x01\x12\x04\xe2\x01\x18#\
    \n\r\n\x05\x04\x1b\x02\x0f\x03\x12\x04\xe2\x01&(\n\r\n\x05\x04\x1b\x02\
    \x0f\x08\x12\x04\xe2\x01)6\n\r\n\x05\x04\x1b\x02\x0f\x07\x12\x04\xe2\x01\
    45\n\x0c\n\x04\x04\x1b\x02\x10\x12\x04\xe3\x01\x08:\n\r\n\x05\x04\x1b\
    \x02\x10\x04\x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x1b\x02\x10\x06\x12\
    \x04\xe3\x01\x11%\n\r\n\x05\x04\x1b\x02\x10\x01\x12\x04\xe3\x01&4\n\r\n\
    \x05\x04\x1b\x02\x10\x03\x12\x04\xe3\x0179\n\x0c\n\x04\x04\x1b\x02\x11\
    \x12\x04\xe4\x01\x08$\n\r\n\x05\x04\x1b\x02\x11\x04\x12\x04\xe4\x01\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x11\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x11\x01\x12\x04\xe4\x01\x18\x1e\n\r\n\x05\x04\x1b\x02\x11\x03\
    \x12\x04\xe4\x01!#\n\x0c\n\x02\x04\x1c\x12\x06\xe7\x01\0\xec\x01\x01\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xe7\x01\x08#\n\x0c\n\x04\x04\x1c\x02\0\
    \x12\x04\xe8\x01\x08$\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xe8\x01\x08\
    \x10\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xe8\x01\x18\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\
    \x04\xe8\x01\"#\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xe9\x01\x08&\n\r\n\
    \x05\x04\x1c\x02\x01\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x01\x05\x12\x04\xe9\x01\x11\x17\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\
    \xe9\x01\x18!\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xe9\x01$%\n\x0c\n\
    \x04\x04\x1c\x02\x02\x12\x04\xea\x01\x08%\n\r\n\x05\x04\x1c\x02\x02\x04\
    \x12\x04\xea\x01\x08\x10\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xea\x01\
    \x11\x17\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xea\x01\x18\x20\n\r\n\x05\
    \x04\x1c\x02\x02\x03\x12\x04\xea\x01#$\n\x0c\n\x04\x04\x1c\x02\x03\x12\
    \x04\xeb\x01\x08\x1f\n\r\n\x05\x04\x1c\x02\x03\x04\x12\x04\xeb\x01\x08\
    \x10\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xeb\x01\x11\x15\n\r\n\x05\x04\
    \x1c\x02\x03\x01\x12\x04\xeb\x01\x16\x1a\n\r\n\x05\x04\x1c\x02\x03\x03\
    \x12\x04\xeb\x01\x1d\x1e\n\x0c\n\x02\x04\x1d\x12\x06\xee\x01\0\xf2\x01\
    \x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xee\x01\x08(\n\x0c\n\x04\x04\x1d\
    \x02\0\x12\x04\xef\x01\x08%\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xef\x01\
    \x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xef\x01\x11\x17\n\r\n\x05\
    \x04\x1d\x02\0\x01\x12\x04\xef\x01\x18\x20\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xef\x01#$\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xf0\x01\x08&\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xf0\x01\x08\x10\n\r\n\x05\x04\x1d\x02\
    \x01\x05\x12\x04\xf0\x01\x11\x17\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\
    \xf0\x01\x18!\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xf0\x01$%\n\x0c\n\
    \x04\x04\x1d\x02\x02\x12\x04\xf1\x01\x08*\n\r\n\x05\x04\x1d\x02\x02\x04\
    \x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xf1\x01\
    \x11\x17\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\xf1\x01\x18%\n\r\n\x05\
    \x04\x1d\x02\x02\x03\x12\x04\xf1\x01()\n\x0c\n\x02\x04\x1e\x12\x06\xf4\
    \x01\0\xf6\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xf4\x01\x08\x15\n\x0c\
    \n\x04\x04\x1e\x02\0\x12\x04\xf5\x01\x08&\n\r\n\x05\x04\x1e\x02\0\x04\
    \x12\x04\xf5\x01\x08\x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xf5\x01\x11\
    \x17\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xf5\x01\x18!\n\r\n\x05\x04\x1e\
    \x02\0\x03\x12\x04\xf5\x01$%\n\x0c\n\x02\x04\x1f\x12\x06\xf8\x01\0\xfd\
    \x01\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xf8\x01\x08\x18\n\x0c\n\x04\x04\
    \x1f\x02\0\x12\x04\xf9\x01\x08'\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\xf9\
    \x01\x08\x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xf9\x01\x11\x17\n\r\n\
    \x05\x04\x1f\x02\0\x01\x12\x04\xf9\x01\x18\"\n\r\n\x05\x04\x1f\x02\0\x03\
    \x12\x04\xf9\x01%&\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\xfa\x01\x08&\n\r\
    \n\x05\x04\x1f\x02\x01\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x1f\x02\
    \x01\x05\x12\x04\xfa\x01\x11\x17\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\
    \xfa\x01\x18!\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xfa\x01$%\n\x0c\n\
    \x04\x04\x1f\x02\x02\x12\x04\xfb\x01\x08*\n\r\n\x05\x04\x1f\x02\x02\x04\
    \x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xfb\x01\
    \x11\x17\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xfb\x01\x18%\n\r\n\x05\
    \x04\x1f\x02\x02\x03\x12\x04\xfb\x01()\n\x0c\n\x04\x04\x1f\x02\x03\x12\
    \x04\xfc\x01\x08!\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xfc\x01\x08\x10\
    \n\r\n\x05\x04\x1f\x02\x03\x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04\x1f\
    \x02\x03\x01\x12\x04\xfc\x01\x18\x1c\n\r\n\x05\x04\x1f\x02\x03\x03\x12\
    \x04\xfc\x01\x1f\x20\n\x0c\n\x02\x04\x20\x12\x06\xff\x01\0\x82\x02\x01\n\
    \x0b\n\x03\x04\x20\x01\x12\x04\xff\x01\x08\x1c\n\x0c\n\x04\x04\x20\x02\0\
    \x12\x04\x80\x02\x081\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\x80\x02\x08\
    \x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x80\x02\x11\x18\n\r\n\x05\x04\
    \x20\x02\0\x01\x12\x04\x80\x02\x19,\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\
    \x80\x02/0\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x81\x02\x08$\n\r\n\x05\
    \x04\x20\x02\x01\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x20\x02\x01\
    \x05\x12\x04\x81\x02\x11\x16\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\x81\
    \x02\x17\x1f\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x81\x02\"#\n\x0c\n\
    \x02\x04!\x12\x06\x84\x02\0\x8a\x02\x01\n\x0b\n\x03\x04!\x01\x12\x04\x84\
    \x02\x08$\n\x0c\n\x04\x04!\x02\0\x12\x04\x85\x02\x08\"\n\r\n\x05\x04!\
    \x02\0\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04!\x02\0\x05\x12\x04\x85\
    \x02\x11\x16\n\r\n\x05\x04!\x02\0\x01\x12\x04\x85\x02\x17\x1d\n\r\n\x05\
    \x04!\x02\0\x03\x12\x04\x85\x02\x20!\n\x0c\n\x04\x04!\x02\x01\x12\x04\
    \x86\x02\x08/\n\r\n\x05\x04!\x02\x01\x04\x12\x04\x86\x02\x08\x10\n\r\n\
    \x05\x04!\x02\x01\x05\x12\x04\x86\x02\x11\x16\n\r\n\x05\x04!\x02\x01\x01\
    \x12\x04\x86\x02\x17*\n\r\n\x05\x04!\x02\x01\x03\x12\x04\x86\x02-.\n\x0c\
    \n\x04\x04!\x02\x02\x12\x04\x87\x02\x08/\n\r\n\x05\x04!\x02\x02\x04\x12\
    \x04\x87\x02\x08\x10\n\r\n\x05\x04!\x02\x02\x05\x12\x04\x87\x02\x11\x17\
    \n\r\n\x05\x04!\x02\x02\x01\x12\x04\x87\x02\x18*\n\r\n\x05\x04!\x02\x02\
    \x03\x12\x04\x87\x02-.\n\x0c\n\x04\x04!\x02\x03\x12\x04\x88\x02\x081\n\r\
    \n\x05\x04!\x02\x03\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04!\x02\x03\
    \x05\x12\x04\x88\x02\x11\x18\n\r\n\x05\x04!\x02\x03\x01\x12\x04\x88\x02\
    \x19,\n\r\n\x05\x04!\x02\x03\x03\x12\x04\x88\x02/0\n\x0c\n\x04\x04!\x02\
    \x04\x12\x04\x89\x02\x08'\n\r\n\x05\x04!\x02\x04\x04\x12\x04\x89\x02\x08\
    \x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\x89\x02\x11\x16\n\r\n\x05\x04!\
    \x02\x04\x01\x12\x04\x89\x02\x17\"\n\r\n\x05\x04!\x02\x04\x03\x12\x04\
    \x89\x02%&\n\x0c\n\x02\x04\"\x12\x06\x8c\x02\0\x90\x02\x01\n\x0b\n\x03\
    \x04\"\x01\x12\x04\x8c\x02\x08\x1c\n\x0c\n\x04\x04\"\x02\0\x12\x04\x8d\
    \x02\x08&\n\r\n\x05\x04\"\x02\0\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\
    \x04\"\x02\0\x05\x12\x04\x8d\x02\x11\x16\n\r\n\x05\x04\"\x02\0\x01\x12\
    \x04\x8d\x02\x17!\n\r\n\x05\x04\"\x02\0\x03\x12\x04\x8d\x02$%\n\x0c\n\
    \x04\x04\"\x02\x01\x12\x04\x8e\x02\x081\n\r\n\x05\x04\"\x02\x01\x04\x12\
    \x04\x8e\x02\x08\x10\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x8e\x02\x11\x18\
    \n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x8e\x02\x19,\n\r\n\x05\x04\"\x02\
    \x01\x03\x12\x04\x8e\x02/0\n\x0c\n\x04\x04\"\x02\x02\x12\x04\x8f\x02\x08\
    +\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \x8f\x02\x18&\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x8f\x02)*\n\x0c\n\x02\
    \x04#\x12\x06\x92\x02\0\x94\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\x92\x02\
    \x08\x13\n\x0c\n\x04\x04#\x02\0\x12\x04\x93\x02\x08'\n\r\n\x05\x04#\x02\
    \0\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04#\x02\0\x05\x12\x04\x93\x02\
    \x11\x17\n\r\n\x05\x04#\x02\0\x01\x12\x04\x93\x02\x18\"\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\x93\x02%&\n\x0c\n\x02\x04$\x12\x06\x96\x02\0\x97\x02\
    \x01\n\x0b\n\x03\x04$\x01\x12\x04\x96\x02\x08#\n\x0c\n\x02\x04%\x12\x06\
    \x99\x02\0\x9c\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\x99\x02\x08\x17\n\
    \x0c\n\x04\x04%\x02\0\x12\x04\x9a\x02\x08!\n\r\n\x05\x04%\x02\0\x04\x12\
    \x04\x9a\x02\x08\x10\n\r\n\x05\x04%\x02\0\x05\x12\x04\x9a\x02\x11\x17\n\
    \r\n\x05\x04%\x02\0\x01\x12\x04\x9a\x02\x18\x1c\n\r\n\x05\x04%\x02\0\x03\
    \x12\x04\x9a\x02\x1f\x20\n\x0c\n\x04\x04%\x02\x01\x12\x04\x9b\x02\x08\"\
    \n\r\n\x05\x04%\x02\x01\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04%\x02\
    \x01\x05\x12\x04\x9b\x02\x11\x17\n\r\n\x05\x04%\x02\x01\x01\x12\x04\x9b\
    \x02\x18\x1d\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x9b\x02\x20!\n\x0c\n\x02\
    \x04&\x12\x06\x9e\x02\0\xa0\x02\x01\n\x0b\n\x03\x04&\x01\x12\x04\x9e\x02\
    \x08\x1c\n\x0c\n\x04\x04&\x02\0\x12\x04\x9f\x02\x08.\n\r\n\x05\x04&\x02\
    \0\x04\x12\x04\x9f\x02\x08\x10\n\r\n\x05\x04&\x02\0\x06\x12\x04\x9f\x02\
    \x11!\n\r\n\x05\x04&\x02\0\x01\x12\x04\x9f\x02\")\n\r\n\x05\x04&\x02\0\
    \x03\x12\x04\x9f\x02,-\n\x0c\n\x02\x04'\x12\x06\xa2\x02\0\xa8\x02\x01\n\
    \x0b\n\x03\x04'\x01\x12\x04\xa2\x02\x08\x13\n\x0c\n\x04\x04'\x02\0\x12\
    \x04\xa3\x02\x08$\n\r\n\x05\x04'\x02\0\x04\x12\x04\xa3\x02\x08\x10\n\r\n\
    \x05\x04'\x02\0\x05\x12\x04\xa3\x02\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\
    \x04\xa3\x02\x18\x1f\n\r\n\x05\x04'\x02\0\x03\x12\x04\xa3\x02\"#\n\x0c\n\
    \x04\x04'\x02\x01\x12\x04\xa4\x02\x08-\n\r\n\x05\x04'\x02\x01\x04\x12\
    \x04\xa4\x02\x08\x10\n\r\n\x05\x04'\x02\x01\x05\x12\x04\xa4\x02\x11\x18\
    \n\r\n\x05\x04'\x02\x01\x01\x12\x04\xa4\x02\x19(\n\r\n\x05\x04'\x02\x01\
    \x03\x12\x04\xa4\x02+,\n\x0c\n\x04\x04'\x02\x02\x12\x04\xa5\x02\x084\n\r\
    \n\x05\x04'\x02\x02\x04\x12\x04\xa5\x02\x08\x10\n\r\n\x05\x04'\x02\x02\
    \x05\x12\x04\xa5\x02\x11\x17\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xa5\x02\
    \x18/\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xa5\x0223\n\x0c\n\x04\x04'\x02\
    \x03\x12\x04\xa6\x02\x08-\n\r\n\x05\x04'\x02\x03\x04\x12\x04\xa6\x02\x08\
    \x10\n\r\n\x05\x04'\x02\x03\x05\x12\x04\xa6\x02\x11\x17\n\r\n\x05\x04'\
    \x02\x03\x01\x12\x04\xa6\x02\x18(\n\r\n\x05\x04'\x02\x03\x03\x12\x04\xa6\
    \x02+,\n\x0c\n\x04\x04'\x02\x04\x12\x04\xa7\x02\x080\n\r\n\x05\x04'\x02\
    \x04\x04\x12\x04\xa7\x02\x08\x10\n\r\n\x05\x04'\x02\x04\x05\x12\x04\xa7\
    \x02\x11\x18\n\r\n\x05\x04'\x02\x04\x01\x12\x04\xa7\x02\x19+\n\r\n\x05\
    \x04'\x02\x04\x03\x12\x04\xa7\x02./\n\x0c\n\x02\x04(\x12\x06\xaa\x02\0\
    \xae\x02\x01\n\x0b\n\x03\x04(\x01\x12\x04\xaa\x02\x08#\n\x0c\n\x04\x04(\
    \x02\0\x12\x04\xab\x02\x08(\n\r\n\x05\x04(\x02\0\x04\x12\x04\xab\x02\x08\
    \x10\n\r\n\x05\x04(\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04(\x02\
    \0\x01\x12\x04\xab\x02\x18#\n\r\n\x05\x04(\x02\0\x03\x12\x04\xab\x02&'\n\
    \x0c\n\x04\x04(\x02\x01\x12\x04\xac\x02\x081\n\r\n\x05\x04(\x02\x01\x04\
    \x12\x04\xac\x02\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xac\x02\x11\
    \x17\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xac\x02\x18,\n\r\n\x05\x04(\x02\
    \x01\x03\x12\x04\xac\x02/0\n\x0c\n\x04\x04(\x02\x02\x12\x04\xad\x02\x08'\
    \n\r\n\x05\x04(\x02\x02\x04\x12\x04\xad\x02\x08\x10\n\r\n\x05\x04(\x02\
    \x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xad\
    \x02\x18\"\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xad\x02%&\n\x0c\n\x02\x04)\
    \x12\x06\xb0\x02\0\xb2\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xb0\x02\x08\
    \x1f\n\x0c\n\x04\x04)\x02\0\x12\x04\xb1\x02\x08'\n\r\n\x05\x04)\x02\0\
    \x04\x12\x04\xb1\x02\x08\x10\n\r\n\x05\x04)\x02\0\x05\x12\x04\xb1\x02\
    \x11\x16\n\r\n\x05\x04)\x02\0\x01\x12\x04\xb1\x02\x17\"\n\r\n\x05\x04)\
    \x02\0\x03\x12\x04\xb1\x02%&\n\x0c\n\x02\x04*\x12\x06\xb4\x02\0\xbc\x02\
    \x01\n\x0b\n\x03\x04*\x01\x12\x04\xb4\x02\x08(\n\x0c\n\x04\x04*\x02\0\
    \x12\x04\xb5\x02\x08'\n\r\n\x05\x04*\x02\0\x04\x12\x04\xb5\x02\x08\x10\n\
    \r\n\x05\x04*\x02\0\x05\x12\x04\xb5\x02\x11\x17\n\r\n\x05\x04*\x02\0\x01\
    \x12\x04\xb5\x02\x18\"\n\r\n\x05\x04*\x02\0\x03\x12\x04\xb5\x02%&\n\x0c\
    \n\x04\x04*\x02\x01\x12\x04\xb6\x02\x08&\n\r\n\x05\x04*\x02\x01\x04\x12\
    \x04\xb6\x02\x08\x10\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xb6\x02\x11\x17\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xb6\x02\x18!\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xb6\x02$%\n\x0c\n\x04\x04*\x02\x02\x12\x04\xb7\x02\x08&\n\r\
    \n\x05\x04*\x02\x02\x04\x12\x04\xb7\x02\x08\x10\n\r\n\x05\x04*\x02\x02\
    \x05\x12\x04\xb7\x02\x11\x17\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xb7\x02\
    \x18!\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xb7\x02$%\n\x0c\n\x04\x04*\x02\
    \x03\x12\x04\xb8\x02\x08$\n\r\n\x05\x04*\x02\x03\x04\x12\x04\xb8\x02\x08\
    \x10\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xb8\x02\x11\x17\n\r\n\x05\x04*\
    \x02\x03\x01\x12\x04\xb8\x02\x18\x1f\n\r\n\x05\x04*\x02\x03\x03\x12\x04\
    \xb8\x02\"#\n\x0c\n\x04\x04*\x02\x04\x12\x04\xb9\x02\x08#\n\r\n\x05\x04*\
    \x02\x04\x04\x12\x04\xb9\x02\x08\x10\n\r\n\x05\x04*\x02\x04\x05\x12\x04\
    \xb9\x02\x11\x17\n\r\n\x05\x04*\x02\x04\x01\x12\x04\xb9\x02\x18\x1e\n\r\
    \n\x05\x04*\x02\x04\x03\x12\x04\xb9\x02!\"\n\x0c\n\x04\x04*\x02\x05\x12\
    \x04\xba\x02\x08#\n\r\n\x05\x04*\x02\x05\x04\x12\x04\xba\x02\x08\x10\n\r\
    \n\x05\x04*\x02\x05\x05\x12\x04\xba\x02\x11\x17\n\r\n\x05\x04*\x02\x05\
    \x01\x12\x04\xba\x02\x18\x1e\n\r\n\x05\x04*\x02\x05\x03\x12\x04\xba\x02!\
    \"\n\x0c\n\x04\x04*\x02\x06\x12\x04\xbb\x02\x08$\n\r\n\x05\x04*\x02\x06\
    \x04\x12\x04\xbb\x02\x08\x10\n\r\n\x05\x04*\x02\x06\x05\x12\x04\xbb\x02\
    \x11\x17\n\r\n\x05\x04*\x02\x06\x01\x12\x04\xbb\x02\x18\x1f\n\r\n\x05\
    \x04*\x02\x06\x03\x12\x04\xbb\x02\"#\n\x0c\n\x02\x04+\x12\x06\xbe\x02\0\
    \xc6\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\xbe\x02\x08\x1c\n\x0e\n\x04\
    \x04+\x03\0\x12\x06\xbf\x02\x08\xc3\x02\t\n\r\n\x05\x04+\x03\0\x01\x12\
    \x04\xbf\x02\x10\x1c\n\x0e\n\x06\x04+\x03\0\x02\0\x12\x04\xc0\x02\x103\n\
    \x0f\n\x07\x04+\x03\0\x02\0\x04\x12\x04\xc0\x02\x10\x18\n\x0f\n\x07\x04+\
    \x03\0\x02\0\x05\x12\x04\xc0\x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\0\
    \x01\x12\x04\xc0\x02\x20.\n\x0f\n\x07\x04+\x03\0\x02\0\x03\x12\x04\xc0\
    \x0212\n\x0e\n\x06\x04+\x03\0\x02\x01\x12\x04\xc1\x02\x10-\n\x0f\n\x07\
    \x04+\x03\0\x02\x01\x04\x12\x04\xc1\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\
    \x02\x01\x05\x12\x04\xc1\x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\x01\x01\
    \x12\x04\xc1\x02\x20(\n\x0f\n\x07\x04+\x03\0\x02\x01\x03\x12\x04\xc1\x02\
    +,\n\x0e\n\x06\x04+\x03\0\x02\x02\x12\x04\xc2\x02\x10,\n\x0f\n\x07\x04+\
    \x03\0\x02\x02\x04\x12\x04\xc2\x02\x10\x18\n\x0f\n\x07\x04+\x03\0\x02\
    \x02\x05\x12\x04\xc2\x02\x19\x1f\n\x0f\n\x07\x04+\x03\0\x02\x02\x01\x12\
    \x04\xc2\x02\x20'\n\x0f\n\x07\x04+\x03\0\x02\x02\x03\x12\x04\xc2\x02*+\n\
    \x0c\n\x04\x04+\x02\0\x12\x04\xc5\x02\x08G\n\r\n\x05\x04+\x02\0\x04\x12\
    \x04\xc5\x02\x08\x10\n\r\n\x05\x04+\x02\0\x06\x12\x04\xc5\x02\x113\n\r\n\
    \x05\x04+\x02\0\x01\x12\x04\xc5\x024B\n\r\n\x05\x04+\x02\0\x03\x12\x04\
    \xc5\x02EF\n\x0c\n\x02\x04,\x12\x06\xc8\x02\0\xd0\x02\x01\n\x0b\n\x03\
    \x04,\x01\x12\x04\xc8\x02\x08\x19\n\x0c\n\x04\x04,\x02\0\x12\x04\xc9\x02\
    \x08-\n\r\n\x05\x04,\x02\0\x04\x12\x04\xc9\x02\x08\x10\n\r\n\x05\x04,\
    \x02\0\x05\x12\x04\xc9\x02\x11\x18\n\r\n\x05\x04,\x02\0\x01\x12\x04\xc9\
    \x02\x19(\n\r\n\x05\x04,\x02\0\x03\x12\x04\xc9\x02+,\n\x0c\n\x04\x04,\
    \x02\x01\x12\x04\xca\x02\x08(\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xca\x02\
    \x08\x10\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\
    \x04,\x02\x01\x01\x12\x04\xca\x02\x18#\n\r\n\x05\x04,\x02\x01\x03\x12\
    \x04\xca\x02&'\n\x0c\n\x04\x04,\x02\x02\x12\x04\xcb\x02\x08\x20\n\r\n\
    \x05\x04,\x02\x02\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04,\x02\x02\x05\
    \x12\x04\xcb\x02\x11\x17\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xcb\x02\x18\
    \x1b\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xcb\x02\x1e\x1f\n\x0c\n\x04\x04,\
    \x02\x03\x12\x04\xcc\x02\x08'\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xcc\x02\
    \x08\x10\n\r\n\x05\x04,\x02\x03\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\
    \x04,\x02\x03\x01\x12\x04\xcc\x02\x18\"\n\r\n\x05\x04,\x02\x03\x03\x12\
    \x04\xcc\x02%&\n\x0c\n\x04\x04,\x02\x04\x12\x04\xcd\x02\x08)\n\r\n\x05\
    \x04,\x02\x04\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04,\x02\x04\x05\x12\
    \x04\xcd\x02\x11\x17\n\r\n\x05\x04,\x02\x04\x01\x12\x04\xcd\x02\x18$\n\r\
    \n\x05\x04,\x02\x04\x03\x12\x04\xcd\x02'(\n\x0c\n\x04\x04,\x02\x05\x12\
    \x04\xce\x02\x083\n\r\n\x05\x04,\x02\x05\x04\x12\x04\xce\x02\x08\x10\n\r\
    \n\x05\x04,\x02\x05\x05\x12\x04\xce\x02\x11\x18\n\r\n\x05\x04,\x02\x05\
    \x01\x12\x04\xce\x02\x19.\n\r\n\x05\x04,\x02\x05\x03\x12\x04\xce\x0212\n\
    \x0c\n\x04\x04,\x02\x06\x12\x04\xcf\x02\x084\n\r\n\x05\x04,\x02\x06\x04\
    \x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04,\x02\x06\x05\x12\x04\xcf\x02\x11\
    \x17\n\r\n\x05\x04,\x02\x06\x01\x12\x04\xcf\x02\x18/\n\r\n\x05\x04,\x02\
    \x06\x03\x12\x04\xcf\x0223\n\x0c\n\x02\x04-\x12\x06\xd2\x02\0\xd6\x02\
    \x01\n\x0b\n\x03\x04-\x01\x12\x04\xd2\x02\x08!\n\x0c\n\x04\x04-\x02\0\
    \x12\x04\xd3\x02\x08-\n\r\n\x05\x04-\x02\0\x04\x12\x04\xd3\x02\x08\x10\n\
    \r\n\x05\x04-\x02\0\x05\x12\x04\xd3\x02\x11\x18\n\r\n\x05\x04-\x02\0\x01\
    \x12\x04\xd3\x02\x19(\n\r\n\x05\x04-\x02\0\x03\x12\x04\xd3\x02+,\n\x0c\n\
    \x04\x04-\x02\x01\x12\x04\xd4\x02\x08#\n\r\n\x05\x04-\x02\x01\x04\x12\
    \x04\xd4\x02\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\xd4\x02\x11\x17\
    \n\r\n\x05\x04-\x02\x01\x01\x12\x04\xd4\x02\x18\x1e\n\r\n\x05\x04-\x02\
    \x01\x03\x12\x04\xd4\x02!\"\n\x0c\n\x04\x04-\x02\x02\x12\x04\xd5\x02\x08\
    *\n\r\n\x05\x04-\x02\x02\x04\x12\x04\xd5\x02\x08\x10\n\r\n\x05\x04-\x02\
    \x02\x05\x12\x04\xd5\x02\x11\x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xd5\
    \x02\x18%\n\r\n\x05\x04-\x02\x02\x03\x12\x04\xd5\x02()\n\x0c\n\x02\x04.\
    \x12\x06\xd8\x02\0\xdc\x02\x01\n\x0b\n\x03\x04.\x01\x12\x04\xd8\x02\x08\
    \"\n\x0c\n\x04\x04.\x02\0\x12\x04\xd9\x02\x08,\n\r\n\x05\x04.\x02\0\x04\
    \x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04.\x02\0\x05\x12\x04\xd9\x02\x11\
    \x18\n\r\n\x05\x04.\x02\0\x01\x12\x04\xd9\x02\x19'\n\r\n\x05\x04.\x02\0\
    \x03\x12\x04\xd9\x02*+\n\x0c\n\x04\x04.\x02\x01\x12\x04\xda\x02\x08+\n\r\
    \n\x05\x04.\x02\x01\x04\x12\x04\xda\x02\x08\x10\n\r\n\x05\x04.\x02\x01\
    \x05\x12\x04\xda\x02\x11\x17\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xda\x02\
    \x18&\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xda\x02)*\n\x0c\n\x04\x04.\x02\
    \x02\x12\x04\xdb\x02\x08-\n\r\n\x05\x04.\x02\x02\x04\x12\x04\xdb\x02\x08\
    \x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xdb\x02\x11\x17\n\r\n\x05\x04.\
    \x02\x02\x01\x12\x04\xdb\x02\x18(\n\r\n\x05\x04.\x02\x02\x03\x12\x04\xdb\
    \x02+,\n\x0c\n\x02\x04/\x12\x06\xde\x02\0\xe3\x02\x01\n\x0b\n\x03\x04/\
    \x01\x12\x04\xde\x02\x08'\n\x0c\n\x04\x04/\x02\0\x12\x04\xdf\x02\x08@\n\
    \r\n\x05\x04/\x02\0\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04/\x02\0\x05\
    \x12\x04\xdf\x02\x11\x17\n\r\n\x05\x04/\x02\0\x01\x12\x04\xdf\x02\x18;\n\
    \r\n\x05\x04/\x02\0\x03\x12\x04\xdf\x02>?\n\x0c\n\x04\x04/\x02\x01\x12\
    \x04\xe0\x02\x08?\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xe0\x02\x08\x10\n\r\
    \n\x05\x04/\x02\x01\x05\x12\x04\xe0\x02\x11\x17\n\r\n\x05\x04/\x02\x01\
    \x01\x12\x04\xe0\x02\x18:\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xe0\x02=>\n\
    \x0c\n\x04\x04/\x02\x02\x12\x04\xe1\x02\x080\n\r\n\x05\x04/\x02\x02\x04\
    \x12\x04\xe1\x02\x08\x10\n\r\n\x05\x04/\x02\x02\x05\x12\x04\xe1\x02\x11\
    \x17\n\r\n\x05\x04/\x02\x02\x01\x12\x04\xe1\x02\x18+\n\r\n\x05\x04/\x02\
    \x02\x03\x12\x04\xe1\x02./\n\x0c\n\x04\x04/\x02\x03\x12\x04\xe2\x02\x082\
    \n\r\n\x05\x04/\x02\x03\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04/\x02\
    \x03\x05\x12\x04\xe2\x02\x11\x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xe2\
    \x02\x18-\n\r\n\x05\x04/\x02\x03\x03\x12\x04\xe2\x0201\n\x0c\n\x02\x040\
    \x12\x06\xe5\x02\0\xe7\x02\x01\n\x0b\n\x03\x040\x01\x12\x04\xe5\x02\x08\
    \x1f\n\x0c\n\x04\x040\x02\0\x12\x04\xe6\x02\x08,\n\r\n\x05\x040\x02\0\
    \x04\x12\x04\xe6\x02\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xe6\x02\
    \x11\x18\n\r\n\x05\x040\x02\0\x01\x12\x04\xe6\x02\x19'\n\r\n\x05\x040\
    \x02\0\x03\x12\x04\xe6\x02*+\n\x0c\n\x02\x041\x12\x06\xe9\x02\0\xee\x02\
    \x01\n\x0b\n\x03\x041\x01\x12\x04\xe9\x02\x08(\n\x0c\n\x04\x041\x02\0\
    \x12\x04\xea\x02\x08C\n\r\n\x05\x041\x02\0\x04\x12\x04\xea\x02\x08\x10\n\
    \r\n\x05\x041\x02\0\x05\x12\x04\xea\x02\x11\x17\n\r\n\x05\x041\x02\0\x01\
    \x12\x04\xea\x02\x18)\n\r\n\x05\x041\x02\0\x03\x12\x04\xea\x02,-\n\r\n\
    \x05\x041\x02\0\x08\x12\x04\xea\x02.B\n\x10\n\x08\x041\x02\0\x08\xe0\xd4\
    \x03\x12\x04\xea\x02/A\n\x0c\n\x04\x041\x02\x01\x12\x04\xeb\x02\x08&\n\r\
    \n\x05\x041\x02\x01\x04\x12\x04\xeb\x02\x08\x10\n\r\n\x05\x041\x02\x01\
    \x05\x12\x04\xeb\x02\x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\xeb\x02\
    \x18!\n\r\n\x05\x041\x02\x01\x03\x12\x04\xeb\x02$%\n\x0c\n\x04\x041\x02\
    \x02\x12\x04\xec\x02\x08%\n\r\n\x05\x041\x02\x02\x04\x12\x04\xec\x02\x08\
    \x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xec\x02\x11\x17\n\r\n\x05\x041\
    \x02\x02\x01\x12\x04\xec\x02\x18\x20\n\r\n\x05\x041\x02\x02\x03\x12\x04\
    \xec\x02#$\n\x0c\n\x04\x041\x02\x03\x12\x04\xed\x02\x08'\n\r\n\x05\x041\
    \x02\x03\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\x041\x02\x03\x05\x12\x04\
    \xed\x02\x11\x17\n\r\n\x05\x041\x02\x03\x01\x12\x04\xed\x02\x18\"\n\r\n\
    \x05\x041\x02\x03\x03\x12\x04\xed\x02%&\n\x0c\n\x02\x042\x12\x06\xf0\x02\
    \0\xf7\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\xf0\x02\x08\x20\n\x0c\n\x04\
    \x042\x02\0\x12\x04\xf1\x02\x08'\n\r\n\x05\x042\x02\0\x04\x12\x04\xf1\
    \x02\x08\x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xf1\x02\x11\x17\n\r\n\x05\
    \x042\x02\0\x01\x12\x04\xf1\x02\x18\"\n\r\n\x05\x042\x02\0\x03\x12\x04\
    \xf1\x02%&\n\x0c\n\x04\x042\x02\x01\x12\x04\xf2\x02\x08-\n\r\n\x05\x042\
    \x02\x01\x04\x12\x04\xf2\x02\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\
    \xf2\x02\x11\x18\n\r\n\x05\x042\x02\x01\x01\x12\x04\xf2\x02\x19(\n\r\n\
    \x05\x042\x02\x01\x03\x12\x04\xf2\x02+,\n\x0c\n\x04\x042\x02\x02\x12\x04\
    \xf3\x02\x08!\n\r\n\x05\x042\x02\x02\x04\x12\x04\xf3\x02\x08\x10\n\r\n\
    \x05\x042\x02\x02\x05\x12\x04\xf3\x02\x11\x16\n\r\n\x05\x042\x02\x02\x01\
    \x12\x04\xf3\x02\x17\x1c\n\r\n\x05\x042\x02\x02\x03\x12\x04\xf3\x02\x1f\
    \x20\n\x0c\n\x04\x042\x02\x03\x12\x04\xf4\x02\x08(\n\r\n\x05\x042\x02\
    \x03\x04\x12\x04\xf4\x02\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\xf4\
    \x02\x11\x17\n\r\n\x05\x042\x02\x03\x01\x12\x04\xf4\x02\x18#\n\r\n\x05\
    \x042\x02\x03\x03\x12\x04\xf4\x02&'\n\x0c\n\x04\x042\x02\x04\x12\x04\xf5\
    \x02\x08$\n\r\n\x05\x042\x02\x04\x04\x12\x04\xf5\x02\x08\x10\n\r\n\x05\
    \x042\x02\x04\x05\x12\x04\xf5\x02\x11\x17\n\r\n\x05\x042\x02\x04\x01\x12\
    \x04\xf5\x02\x18\x1f\n\r\n\x05\x042\x02\x04\x03\x12\x04\xf5\x02\"#\n\x0c\
    \n\x04\x042\x02\x05\x12\x04\xf6\x02\x08&\n\r\n\x05\x042\x02\x05\x04\x12\
    \x04\xf6\x02\x08\x10\n\r\n\x05\x042\x02\x05\x05\x12\x04\xf6\x02\x11\x17\
    \n\r\n\x05\x042\x02\x05\x01\x12\x04\xf6\x02\x18!\n\r\n\x05\x042\x02\x05\
    \x03\x12\x04\xf6\x02$%\n\x0c\n\x02\x043\x12\x06\xf9\x02\0\xfe\x02\x01\n\
    \x0b\n\x03\x043\x01\x12\x04\xf9\x02\x08!\n\x0c\n\x04\x043\x02\0\x12\x04\
    \xfa\x02\x08<\n\r\n\x05\x043\x02\0\x04\x12\x04\xfa\x02\x08\x10\n\r\n\x05\
    \x043\x02\0\x05\x12\x04\xfa\x02\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\
    \xfa\x02\x18\"\n\r\n\x05\x043\x02\0\x03\x12\x04\xfa\x02%&\n\r\n\x05\x043\
    \x02\0\x08\x12\x04\xfa\x02';\n\x10\n\x08\x043\x02\0\x08\xe0\xd4\x03\x12\
    \x04\xfa\x02(:\n\x0c\n\x04\x043\x02\x01\x12\x04\xfb\x02\x08;\n\r\n\x05\
    \x043\x02\x01\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x043\x02\x01\x05\x12\
    \x04\xfb\x02\x11\x17\n\r\n\x05\x043\x02\x01\x01\x12\x04\xfb\x02\x18!\n\r\
    \n\x05\x043\x02\x01\x03\x12\x04\xfb\x02$%\n\r\n\x05\x043\x02\x01\x08\x12\
    \x04\xfb\x02&:\n\x10\n\x08\x043\x02\x01\x08\xe0\xd4\x03\x12\x04\xfb\x02'\
    9\n\x0c\n\x04\x043\x02\x02\x12\x04\xfc\x02\x08\"\n\r\n\x05\x043\x02\x02\
    \x04\x12\x04\xfc\x02\x08\x10\n\r\n\x05\x043\x02\x02\x05\x12\x04\xfc\x02\
    \x11\x17\n\r\n\x05\x043\x02\x02\x01\x12\x04\xfc\x02\x18\x1d\n\r\n\x05\
    \x043\x02\x02\x03\x12\x04\xfc\x02\x20!\n\x0c\n\x04\x043\x02\x03\x12\x04\
    \xfd\x02\x08&\n\r\n\x05\x043\x02\x03\x04\x12\x04\xfd\x02\x08\x10\n\r\n\
    \x05\x043\x02\x03\x05\x12\x04\xfd\x02\x11\x17\n\r\n\x05\x043\x02\x03\x01\
    \x12\x04\xfd\x02\x18!\n\r\n\x05\x043\x02\x03\x03\x12\x04\xfd\x02$%\n\x0c\
    \n\x02\x044\x12\x06\x80\x03\0\x84\x03\x01\n\x0b\n\x03\x044\x01\x12\x04\
    \x80\x03\x08\x1e\n\x0c\n\x04\x044\x02\0\x12\x04\x81\x03\x08'\n\r\n\x05\
    \x044\x02\0\x04\x12\x04\x81\x03\x08\x10\n\r\n\x05\x044\x02\0\x05\x12\x04\
    \x81\x03\x11\x17\n\r\n\x05\x044\x02\0\x01\x12\x04\x81\x03\x18\"\n\r\n\
    \x05\x044\x02\0\x03\x12\x04\x81\x03%&\n\x0c\n\x04\x044\x02\x01\x12\x04\
    \x82\x03\x08%\n\r\n\x05\x044\x02\x01\x04\x12\x04\x82\x03\x08\x10\n\r\n\
    \x05\x044\x02\x01\x05\x12\x04\x82\x03\x11\x17\n\r\n\x05\x044\x02\x01\x01\
    \x12\x04\x82\x03\x18\x20\n\r\n\x05\x044\x02\x01\x03\x12\x04\x82\x03#$\n\
    \x0c\n\x04\x044\x02\x02\x12\x04\x83\x03\x08$\n\r\n\x05\x044\x02\x02\x04\
    \x12\x04\x83\x03\x08\x10\n\r\n\x05\x044\x02\x02\x05\x12\x04\x83\x03\x11\
    \x17\n\r\n\x05\x044\x02\x02\x01\x12\x04\x83\x03\x18\x1f\n\r\n\x05\x044\
    \x02\x02\x03\x12\x04\x83\x03\"#\n\x0c\n\x02\x045\x12\x06\x86\x03\0\x88\
    \x03\x01\n\x0b\n\x03\x045\x01\x12\x04\x86\x03\x08/\n\x0c\n\x04\x045\x02\
    \0\x12\x04\x87\x03\x08+\n\r\n\x05\x045\x02\0\x04\x12\x04\x87\x03\x08\x10\
    \n\r\n\x05\x045\x02\0\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x045\x02\0\
    \x01\x12\x04\x87\x03\x18&\n\r\n\x05\x045\x02\0\x03\x12\x04\x87\x03)*\n\
    \x0c\n\x02\x046\x12\x06\x8a\x03\0\x8c\x03\x01\n\x0b\n\x03\x046\x01\x12\
    \x04\x8a\x03\x08!\n\x0c\n\x04\x046\x02\0\x12\x04\x8b\x03\x08#\n\r\n\x05\
    \x046\x02\0\x04\x12\x04\x8b\x03\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\
    \x8b\x03\x11\x17\n\r\n\x05\x046\x02\0\x01\x12\x04\x8b\x03\x18\x1e\n\r\n\
    \x05\x046\x02\0\x03\x12\x04\x8b\x03!\"\n\x0c\n\x02\x047\x12\x06\x8e\x03\
    \0\x90\x03\x01\n\x0b\n\x03\x047\x01\x12\x04\x8e\x03\x08)\n\x0c\n\x04\x04\
    7\x02\0\x12\x04\x8f\x03\x08#\n\r\n\x05\x047\x02\0\x04\x12\x04\x8f\x03\
    \x08\x10\n\r\n\x05\x047\x02\0\x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x047\
    \x02\0\x01\x12\x04\x8f\x03\x18\x1e\n\r\n\x05\x047\x02\0\x03\x12\x04\x8f\
    \x03!\"\n\x0c\n\x02\x048\x12\x06\x92\x03\0\x94\x03\x01\n\x0b\n\x03\x048\
    \x01\x12\x04\x92\x03\x08#\n\x0c\n\x04\x048\x02\0\x12\x04\x93\x03\x08#\n\
    \r\n\x05\x048\x02\0\x04\x12\x04\x93\x03\x08\x10\n\r\n\x05\x048\x02\0\x05\
    \x12\x04\x93\x03\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\x93\x03\x18\
    \x1e\n\r\n\x05\x048\x02\0\x03\x12\x04\x93\x03!\"\n\x0c\n\x02\x049\x12\
    \x06\x96\x03\0\x99\x03\x01\n\x0b\n\x03\x049\x01\x12\x04\x96\x03\x08+\n\
    \x0c\n\x04\x049\x02\0\x12\x04\x97\x03\x08#\n\r\n\x05\x049\x02\0\x04\x12\
    \x04\x97\x03\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\x97\x03\x11\x17\n\
    \r\n\x05\x049\x02\0\x01\x12\x04\x97\x03\x18\x1e\n\r\n\x05\x049\x02\0\x03\
    \x12\x04\x97\x03!\"\n\x0c\n\x04\x049\x02\x01\x12\x04\x98\x03\x08%\n\r\n\
    \x05\x049\x02\x01\x04\x12\x04\x98\x03\x08\x10\n\r\n\x05\x049\x02\x01\x05\
    \x12\x04\x98\x03\x11\x17\n\r\n\x05\x049\x02\x01\x01\x12\x04\x98\x03\x18\
    \x20\n\r\n\x05\x049\x02\x01\x03\x12\x04\x98\x03#$\n\x0c\n\x02\x04:\x12\
    \x06\x9b\x03\0\x9e\x03\x01\n\x0b\n\x03\x04:\x01\x12\x04\x9b\x03\x08#\n\
    \x0c\n\x04\x04:\x02\0\x12\x04\x9c\x03\x08.\n\r\n\x05\x04:\x02\0\x04\x12\
    \x04\x9c\x03\x08\x10\n\r\n\x05\x04:\x02\0\x05\x12\x04\x9c\x03\x11\x17\n\
    \r\n\x05\x04:\x02\0\x01\x12\x04\x9c\x03\x18)\n\r\n\x05\x04:\x02\0\x03\
    \x12\x04\x9c\x03,-\n\x0c\n\x04\x04:\x02\x01\x12\x04\x9d\x03\x08$\n\r\n\
    \x05\x04:\x02\x01\x04\x12\x04\x9d\x03\x08\x10\n\r\n\x05\x04:\x02\x01\x05\
    \x12\x04\x9d\x03\x11\x17\n\r\n\x05\x04:\x02\x01\x01\x12\x04\x9d\x03\x18\
    \x1f\n\r\n\x05\x04:\x02\x01\x03\x12\x04\x9d\x03\"#\n\x0c\n\x02\x04;\x12\
    \x06\xa0\x03\0\xa1\x03\x01\n\x0b\n\x03\x04;\x01\x12\x04\xa0\x03\x08\"\n\
    \x0c\n\x02\x04<\x12\x06\xa3\x03\0\xa8\x03\x01\n\x0b\n\x03\x04<\x01\x12\
    \x04\xa3\x03\x08*\n\x0c\n\x04\x04<\x02\0\x12\x04\xa4\x03\x08/\n\r\n\x05\
    \x04<\x02\0\x04\x12\x04\xa4\x03\x08\x10\n\r\n\x05\x04<\x02\0\x05\x12\x04\
    \xa4\x03\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\xa4\x03\x18*\n\r\n\x05\
    \x04<\x02\0\x03\x12\x04\xa4\x03-.\n\x0c\n\x04\x04<\x02\x01\x12\x04\xa5\
    \x03\x08)\n\r\n\x05\x04<\x02\x01\x04\x12\x04\xa5\x03\x08\x10\n\r\n\x05\
    \x04<\x02\x01\x05\x12\x04\xa5\x03\x11\x17\n\r\n\x05\x04<\x02\x01\x01\x12\
    \x04\xa5\x03\x18$\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xa5\x03'(\n\x0c\n\
    \x04\x04<\x02\x02\x12\x04\xa6\x03\x08,\n\r\n\x05\x04<\x02\x02\x04\x12\
    \x04\xa6\x03\x08\x10\n\r\n\x05\x04<\x02\x02\x05\x12\x04\xa6\x03\x11\x17\
    \n\r\n\x05\x04<\x02\x02\x01\x12\x04\xa6\x03\x18'\n\r\n\x05\x04<\x02\x02\
    \x03\x12\x04\xa6\x03*+\n\x0c\n\x04\x04<\x02\x03\x12\x04\xa7\x03\x08&\n\r\
    \n\x05\x04<\x02\x03\x04\x12\x04\xa7\x03\x08\x10\n\r\n\x05\x04<\x02\x03\
    \x05\x12\x04\xa7\x03\x11\x17\n\r\n\x05\x04<\x02\x03\x01\x12\x04\xa7\x03\
    \x18!\n\r\n\x05\x04<\x02\x03\x03\x12\x04\xa7\x03$%\n\x0c\n\x02\x04=\x12\
    \x06\xaa\x03\0\xae\x03\x01\n\x0b\n\x03\x04=\x01\x12\x04\xaa\x03\x08\x18\
    \n\x0c\n\x04\x04=\x02\0\x12\x04\xab\x03\x08$\n\r\n\x05\x04=\x02\0\x04\
    \x12\x04\xab\x03\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\xab\x03\x11\
    \x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\xab\x03\x18\x1f\n\r\n\x05\x04=\x02\
    \0\x03\x12\x04\xab\x03\"#\n\x0c\n\x04\x04=\x02\x01\x12\x04\xac\x03\x08Z\
    \n\r\n\x05\x04=\x02\x01\x04\x12\x04\xac\x03\x08\x10\n\r\n\x05\x04=\x02\
    \x01\x06\x12\x04\xac\x03\x11#\n\r\n\x05\x04=\x02\x01\x01\x12\x04\xac\x03\
    $-\n\r\n\x05\x04=\x02\x01\x03\x12\x04\xac\x0301\n\r\n\x05\x04=\x02\x01\
    \x08\x12\x04\xac\x032Y\n\r\n\x05\x04=\x02\x01\x07\x12\x04\xac\x03=X\n\
    \x0c\n\x04\x04=\x02\x02\x12\x04\xad\x03\x08!\n\r\n\x05\x04=\x02\x02\x04\
    \x12\x04\xad\x03\x08\x10\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xad\x03\x11\
    \x17\n\r\n\x05\x04=\x02\x02\x01\x12\x04\xad\x03\x18\x1c\n\r\n\x05\x04=\
    \x02\x02\x03\x12\x04\xad\x03\x1f\x20\n\x0c\n\x02\x04>\x12\x06\xb0\x03\0\
    \xb3\x03\x01\n\x0b\n\x03\x04>\x01\x12\x04\xb0\x03\x08$\n\x0c\n\x04\x04>\
    \x02\0\x12\x04\xb1\x03\x08.\n\r\n\x05\x04>\x02\0\x04\x12\x04\xb1\x03\x08\
    \x10\n\r\n\x05\x04>\x02\0\x05\x12\x04\xb1\x03\x11\x17\n\r\n\x05\x04>\x02\
    \0\x01\x12\x04\xb1\x03\x18)\n\r\n\x05\x04>\x02\0\x03\x12\x04\xb1\x03,-\n\
    \x0c\n\x04\x04>\x02\x01\x12\x04\xb2\x03\x081\n\r\n\x05\x04>\x02\x01\x04\
    \x12\x04\xb2\x03\x08\x10\n\r\n\x05\x04>\x02\x01\x06\x12\x04\xb2\x03\x11\
    \"\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xb2\x03#,\n\r\n\x05\x04>\x02\x01\
    \x03\x12\x04\xb2\x03/0\n\x0c\n\x02\x04?\x12\x06\xb5\x03\0\xb7\x03\x01\n\
    \x0b\n\x03\x04?\x01\x12\x04\xb5\x03\x08)\n\x0c\n\x04\x04?\x02\0\x12\x04\
    \xb6\x03\x08=\n\r\n\x05\x04?\x02\0\x04\x12\x04\xb6\x03\x08\x10\n\r\n\x05\
    \x04?\x02\0\x06\x12\x04\xb6\x03\x11.\n\r\n\x05\x04?\x02\0\x01\x12\x04\
    \xb6\x03/8\n\r\n\x05\x04?\x02\0\x03\x12\x04\xb6\x03;<\n\x0c\n\x02\x04@\
    \x12\x06\xb9\x03\0\xbb\x03\x01\n\x0b\n\x03\x04@\x01\x12\x04\xb9\x03\x08'\
    \n\x0c\n\x04\x04@\x02\0\x12\x04\xba\x03\x08%\n\r\n\x05\x04@\x02\0\x04\
    \x12\x04\xba\x03\x08\x10\n\r\n\x05\x04@\x02\0\x05\x12\x04\xba\x03\x11\
    \x17\n\r\n\x05\x04@\x02\0\x01\x12\x04\xba\x03\x18\x20\n\r\n\x05\x04@\x02\
    \0\x03\x12\x04\xba\x03#$\n\x0c\n\x02\x04A\x12\x06\xbd\x03\0\xc2\x03\x01\
    \n\x0b\n\x03\x04A\x01\x12\x04\xbd\x03\x086\n\x0c\n\x04\x04A\x02\0\x12\
    \x04\xbe\x03\x08<\n\r\n\x05\x04A\x02\0\x04\x12\x04\xbe\x03\x08\x10\n\r\n\
    \x05\x04A\x02\0\x05\x12\x04\xbe\x03\x11\x17\n\r\n\x05\x04A\x02\0\x01\x12\
    \x04\xbe\x03\x18\"\n\r\n\x05\x04A\x02\0\x03\x12\x04\xbe\x03%&\n\r\n\x05\
    \x04A\x02\0\x08\x12\x04\xbe\x03';\n\x10\n\x08\x04A\x02\0\x08\xe0\xd4\x03\
    \x12\x04\xbe\x03(:\n\x0c\n\x04\x04A\x02\x01\x12\x04\xbf\x03\x08,\n\r\n\
    \x05\x04A\x02\x01\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04A\x02\x01\x05\
    \x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xbf\x03\x18'\
    \n\r\n\x05\x04A\x02\x01\x03\x12\x04\xbf\x03*+\n\x0c\n\x04\x04A\x02\x02\
    \x12\x04\xc0\x03\x08:\n\r\n\x05\x04A\x02\x02\x04\x12\x04\xc0\x03\x08\x10\
    \n\r\n\x05\x04A\x02\x02\x05\x12\x04\xc0\x03\x11\x17\n\r\n\x05\x04A\x02\
    \x02\x01\x12\x04\xc0\x03\x18\x20\n\r\n\x05\x04A\x02\x02\x03\x12\x04\xc0\
    \x03#$\n\r\n\x05\x04A\x02\x02\x08\x12\x04\xc0\x03%9\n\x10\n\x08\x04A\x02\
    \x02\x08\xe0\xd4\x03\x12\x04\xc0\x03&8\n\x0c\n\x04\x04A\x02\x03\x12\x04\
    \xc1\x03\x089\n\r\n\x05\x04A\x02\x03\x04\x12\x04\xc1\x03\x08\x10\n\r\n\
    \x05\x04A\x02\x03\x05\x12\x04\xc1\x03\x11\x17\n\r\n\x05\x04A\x02\x03\x01\
    \x12\x04\xc1\x03\x18\x1f\n\r\n\x05\x04A\x02\x03\x03\x12\x04\xc1\x03\"#\n\
    \r\n\x05\x04A\x02\x03\x08\x12\x04\xc1\x03$8\n\x10\n\x08\x04A\x02\x03\x08\
    \xe0\xd4\x03\x12\x04\xc1\x03%7\n\x0c\n\x02\x04B\x12\x06\xc4\x03\0\xc7\
    \x03\x01\n\x0b\n\x03\x04B\x01\x12\x04\xc4\x03\x08\x1f\n\x0c\n\x04\x04B\
    \x02\0\x12\x04\xc5\x03\x08%\n\r\n\x05\x04B\x02\0\x04\x12\x04\xc5\x03\x08\
    \x10\n\r\n\x05\x04B\x02\0\x05\x12\x04\xc5\x03\x11\x17\n\r\n\x05\x04B\x02\
    \0\x01\x12\x04\xc5\x03\x18\x20\n\r\n\x05\x04B\x02\0\x03\x12\x04\xc5\x03#\
    $\n\x0c\n\x04\x04B\x02\x01\x12\x04\xc6\x03\x08'\n\r\n\x05\x04B\x02\x01\
    \x04\x12\x04\xc6\x03\x08\x10\n\r\n\x05\x04B\x02\x01\x05\x12\x04\xc6\x03\
    \x11\x17\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xc6\x03\x18\"\n\r\n\x05\x04B\
    \x02\x01\x03\x12\x04\xc6\x03%&\n\x0c\n\x02\x04C\x12\x06\xc9\x03\0\xcc\
    \x03\x01\n\x0b\n\x03\x04C\x01\x12\x04\xc9\x03\x08'\n\x0c\n\x04\x04C\x02\
    \0\x12\x04\xca\x03\x08%\n\r\n\x05\x04C\x02\0\x04\x12\x04\xca\x03\x08\x10\
    \n\r\n\x05\x04C\x02\0\x05\x12\x04\xca\x03\x11\x17\n\r\n\x05\x04C\x02\0\
    \x01\x12\x04\xca\x03\x18\x20\n\r\n\x05\x04C\x02\0\x03\x12\x04\xca\x03#$\
    \n\x0c\n\x04\x04C\x02\x01\x12\x04\xcb\x03\x08'\n\r\n\x05\x04C\x02\x01\
    \x04\x12\x04\xcb\x03\x08\x10\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xcb\x03\
    \x11\x17\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xcb\x03\x18\"\n\r\n\x05\x04C\
    \x02\x01\x03\x12\x04\xcb\x03%&\n\x0c\n\x02\x04D\x12\x06\xce\x03\0\xd1\
    \x03\x01\n\x0b\n\x03\x04D\x01\x12\x04\xce\x03\x08\x19\n\x0c\n\x04\x04D\
    \x02\0\x12\x04\xcf\x03\x08/\n\r\n\x05\x04D\x02\0\x04\x12\x04\xcf\x03\x08\
    \x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xcf\x03\x11\x17\n\r\n\x05\x04D\x02\
    \0\x01\x12\x04\xcf\x03\x18*\n\r\n\x05\x04D\x02\0\x03\x12\x04\xcf\x03-.\n\
    \x0c\n\x04\x04D\x02\x01\x12\x04\xd0\x03\x08,\n\r\n\x05\x04D\x02\x01\x04\
    \x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xd0\x03\x11\
    \x17\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xd0\x03\x18'\n\r\n\x05\x04D\x02\
    \x01\x03\x12\x04\xd0\x03*+\n\x0c\n\x02\x04E\x12\x06\xd3\x03\0\xd4\x03\
    \x01\n\x0b\n\x03\x04E\x01\x12\x04\xd3\x03\x08\x1a\n\x0c\n\x02\x04F\x12\
    \x06\xd6\x03\0\xd8\x03\x01\n\x0b\n\x03\x04F\x01\x12\x04\xd6\x03\x08#\n\
    \x0c\n\x04\x04F\x02\0\x12\x04\xd7\x03\x08%\n\r\n\x05\x04F\x02\0\x04\x12\
    \x04\xd7\x03\x08\x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xd7\x03\x11\x17\n\
    \r\n\x05\x04F\x02\0\x01\x12\x04\xd7\x03\x18\x20\n\r\n\x05\x04F\x02\0\x03\
    \x12\x04\xd7\x03#$\n\x0c\n\x02\x04G\x12\x06\xda\x03\0\xdc\x03\x01\n\x0b\
    \n\x03\x04G\x01\x12\x04\xda\x03\x08!\n\x0c\n\x04\x04G\x02\0\x12\x04\xdb\
    \x03\x08&\n\r\n\x05\x04G\x02\0\x04\x12\x04\xdb\x03\x08\x10\n\r\n\x05\x04\
    G\x02\0\x05\x12\x04\xdb\x03\x11\x18\n\r\n\x05\x04G\x02\0\x01\x12\x04\xdb\
    \x03\x19!\n\r\n\x05\x04G\x02\0\x03\x12\x04\xdb\x03$%\n\x0c\n\x02\x04H\
    \x12\x06\xde\x03\0\xe0\x03\x01\n\x0b\n\x03\x04H\x01\x12\x04\xde\x03\x08)\
    \n\x0c\n\x04\x04H\x02\0\x12\x04\xdf\x03\x08%\n\r\n\x05\x04H\x02\0\x04\
    \x12\x04\xdf\x03\x08\x10\n\r\n\x05\x04H\x02\0\x05\x12\x04\xdf\x03\x11\
    \x15\n\r\n\x05\x04H\x02\0\x01\x12\x04\xdf\x03\x16\x20\n\r\n\x05\x04H\x02\
    \0\x03\x12\x04\xdf\x03#$\n\x0c\n\x02\x04I\x12\x06\xe2\x03\0\xe4\x03\x01\
    \n\x0b\n\x03\x04I\x01\x12\x04\xe2\x03\x08)\n\x0c\n\x04\x04I\x02\0\x12\
    \x04\xe3\x03\x08(\n\r\n\x05\x04I\x02\0\x04\x12\x04\xe3\x03\x08\x10\n\r\n\
    \x05\x04I\x02\0\x05\x12\x04\xe3\x03\x11\x17\n\r\n\x05\x04I\x02\0\x01\x12\
    \x04\xe3\x03\x18#\n\r\n\x05\x04I\x02\0\x03\x12\x04\xe3\x03&'\n\x0c\n\x02\
    \x04J\x12\x06\xe6\x03\0\xe8\x03\x01\n\x0b\n\x03\x04J\x01\x12\x04\xe6\x03\
    \x08\"\n\x0c\n\x04\x04J\x02\0\x12\x04\xe7\x03\x08+\n\r\n\x05\x04J\x02\0\
    \x04\x12\x04\xe7\x03\x08\x10\n\r\n\x05\x04J\x02\0\x05\x12\x04\xe7\x03\
    \x11\x17\n\r\n\x05\x04J\x02\0\x01\x12\x04\xe7\x03\x18&\n\r\n\x05\x04J\
    \x02\0\x03\x12\x04\xe7\x03)*\n\x0c\n\x02\x04K\x12\x06\xea\x03\0\xec\x03\
    \x01\n\x0b\n\x03\x04K\x01\x12\x04\xea\x03\x08\"\n\x0c\n\x04\x04K\x02\0\
    \x12\x04\xeb\x03\x08+\n\r\n\x05\x04K\x02\0\x04\x12\x04\xeb\x03\x08\x10\n\
    \r\n\x05\x04K\x02\0\x05\x12\x04\xeb\x03\x11\x17\n\r\n\x05\x04K\x02\0\x01\
    \x12\x04\xeb\x03\x18&\n\r\n\x05\x04K\x02\0\x03\x12\x04\xeb\x03)*\n\x0c\n\
    \x02\x04L\x12\x06\xee\x03\0\xef\x03\x01\n\x0b\n\x03\x04L\x01\x12\x04\xee\
    \x03\x08&\n\x0c\n\x02\x04M\x12\x06\xf1\x03\0\xf5\x03\x01\n\x0b\n\x03\x04\
    M\x01\x12\x04\xf1\x03\x08*\n\x0c\n\x04\x04M\x02\0\x12\x04\xf2\x03\x08&\n\
    \r\n\x05\x04M\x02\0\x04\x12\x04\xf2\x03\x08\x10\n\r\n\x05\x04M\x02\0\x05\
    \x12\x04\xf2\x03\x11\x18\n\r\n\x05\x04M\x02\0\x01\x12\x04\xf2\x03\x19!\n\
    \r\n\x05\x04M\x02\0\x03\x12\x04\xf2\x03$%\n\x0c\n\x04\x04M\x02\x01\x12\
    \x04\xf3\x03\x08&\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xf3\x03\x08\x10\n\r\
    \n\x05\x04M\x02\x01\x05\x12\x04\xf3\x03\x11\x17\n\r\n\x05\x04M\x02\x01\
    \x01\x12\x04\xf3\x03\x18!\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xf3\x03$%\n\
    \x0c\n\x04\x04M\x02\x02\x12\x04\xf4\x03\x08'\n\r\n\x05\x04M\x02\x02\x04\
    \x12\x04\xf4\x03\x08\x10\n\r\n\x05\x04M\x02\x02\x05\x12\x04\xf4\x03\x11\
    \x16\n\r\n\x05\x04M\x02\x02\x01\x12\x04\xf4\x03\x17\"\n\r\n\x05\x04M\x02\
    \x02\x03\x12\x04\xf4\x03%&\n\x0c\n\x02\x04N\x12\x06\xf7\x03\0\x90\x04\
    \x01\n\x0b\n\x03\x04N\x01\x12\x04\xf7\x03\x08\x1a\n\x0e\n\x04\x04N\x04\0\
    \x12\x06\xf8\x03\x08\xfc\x03\t\n\r\n\x05\x04N\x04\0\x01\x12\x04\xf8\x03\
    \r\x17\n\x0e\n\x06\x04N\x04\0\x02\0\x12\x04\xf9\x03\x10\x20\n\x0f\n\x07\
    \x04N\x04\0\x02\0\x01\x12\x04\xf9\x03\x10\x1b\n\x0f\n\x07\x04N\x04\0\x02\
    \0\x02\x12\x04\xf9\x03\x1e\x1f\n\x0e\n\x06\x04N\x04\0\x02\x01\x12\x04\
    \xfa\x03\x10\x19\n\x0f\n\x07\x04N\x04\0\x02\x01\x01\x12\x04\xfa\x03\x10\
    \x14\n\x0f\n\x07\x04N\x04\0\x02\x01\x02\x12\x04\xfa\x03\x17\x18\n\x0e\n\
    \x06\x04N\x04\0\x02\x02\x12\x04\xfb\x03\x10\x1a\n\x0f\n\x07\x04N\x04\0\
    \x02\x02\x01\x12\x04\xfb\x03\x10\x15\n\x0f\n\x07\x04N\x04\0\x02\x02\x02\
    \x12\x04\xfb\x03\x18\x19\n\x0c\n\x04\x04N\x02\0\x12\x04\xfe\x03\x083\n\r\
    \n\x05\x04N\x02\0\x04\x12\x04\xfe\x03\x08\x10\n\r\n\x05\x04N\x02\0\x05\
    \x12\x04\xfe\x03\x11\x18\n\r\n\x05\x04N\x02\0\x01\x12\x04\xfe\x03\x19.\n\
    \r\n\x05\x04N\x02\0\x03\x12\x04\xfe\x0312\n\x0c\n\x04\x04N\x02\x01\x12\
    \x04\xff\x03\x084\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xff\x03\x08\x10\n\r\
    \n\x05\x04N\x02\x01\x05\x12\x04\xff\x03\x11\x18\n\r\n\x05\x04N\x02\x01\
    \x01\x12\x04\xff\x03\x19/\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xff\x0323\n\
    \x0c\n\x04\x04N\x02\x02\x12\x04\x80\x04\x08(\n\r\n\x05\x04N\x02\x02\x04\
    \x12\x04\x80\x04\x08\x10\n\r\n\x05\x04N\x02\x02\x05\x12\x04\x80\x04\x11\
    \x17\n\r\n\x05\x04N\x02\x02\x01\x12\x04\x80\x04\x18#\n\r\n\x05\x04N\x02\
    \x02\x03\x12\x04\x80\x04&'\n\x0c\n\x04\x04N\x02\x03\x12\x04\x81\x04\x08+\
    \n\r\n\x05\x04N\x02\x03\x04\x12\x04\x81\x04\x08\x10\n\r\n\x05\x04N\x02\
    \x03\x05\x12\x04\x81\x04\x11\x17\n\r\n\x05\x04N\x02\x03\x01\x12\x04\x81\
    \x04\x18&\n\r\n\x05\x04N\x02\x03\x03\x12\x04\x81\x04)*\n\x0c\n\x04\x04N\
    \x02\x04\x12\x04\x82\x04\x08'\n\r\n\x05\x04N\x02\x04\x04\x12\x04\x82\x04\
    \x08\x10\n\r\n\x05\x04N\x02\x04\x05\x12\x04\x82\x04\x11\x17\n\r\n\x05\
    \x04N\x02\x04\x01\x12\x04\x82\x04\x18\"\n\r\n\x05\x04N\x02\x04\x03\x12\
    \x04\x82\x04%&\n\x0c\n\x04\x04N\x02\x05\x12\x04\x83\x04\x08-\n\r\n\x05\
    \x04N\x02\x05\x04\x12\x04\x83\x04\x08\x10\n\r\n\x05\x04N\x02\x05\x05\x12\
    \x04\x83\x04\x11\x15\n\r\n\x05\x04N\x02\x05\x01\x12\x04\x83\x04\x16(\n\r\
    \n\x05\x04N\x02\x05\x03\x12\x04\x83\x04+,\n\x0c\n\x04\x04N\x02\x06\x12\
    \x04\x84\x04\x08X\n\r\n\x05\x04N\x02\x06\x04\x12\x04\x84\x04\x08\x10\n\r\
    \n\x05\x04N\x02\x06\x06\x12\x04\x84\x04\x11/\n\r\n\x05\x04N\x02\x06\x01\
    \x12\x04\x84\x040;\n\r\n\x05\x04N\x02\x06\x03\x12\x04\x84\x04>?\n\r\n\
    \x05\x04N\x02\x06\x08\x12\x04\x84\x04@W\n\r\n\x05\x04N\x02\x06\x07\x12\
    \x04\x84\x04KV\n\x0c\n\x04\x04N\x02\x07\x12\x04\x85\x04\x08*\n\r\n\x05\
    \x04N\x02\x07\x04\x12\x04\x85\x04\x08\x10\n\r\n\x05\x04N\x02\x07\x05\x12\
    \x04\x85\x04\x11\x17\n\r\n\x05\x04N\x02\x07\x01\x12\x04\x85\x04\x18%\n\r\
    \n\x05\x04N\x02\x07\x03\x12\x04\x85\x04()\n\x0c\n\x04\x04N\x02\x08\x12\
    \x04\x86\x04\x08*\n\r\n\x05\x04N\x02\x08\x04\x12\x04\x86\x04\x08\x10\n\r\
    \n\x05\x04N\x02\x08\x05\x12\x04\x86\x04\x11\x16\n\r\n\x05\x04N\x02\x08\
    \x01\x12\x04\x86\x04\x17%\n\r\n\x05\x04N\x02\x08\x03\x12\x04\x86\x04()\n\
    \x0c\n\x04\x04N\x02\t\x12\x04\x87\x04\x085\n\r\n\x05\x04N\x02\t\x04\x12\
    \x04\x87\x04\x08\x10\n\r\n\x05\x04N\x02\t\x05\x12\x04\x87\x04\x11\x16\n\
    \r\n\x05\x04N\x02\t\x01\x12\x04\x87\x04\x17/\n\r\n\x05\x04N\x02\t\x03\
    \x12\x04\x87\x0424\n\x0c\n\x04\x04N\x02\n\x12\x04\x88\x04\x08-\n\r\n\x05\
    \x04N\x02\n\x04\x12\x04\x88\x04\x08\x10\n\r\n\x05\x04N\x02\n\x05\x12\x04\
    \x88\x04\x11\x16\n\r\n\x05\x04N\x02\n\x01\x12\x04\x88\x04\x17'\n\r\n\x05\
    \x04N\x02\n\x03\x12\x04\x88\x04*,\n\x0c\n\x04\x04N\x02\x0b\x12\x04\x89\
    \x04\x08>\n\r\n\x05\x04N\x02\x0b\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\
    \x04N\x02\x0b\x05\x12\x04\x89\x04\x11\x18\n\r\n\x05\x04N\x02\x0b\x01\x12\
    \x04\x89\x04\x198\n\r\n\x05\x04N\x02\x0b\x03\x12\x04\x89\x04;=\n\x0c\n\
    \x04\x04N\x02\x0c\x12\x04\x8a\x04\x08-\n\r\n\x05\x04N\x02\x0c\x04\x12\
    \x04\x8a\x04\x08\x10\n\r\n\x05\x04N\x02\x0c\x05\x12\x04\x8a\x04\x11\x17\
    \n\r\n\x05\x04N\x02\x0c\x01\x12\x04\x8a\x04\x18'\n\r\n\x05\x04N\x02\x0c\
    \x03\x12\x04\x8a\x04*,\n\x0c\n\x04\x04N\x02\r\x12\x04\x8b\x04\x08-\n\r\n\
    \x05\x04N\x02\r\x04\x12\x04\x8b\x04\x08\x10\n\r\n\x05\x04N\x02\r\x05\x12\
    \x04\x8b\x04\x11\x16\n\r\n\x05\x04N\x02\r\x01\x12\x04\x8b\x04\x17'\n\r\n\
    \x05\x04N\x02\r\x03\x12\x04\x8b\x04*,\n\x0c\n\x04\x04N\x02\x0e\x12\x04\
    \x8c\x04\x084\n\r\n\x05\x04N\x02\x0e\x04\x12\x04\x8c\x04\x08\x10\n\r\n\
    \x05\x04N\x02\x0e\x05\x12\x04\x8c\x04\x11\x16\n\r\n\x05\x04N\x02\x0e\x01\
    \x12\x04\x8c\x04\x17.\n\r\n\x05\x04N\x02\x0e\x03\x12\x04\x8c\x0413\n\x0c\
    \n\x04\x04N\x02\x0f\x12\x04\x8d\x04\x08;\n\r\n\x05\x04N\x02\x0f\x04\x12\
    \x04\x8d\x04\x08\x10\n\r\n\x05\x04N\x02\x0f\x05\x12\x04\x8d\x04\x11\x18\
    \n\r\n\x05\x04N\x02\x0f\x01\x12\x04\x8d\x04\x195\n\r\n\x05\x04N\x02\x0f\
    \x03\x12\x04\x8d\x048:\n\x0c\n\x04\x04N\x02\x10\x12\x04\x8e\x04\x080\n\r\
    \n\x05\x04N\x02\x10\x04\x12\x04\x8e\x04\x08\x10\n\r\n\x05\x04N\x02\x10\
    \x05\x12\x04\x8e\x04\x11\x17\n\r\n\x05\x04N\x02\x10\x01\x12\x04\x8e\x04\
    \x18*\n\r\n\x05\x04N\x02\x10\x03\x12\x04\x8e\x04-/\n\x0c\n\x04\x04N\x02\
    \x11\x12\x04\x8f\x04\x08-\n\r\n\x05\x04N\x02\x11\x04\x12\x04\x8f\x04\x08\
    \x10\n\r\n\x05\x04N\x02\x11\x05\x12\x04\x8f\x04\x11\x18\n\r\n\x05\x04N\
    \x02\x11\x01\x12\x04\x8f\x04\x19'\n\r\n\x05\x04N\x02\x11\x03\x12\x04\x8f\
    \x04*,\n\x0c\n\x02\x04O\x12\x06\x92\x04\0\x98\x04\x01\n\x0b\n\x03\x04O\
    \x01\x12\x04\x92\x04\x08\x18\n\x0c\n\x04\x04O\x02\0\x12\x04\x93\x04\x08<\
    \n\r\n\x05\x04O\x02\0\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04O\x02\0\
    \x05\x12\x04\x93\x04\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\x93\x04\
    \x18\"\n\r\n\x05\x04O\x02\0\x03\x12\x04\x93\x04%&\n\r\n\x05\x04O\x02\0\
    \x08\x12\x04\x93\x04';\n\x10\n\x08\x04O\x02\0\x08\xe0\xd4\x03\x12\x04\
    \x93\x04(:\n\x0c\n\x04\x04O\x02\x01\x12\x04\x94\x04\x08:\n\r\n\x05\x04O\
    \x02\x01\x04\x12\x04\x94\x04\x08\x10\n\r\n\x05\x04O\x02\x01\x05\x12\x04\
    \x94\x04\x11\x17\n\r\n\x05\x04O\x02\x01\x01\x12\x04\x94\x04\x18\x20\n\r\
    \n\x05\x04O\x02\x01\x03\x12\x04\x94\x04#$\n\r\n\x05\x04O\x02\x01\x08\x12\
    \x04\x94\x04%9\n\x10\n\x08\x04O\x02\x01\x08\xe0\xd4\x03\x12\x04\x94\x04&\
    8\n\x0c\n\x04\x04O\x02\x02\x12\x04\x95\x04\x089\n\r\n\x05\x04O\x02\x02\
    \x04\x12\x04\x95\x04\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\x04\x95\x04\
    \x11\x17\n\r\n\x05\x04O\x02\x02\x01\x12\x04\x95\x04\x18\x1f\n\r\n\x05\
    \x04O\x02\x02\x03\x12\x04\x95\x04\"#\n\r\n\x05\x04O\x02\x02\x08\x12\x04\
    \x95\x04$8\n\x10\n\x08\x04O\x02\x02\x08\xe0\xd4\x03\x12\x04\x95\x04%7\n\
    \x0c\n\x04\x04O\x02\x03\x12\x04\x96\x04\x08$\n\r\n\x05\x04O\x02\x03\x04\
    \x12\x04\x96\x04\x08\x10\n\r\n\x05\x04O\x02\x03\x05\x12\x04\x96\x04\x11\
    \x17\n\r\n\x05\x04O\x02\x03\x01\x12\x04\x96\x04\x18\x1f\n\r\n\x05\x04O\
    \x02\x03\x03\x12\x04\x96\x04\"#\n\x0c\n\x04\x04O\x02\x04\x12\x04\x97\x04\
    \x08,\n\r\n\x05\x04O\x02\x04\x04\x12\x04\x97\x04\x08\x10\n\r\n\x05\x04O\
    \x02\x04\x05\x12\x04\x97\x04\x11\x17\n\r\n\x05\x04O\x02\x04\x01\x12\x04\
    \x97\x04\x18'\n\r\n\x05\x04O\x02\x04\x03\x12\x04\x97\x04*+\n\x0c\n\x02\
    \x04P\x12\x06\x9a\x04\0\x9e\x04\x01\n\x0b\n\x03\x04P\x01\x12\x04\x9a\x04\
    \x08\x1b\n\x0c\n\x04\x04P\x02\0\x12\x04\x9b\x04\x08%\n\r\n\x05\x04P\x02\
    \0\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\x9b\x04\
    \x11\x17\n\r\n\x05\x04P\x02\0\x01\x12\x04\x9b\x04\x18\x20\n\r\n\x05\x04P\
    \x02\0\x03\x12\x04\x9b\x04#$\n\x0c\n\x04\x04P\x02\x01\x12\x04\x9c\x04\
    \x08$\n\r\n\x05\x04P\x02\x01\x04\x12\x04\x9c\x04\x08\x10\n\r\n\x05\x04P\
    \x02\x01\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04P\x02\x01\x01\x12\x04\
    \x9c\x04\x18\x1f\n\r\n\x05\x04P\x02\x01\x03\x12\x04\x9c\x04\"#\n\x0c\n\
    \x04\x04P\x02\x02\x12\x04\x9d\x04\x08$\n\r\n\x05\x04P\x02\x02\x04\x12\
    \x04\x9d\x04\x08\x10\n\r\n\x05\x04P\x02\x02\x05\x12\x04\x9d\x04\x11\x17\
    \n\r\n\x05\x04P\x02\x02\x01\x12\x04\x9d\x04\x18\x1f\n\r\n\x05\x04P\x02\
    \x02\x03\x12\x04\x9d\x04\"#\n\x0c\n\x02\x04Q\x12\x06\xa0\x04\0\xa2\x04\
    \x01\n\x0b\n\x03\x04Q\x01\x12\x04\xa0\x04\x08\x1c\n\x0c\n\x04\x04Q\x02\0\
    \x12\x04\xa1\x04\x080\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xa1\x04\x08\x10\n\
    \r\n\x05\x04Q\x02\0\x06\x12\x04\xa1\x04\x11%\n\r\n\x05\x04Q\x02\0\x01\
    \x12\x04\xa1\x04&+\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xa1\x04./\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(83);
            messages.push(CGCStorePurchaseInit_LineItem::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInit::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseInitResponse::generated_message_descriptor_data());
            messages.push(CSOPartyInvite::generated_message_descriptor_data());
            messages.push(CSOLobbyInvite::generated_message_descriptor_data());
            messages.push(CMsgSystemBroadcast::generated_message_descriptor_data());
            messages.push(CMsgInviteToParty::generated_message_descriptor_data());
            messages.push(CMsgInvitationCreated::generated_message_descriptor_data());
            messages.push(CMsgPartyInviteResponse::generated_message_descriptor_data());
            messages.push(CMsgKickFromParty::generated_message_descriptor_data());
            messages.push(CMsgLeaveParty::generated_message_descriptor_data());
            messages.push(CMsgServerAvailable::generated_message_descriptor_data());
            messages.push(CMsgLANServerAvailable::generated_message_descriptor_data());
            messages.push(CSOEconGameAccountClient::generated_message_descriptor_data());
            messages.push(CSOItemCriteriaCondition::generated_message_descriptor_data());
            messages.push(CSOItemCriteria::generated_message_descriptor_data());
            messages.push(CSOItemRecipe::generated_message_descriptor_data());
            messages.push(CMsgDevNewItemRequest::generated_message_descriptor_data());
            messages.push(CMsgIncrementKillCountAttribute::generated_message_descriptor_data());
            messages.push(CMsgApplySticker::generated_message_descriptor_data());
            messages.push(CMsgModifyItemAttribute::generated_message_descriptor_data());
            messages.push(CMsgApplyStatTrakSwap::generated_message_descriptor_data());
            messages.push(CMsgApplyStrangePart::generated_message_descriptor_data());
            messages.push(CMsgApplyPennantUpgrade::generated_message_descriptor_data());
            messages.push(CMsgApplyEggEssence::generated_message_descriptor_data());
            messages.push(CSOEconItemAttribute::generated_message_descriptor_data());
            messages.push(CSOEconItemEquipped::generated_message_descriptor_data());
            messages.push(CSOEconItem::generated_message_descriptor_data());
            messages.push(CMsgAdjustItemEquippedState::generated_message_descriptor_data());
            messages.push(CMsgAdjustItemEquippedStateMulti::generated_message_descriptor_data());
            messages.push(CMsgSortItems::generated_message_descriptor_data());
            messages.push(CSOEconClaimCode::generated_message_descriptor_data());
            messages.push(CMsgStoreGetUserData::generated_message_descriptor_data());
            messages.push(CMsgStoreGetUserDataResponse::generated_message_descriptor_data());
            messages.push(CMsgUpdateItemSchema::generated_message_descriptor_data());
            messages.push(CMsgGCError::generated_message_descriptor_data());
            messages.push(CMsgRequestInventoryRefresh::generated_message_descriptor_data());
            messages.push(CMsgConVarValue::generated_message_descriptor_data());
            messages.push(CMsgReplicateConVars::generated_message_descriptor_data());
            messages.push(CMsgUseItem::generated_message_descriptor_data());
            messages.push(CMsgReplayUploadedToYouTube::generated_message_descriptor_data());
            messages.push(CMsgConsumableExhausted::generated_message_descriptor_data());
            messages.push(CMsgItemAcknowledged__DEPRECATED::generated_message_descriptor_data());
            messages.push(CMsgSetItemPositions::generated_message_descriptor_data());
            messages.push(CMsgGCReportAbuse::generated_message_descriptor_data());
            messages.push(CMsgGCReportAbuseResponse::generated_message_descriptor_data());
            messages.push(CMsgGCNameItemNotification::generated_message_descriptor_data());
            messages.push(CMsgGCClientDisplayNotification::generated_message_descriptor_data());
            messages.push(CMsgGCShowItemsPickedUp::generated_message_descriptor_data());
            messages.push(CMsgGCIncrementKillCountResponse::generated_message_descriptor_data());
            messages.push(CSOEconItemDropRateBonus::generated_message_descriptor_data());
            messages.push(CSOEconItemLeagueViewPass::generated_message_descriptor_data());
            messages.push(CSOEconItemEventTicket::generated_message_descriptor_data());
            messages.push(CMsgGCItemPreviewItemBoughtNotification::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancel::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseCancelResponse::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalize::generated_message_descriptor_data());
            messages.push(CMsgGCStorePurchaseFinalizeResponse::generated_message_descriptor_data());
            messages.push(CMsgGCBannedWordListRequest::generated_message_descriptor_data());
            messages.push(CMsgGCRequestAnnouncements::generated_message_descriptor_data());
            messages.push(CMsgGCRequestAnnouncementsResponse::generated_message_descriptor_data());
            messages.push(CMsgGCBannedWord::generated_message_descriptor_data());
            messages.push(CMsgGCBannedWordListResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBannedWordListBroadcast::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBannedWordListUpdated::generated_message_descriptor_data());
            messages.push(CSOEconDefaultEquippedDefinitionInstanceClient::generated_message_descriptor_data());
            messages.push(CMsgGCToGCDirtySDOCache::generated_message_descriptor_data());
            messages.push(CMsgGCToGCDirtyMultipleSDOCache::generated_message_descriptor_data());
            messages.push(CMsgGCCollectItem::generated_message_descriptor_data());
            messages.push(CMsgSDONoMemcached::generated_message_descriptor_data());
            messages.push(CMsgGCToGCUpdateSQLKeyValue::generated_message_descriptor_data());
            messages.push(CMsgGCToGCIsTrustedServer::generated_message_descriptor_data());
            messages.push(CMsgGCToGCIsTrustedServerResponse::generated_message_descriptor_data());
            messages.push(CMsgGCToGCBroadcastConsoleCommand::generated_message_descriptor_data());
            messages.push(CMsgGCServerVersionUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCClientVersionUpdated::generated_message_descriptor_data());
            messages.push(CMsgGCToGCWebAPIAccountChanged::generated_message_descriptor_data());
            messages.push(CMsgGCToGCRequestPassportItemGrant::generated_message_descriptor_data());
            messages.push(CMsgGameServerInfo::generated_message_descriptor_data());
            messages.push(CSOEconEquipSlot::generated_message_descriptor_data());
            messages.push(CMsgAdjustEquipSlot::generated_message_descriptor_data());
            messages.push(CMsgAdjustEquipSlots::generated_message_descriptor_data());
            messages.push(cmsg_set_item_positions::ItemPosition::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EGCBaseMsg::generated_enum_descriptor_data());
            enums.push(EGCBaseProtoObjectTypes::generated_enum_descriptor_data());
            enums.push(GC_BannedWordType::generated_enum_descriptor_data());
            enums.push(cmsg_game_server_info::ServerType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
